"use strict";
// https://githb.com/neovim/nvim-lspconfi/blob/e38ff05afc3ad5d4fa8b24b4b0619429125582de/la/nvim_lsp/sumneko_lua.lua
Object.defineProperty(exports, "__esModule", { value: true });
exports.luaLsCommandAndArgs = exports.installLuaLs = exports.checkForUpdate = exports.osEnv = exports.install = void 0;
const tslib_1 = require("tslib");
const crypto = tslib_1.__importStar(require("crypto"));
const fs = tslib_1.__importStar(require("fs"));
const https = tslib_1.__importStar(require("https"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const tar = tslib_1.__importStar(require("tar"));
const coc_nvim_1 = require("coc.nvim");
const config_1 = require("./config");
const tools_1 = require("./tools");
const db_1 = require("./db");
const luaLsDir = "sumneko-lua-ls";
const oneDayMS = 24 * 60 * 60 * 1000;
const fsp = fs.promises;
const osPlatform = os.platform();
const tmpBaseDir = os.tmpdir();
const { join } = path;
function releaseDownloadsURL(filePath) {
    return config_1.getConfig().installPreReleases
        ? `https://github.com/josa42/coc-lua-binaries/releases/download/latest/${filePath}`
        : `https://github.com/josa42/coc-lua-binaries/releases/latest/download/${filePath}`;
}
function install(dir) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { tarFile } = osEnv();
        yield downloadTar(releaseDownloadsURL(tarFile), dir);
    });
}
exports.install = install;
function downloadTar(sourceUrl, targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const dir = yield mkTmpDir(sourceUrl);
        const tarTmpPath = join(dir.path, "tmp.tar.gz");
        yield download(sourceUrl, tarTmpPath);
        yield tar.x({ file: tarTmpPath, cwd: targetPath, strip: 1 });
        yield dir.dispose();
    });
}
function mkTmpDir(key) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const hash = crypto.createHash("md5").update(key).digest("hex");
        const dir = join(tmpBaseDir, hash);
        yield fsp.mkdir(dir, { recursive: true });
        return { path: dir, dispose: () => tslib_1.__awaiter(this, void 0, void 0, function* () { return fsp.rmdir(dir, { recursive: true }); }) };
    });
}
function download(sourceUrl, targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const file = fs.createWriteStream(targetPath);
        return new Promise((resolve, reject) => {
            const get = (url) => https.get(url, (res) => {
                const { statusCode } = res;
                if (statusCode === 301 || statusCode === 302) {
                    return get(res.headers.location);
                }
                res
                    .on("data", (data) => file.write(data))
                    .on("end", () => (file.end(), setTimeout(() => resolve(), 5)))
                    .on("error", (err) => reject(err));
            });
            return get(sourceUrl);
        });
    });
}
function osEnv() {
    switch (osPlatform) {
        case "darwin":
            return {
                tarFile: "lua-language-server-macos.tar.gz",
                bin: join("bin", "macOS", "lua-language-server"),
            };
        case "linux":
            return {
                tarFile: "lua-language-server-linux.tar.gz",
                bin: join("bin", "Linux", "lua-language-server"),
            };
        case "win32":
            return {
                tarFile: "lua-language-server-windows.tar.gz",
                bin: join("bin", "Windows", "lua-language-server.exe"),
            };
    }
    return { tarFile: "", bin: "" };
}
exports.osEnv = osEnv;
function checkForUpdate(action) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!(yield shouldCheck())) {
            return;
        }
        const statusItem = coc_nvim_1.window.createStatusBarItem(90, { progress: true });
        statusItem.text = "Check for updates";
        statusItem.show();
        try {
            const rinfo = yield getVersionInfo();
            const linfo = yield getVersionInstalledInfo();
            if (new Date(rinfo.date) > new Date(linfo.date)) {
                handleUpdateAction(action, rinfo.version);
            }
        }
        catch (err) {
            coc_nvim_1.window.showMessage(JSON.stringify(err), "error");
        }
        statusItem.hide();
    });
}
exports.checkForUpdate = checkForUpdate;
function shouldCheck() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const now = new Date().getTime();
        const last = yield db_1.dbGet("last-update-check", -1);
        const diff = now - last;
        if (last === -1 || diff > oneDayMS) {
            yield db_1.dbSet("last-update-check", now);
            return true;
        }
        return false;
    });
}
function handleUpdateAction(action, version) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        switch (action) {
            case "ask":
                if (yield coc_nvim_1.window.showPrompt(`sumneko/lua-language-server ${version} is available. Install?`)) {
                    installLuaLs(true);
                }
                break;
            case "install":
                installLuaLs(true);
                break;
            case "inform":
                coc_nvim_1.window.showMessage(`sumneko/lua-language-server ${version} is available. Run ":CocCommand lua.update"`);
                break;
        }
    });
}
function installLuaLs(force = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!force && (yield luaLsExists())) {
            return;
        }
        yield tools_1.showInstallStatus("sumneko/lua-language-server", () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield install(yield config_1.configDir(luaLsDir));
        }));
    });
}
exports.installLuaLs = installLuaLs;
function luaLsCommandAndArgs() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const baseDir = yield config_1.configDir(luaLsDir);
        const { bin } = osEnv();
        return [path.join(baseDir, bin), ["-E", path.join(baseDir, "main.lua")]];
    });
}
exports.luaLsCommandAndArgs = luaLsCommandAndArgs;
function luaLsExists() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const [bin] = yield luaLsCommandAndArgs();
        return new Promise((resolve) => fs.open(bin, "r", (err) => resolve(err === null)));
    });
}
function getVersionInstalledInfo() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const fpath = path.join(yield config_1.configDir(luaLsDir), "version.json");
            return JSON.parse(yield fs.promises.readFile(fpath, "utf-8"));
        }
        catch (err) {
            if (err.code !== "ENOENT") {
                coc_nvim_1.window.showMessage(JSON.stringify(err), "error");
            }
            return { date: "", version: "", commit: "" };
        }
    });
}
function getVersionInfo() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const get = (url) => https.get(url, (res) => {
                const { statusCode } = res;
                if (statusCode === 301 || statusCode === 302) {
                    return get(res.headers.location);
                }
                let out = "";
                res
                    .on("data", (data) => (out += data))
                    .on("end", () => resolve(JSON.parse(out)))
                    .on("error", (err) => reject(err));
            });
            return get(releaseDownloadsURL("version.json"));
        });
    });
}
//# sourceMappingURL=installer.js.map