"use strict";
// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.deactivate = exports.activate = void 0;
const coc_nvim_1 = require("coc.nvim");
const semver = require("semver");
const cmds = require("./commands");
const constants_1 = require("./constants");
const lsp_extensions_1 = require("./lsp_extensions");
/** Assert that the condition is "truthy", otherwise throw. */
function assert(cond, msg = "Assertion failed.") {
    if (!cond) {
        throw new Error(msg);
    }
}
const SERVER_SEMVER = ">=1.9.0";
const SERVER_SEMVER_16 = ">=1.16.0";
const settingsKeys = [
    "cache",
    "codeLens",
    "config",
    "enable",
    "importMap",
    "internalDebug",
    "lint",
    "suggest",
    "unstable",
];
function getSettings() {
    var _a, _b;
    const settings = coc_nvim_1.workspace.getConfiguration(constants_1.EXTENSION_NS);
    const result = Object.create(null);
    for (const key of settingsKeys) {
        const value = settings.inspect(key);
        assert(value);
        result[key] = (_b = (_a = value.workspaceValue) !== null && _a !== void 0 ? _a : value.globalValue) !== null && _b !== void 0 ? _b : value.defaultValue;
    }
    return result;
}
let client;
let serverVersion = "";
class DenoTextDocumentContentProvider {
    constructor(client) {
        this.client = client;
    }
    provideTextDocumentContent(uri, token) {
        let res = uri.toString();
        let PATCH_8_2_3468 = false;
        if (res.startsWith("file:")) {
            PATCH_8_2_3468 = true;
            res = res.replace(`file:\/\/${process.cwd()}/`, "").replace("%3A", ":"); //lgtm [js/incomplete-sanitization]
        }
        if (semver.valid(serverVersion)) {
            if (semver.satisfies(serverVersion, SERVER_SEMVER_16)) {
                res = res.replace("deno:/asset", "deno:asset");
            }
            else if (PATCH_8_2_3468) {
                res = res.replace("deno:/asset", "deno:/asset/");
            }
        }
        return this.client.sendRequest(lsp_extensions_1.virtualTextDocument, { textDocument: { uri: res } }, token);
    }
}
async function tryActivate(context) {
    var _a, _b, _c;
    await cmds.checkTSServer();
    const command = coc_nvim_1.workspace.getConfiguration(constants_1.EXTENSION_NS).get("path", "deno");
    const run = {
        command,
        args: ["lsp"],
        options: { env: { ...process.env, "NO_COLOR": true } },
    };
    const docSet = new Set();
    const clientOptions = {
        documentSelector: [
            { scheme: "file", language: "json" },
            { scheme: "file", language: "jsonc" },
            { scheme: "file", language: "markdown" },
            { scheme: "file", language: "javascript" },
            { scheme: "file", language: "javascriptreact" },
            { scheme: "file", language: "typescript" },
            { scheme: "file", language: "typescriptreact" },
            { scheme: "deno", language: "javascript" },
            { scheme: "deno", language: "javascriptreact" },
            { scheme: "deno", language: "typescript" },
            { scheme: "deno", language: "typescriptreact" },
        ],
        diagnosticCollectionName: constants_1.EXTENSION_NS,
        initializationOptions: getSettings(),
        middleware: {
            didOpen: (data, next) => {
                const fsPath = coc_nvim_1.Uri.parse(data.uri).fsPath;
                if (fsPath.includes("deno:asset") || fsPath.includes("deno:/asset")) {
                    return;
                }
                next(data);
            },
            provideDefinition: async (document, position, token, next) => {
                if (docSet.has(document.uri))
                    return;
                docSet.add(document.uri);
                const def = await next(document, position, token);
                docSet.delete(document.uri);
                if (semver.satisfies(serverVersion, SERVER_SEMVER_16)) {
                    if (def && Array.isArray(def)) {
                        def.map((d) => {
                            if (coc_nvim_1.LocationLink.is(d) && d.targetUri.startsWith("deno:asset")) {
                                d.targetUri = d.targetUri.replace("deno:asset", "deno:/asset");
                            }
                        });
                    }
                }
                return def;
            },
        },
    };
    client = new coc_nvim_1.LanguageClient(constants_1.EXTENSION_NS, run, clientOptions);
    const statusBarItem = coc_nvim_1.window.createStatusBarItem(0);
    context.subscriptions.push(statusBarItem);
    context.subscriptions.push(coc_nvim_1.workspace.onDidChangeConfiguration((evt) => {
        if (evt.affectsConfiguration(constants_1.EXTENSION_NS)) {
            client.sendNotification("workspace/didChangeConfiguration", 
            // We actually set this to empty because the language server will
            // call back and get the configuration. There can be issues with the
            // information on the event not being reliable.
            { settings: null });
            coc_nvim_1.commands.executeCommand("deno.restart");
        }
    }), 
    // Register a content provider for Deno resolved read-only files.
    coc_nvim_1.workspace.registerTextDocumentContentProvider(constants_1.EXTENSION_NS, new DenoTextDocumentContentProvider(client)));
    const registerCommand = createRegisterCommand(context);
    registerCommand("cache", cmds.cache);
    registerCommand("status", cmds.status);
    registerCommand("restart", cmds.restart);
    registerCommand("reloadImportRegistries", cmds.reloadImportRegistries);
    registerCommand("initializeWorkspace", cmds.initializeWorkspace);
    coc_nvim_1.commands.registerCommand(`${constants_1.EXTENSION_NS}.test`, cmds.test, null, true);
    coc_nvim_1.commands.registerCommand(`${constants_1.EXTENSION_NS}.showReferences`, cmds.showReferences, null, true);
    context.subscriptions.push(client.start());
    await client.onReady();
    client.onNotification(lsp_extensions_1.registryState, createRegistryStateHandler());
    serverVersion =
        ((_c = (_b = (_a = client.initializeResult) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) !== null && _c !== void 0 ? _c : "").split(" ")[0];
    if (serverVersion) {
        statusBarItem.text = `Deno ${serverVersion}`;
        statusBarItem.show();
    }
    if (semver.valid(serverVersion) &&
        !semver.satisfies(serverVersion, SERVER_SEMVER)) {
        coc_nvim_1.window.showMessage(`The version of Deno ("${serverVersion}") does not meet the requirements of version ("${SERVER_SEMVER}"), please upgrade Deno.`, "warning");
    }
}
async function activate(context) {
    const enable = coc_nvim_1.workspace.getConfiguration(constants_1.EXTENSION_NS).get("enable", false);
    if (!enable) {
        context.subscriptions.push(coc_nvim_1.commands.registerCommand(`${constants_1.EXTENSION_NS}.initializeWorkspace`, async () => {
            await cmds.doInitialize();
            await tryActivate(context);
        }));
        return;
    }
    await tryActivate(context);
}
exports.activate = activate;
function deactivate() {
    return client === null || client === void 0 ? void 0 : client.stop();
}
exports.deactivate = deactivate;
/** Internal function factory that returns a registerCommand function that is
 * bound to the extension context. */
function createRegisterCommand(context) {
    return function registerCommand(name, factory) {
        const fullName = `${constants_1.EXTENSION_NS}.${name}`;
        const command = factory(context, client);
        context.subscriptions.push(coc_nvim_1.commands.registerCommand(fullName, command));
    };
}
function createRegistryStateHandler() {
    return async function handler(p) {
        if (p.suggestions) {
            const selection = await coc_nvim_1.window.showInformationMessage(`The server "${p.origin}" supports completion suggestions for imports. Do you wish to enable this? (Only do this if you trust "${p.origin}") [Learn More](https://github.com/denoland/vscode_deno/blob/main/docs/ImportCompletions.md)`, "No", "Enable");
            const enable = selection === "Enable";
            const config = coc_nvim_1.workspace.getConfiguration("deno.suggest.imports");
            const hosts = config.get("hosts", {});
            hosts[p.origin] = enable;
            config.update("hosts", hosts);
        }
    };
}
//# sourceMappingURL=extension.js.map