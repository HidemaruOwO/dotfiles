var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, {get: all[name2], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS((exports2, module2) => {
  var Node = class {
    constructor(value) {
      this.value = value;
      this.next = void 0;
    }
  };
  var Queue = class {
    constructor() {
      this.clear();
    }
    enqueue(value) {
      const node = new Node(value);
      if (this._head) {
        this._tail.next = node;
        this._tail = node;
      } else {
        this._head = node;
        this._tail = node;
      }
      this._size++;
    }
    dequeue() {
      const current = this._head;
      if (!current) {
        return;
      }
      this._head = this._head.next;
      this._size--;
      return current.value;
    }
    clear() {
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    *[Symbol.iterator]() {
      let current = this._head;
      while (current) {
        yield current.value;
        current = current.next;
      }
    }
  };
  module2.exports = Queue;
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS((exports2, module2) => {
  "use strict";
  var Queue = require_yocto_queue();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    }
    const queue = new Queue();
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.size > 0) {
        queue.dequeue()();
      }
    };
    const run = async (fn, resolve2, ...args) => {
      activeCount++;
      const result = (async () => fn(...args))();
      resolve2(result);
      try {
        await result;
      } catch {
      }
      next();
    };
    const enqueue = (fn, resolve2, ...args) => {
      queue.enqueue(run.bind(null, fn, resolve2, ...args));
      (async () => {
        await Promise.resolve();
        if (activeCount < concurrency && queue.size > 0) {
          queue.dequeue()();
        }
      })();
    };
    const generator = (fn, ...args) => new Promise((resolve2) => {
      enqueue(fn, resolve2, ...args);
    });
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.size
      },
      clearQueue: {
        value: () => {
          queue.clear();
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
});

// node_modules/p-locate/index.js
var require_p_locate = __commonJS((exports2, module2) => {
  "use strict";
  var pLimit = require_p_limit();
  var EndError = class extends Error {
    constructor(value) {
      super();
      this.value = value;
    }
  };
  var testElement = async (element, tester) => tester(await element);
  var finder = async (element) => {
    const values = await Promise.all(element);
    if (values[1] === true) {
      throw new EndError(values[0]);
    }
    return false;
  };
  var pLocate = async (iterable, tester, options) => {
    options = {
      concurrency: Infinity,
      preserveOrder: true,
      ...options
    };
    const limit = pLimit(options.concurrency);
    const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
    try {
      await Promise.all(items.map((element) => checkLimit(finder, element)));
    } catch (error) {
      if (error instanceof EndError) {
        return error.value;
      }
      throw error;
    }
  };
  module2.exports = pLocate;
});

// node_modules/locate-path/index.js
var require_locate_path = __commonJS((exports2, module2) => {
  "use strict";
  var path5 = require("path");
  var fs4 = require("fs");
  var {promisify: promisify2} = require("util");
  var pLocate = require_p_locate();
  var fsStat = promisify2(fs4.stat);
  var fsLStat = promisify2(fs4.lstat);
  var typeMappings = {
    directory: "isDirectory",
    file: "isFile"
  };
  function checkType({type}) {
    if (type in typeMappings) {
      return;
    }
    throw new Error(`Invalid type specified: ${type}`);
  }
  var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
  module2.exports = async (paths, options) => {
    options = {
      cwd: process.cwd(),
      type: "file",
      allowSymlinks: true,
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fsStat : fsLStat;
    return pLocate(paths, async (path_) => {
      try {
        const stat = await statFn(path5.resolve(options.cwd, path_));
        return matchType(options.type, stat);
      } catch {
        return false;
      }
    }, options);
  };
  module2.exports.sync = (paths, options) => {
    options = {
      cwd: process.cwd(),
      allowSymlinks: true,
      type: "file",
      ...options
    };
    checkType(options);
    const statFn = options.allowSymlinks ? fs4.statSync : fs4.lstatSync;
    for (const path_ of paths) {
      try {
        const stat = statFn(path5.resolve(options.cwd, path_));
        if (matchType(options.type, stat)) {
          return path_;
        }
      } catch {
      }
    }
  };
});

// node_modules/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  var fs4 = require("fs");
  var {promisify: promisify2} = require("util");
  var pAccess = promisify2(fs4.access);
  module2.exports = async (path5) => {
    try {
      await pAccess(path5);
      return true;
    } catch (_) {
      return false;
    }
  };
  module2.exports.sync = (path5) => {
    try {
      fs4.accessSync(path5);
      return true;
    } catch (_) {
      return false;
    }
  };
});

// node_modules/find-up/index.js
var require_find_up = __commonJS((exports2, module2) => {
  "use strict";
  var path5 = require("path");
  var locatePath = require_locate_path();
  var pathExists = require_path_exists();
  var stop2 = Symbol("findUp.stop");
  module2.exports = async (name2, options = {}) => {
    let directory = path5.resolve(options.cwd || "");
    const {root} = path5.parse(directory);
    const paths = [].concat(name2);
    const runMatcher = async (locateOptions) => {
      if (typeof name2 !== "function") {
        return locatePath(paths, locateOptions);
      }
      const foundPath = await name2(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = await runMatcher({...options, cwd: directory});
      if (foundPath === stop2) {
        return;
      }
      if (foundPath) {
        return path5.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path5.dirname(directory);
    }
  };
  module2.exports.sync = (name2, options = {}) => {
    let directory = path5.resolve(options.cwd || "");
    const {root} = path5.parse(directory);
    const paths = [].concat(name2);
    const runMatcher = (locateOptions) => {
      if (typeof name2 !== "function") {
        return locatePath.sync(paths, locateOptions);
      }
      const foundPath = name2(locateOptions.cwd);
      if (typeof foundPath === "string") {
        return locatePath.sync([foundPath], locateOptions);
      }
      return foundPath;
    };
    while (true) {
      const foundPath = runMatcher({...options, cwd: directory});
      if (foundPath === stop2) {
        return;
      }
      if (foundPath) {
        return path5.resolve(directory, foundPath);
      }
      if (directory === root) {
        return;
      }
      directory = path5.dirname(directory);
    }
  };
  module2.exports.exists = pathExists;
  module2.exports.sync.exists = pathExists.sync;
  module2.exports.stop = stop2;
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS((exports2, module2) => {
  "use strict";
  var os2 = require("os");
  module2.exports = os2.homedir || function homedir2() {
    var home = process.env.HOME;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
    if (process.platform === "win32") {
      return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }
    if (process.platform === "darwin") {
      return home || (user ? "/Users/" + user : null);
    }
    if (process.platform === "linux") {
      return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
    }
    return home || null;
  };
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS((exports2, module2) => {
  module2.exports = function() {
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function(_, stack2) {
      return stack2;
    };
    var stack = new Error().stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
  };
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS((exports2, module2) => {
  "use strict";
  var isWindows2 = process.platform === "win32";
  var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
  var win32 = {};
  function win32SplitPath(filename) {
    return splitWindowsRe.exec(filename).slice(1);
  }
  win32.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
  var posix = {};
  function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  }
  posix.parse = function(pathString) {
    if (typeof pathString !== "string") {
      throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 5) {
      throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
      root: allParts[1],
      dir: allParts[0].slice(0, -1),
      base: allParts[2],
      ext: allParts[4],
      name: allParts[3]
    };
  };
  if (isWindows2)
    module2.exports = win32.parse;
  else
    module2.exports = posix.parse;
  module2.exports.posix = posix.parse;
  module2.exports.win32 = win32.parse;
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS((exports2, module2) => {
  var path5 = require("path");
  var parse = path5.parse || require_path_parse();
  var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
    var prefix = "/";
    if (/^([A-Za-z]:)/.test(absoluteStart)) {
      prefix = "";
    } else if (/^\\\\/.test(absoluteStart)) {
      prefix = "\\\\";
    }
    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
      paths.push(parsed.dir);
      parsed = parse(parsed.dir);
    }
    return paths.reduce(function(dirs, aPath) {
      return dirs.concat(modules.map(function(moduleDir) {
        return path5.resolve(prefix, aPath, moduleDir);
      }));
    }, []);
  };
  module2.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
    if (opts && typeof opts.paths === "function") {
      return opts.paths(request, start, function() {
        return getNodeModulesDirs(start, modules);
      }, opts);
    }
    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
  };
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS((exports2, module2) => {
  module2.exports = function(x, opts) {
    return opts || {};
  };
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports2, module2) => {
  "use strict";
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(that, args.concat(slice.call(arguments)));
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation();
  module2.exports = Function.prototype.bind || implementation;
});

// node_modules/has/src/index.js
var require_src = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
});

// node_modules/is-core-module/core.json
var require_core = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS((exports2, module2) => {
  "use strict";
  var has = require_src();
  function specifierIncluded(current, specifier) {
    var nodeParts = current.split(".");
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(nodeParts[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      }
      if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(current, range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(current, specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
    if (typeof current !== "string") {
      throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(current, specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(current, specifierValue);
  }
  var data = require_core();
  module2.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
  };
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var fs4 = require("fs");
  var getHomedir = require_homedir();
  var path5 = require("path");
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var isCore = require_is_core_module();
  var realpathFS = fs4.realpath && typeof fs4.realpath.native === "function" ? fs4.realpath.native : fs4.realpath;
  var homedir2 = getHomedir();
  var defaultPaths = function() {
    return [
      path5.join(homedir2, ".node_modules"),
      path5.join(homedir2, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file, cb) {
    fs4.stat(file, function(err, stat) {
      if (!err) {
        return cb(null, stat.isFile() || stat.isFIFO());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultIsDir = function isDirectory(dir, cb) {
    fs4.stat(dir, function(err, stat) {
      if (!err) {
        return cb(null, stat.isDirectory());
      }
      if (err.code === "ENOENT" || err.code === "ENOTDIR")
        return cb(null, false);
      return cb(err);
    });
  };
  var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function(realpathErr, realPath) {
      if (realpathErr && realpathErr.code !== "ENOENT")
        cb(realpathErr);
      else
        cb(null, realpathErr ? x : realPath);
    });
  };
  var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
      realpath(x, cb);
    } else {
      cb(null, x);
    }
  };
  var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
    readFile(pkgfile, function(readFileErr, body) {
      if (readFileErr)
        cb(readFileErr);
      else {
        try {
          var pkg = JSON.parse(body);
          cb(null, pkg);
        } catch (jsonErr) {
          cb(null);
        }
      }
    });
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path5.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolve2(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === "function") {
      cb = opts;
      opts = {};
    }
    if (typeof x !== "string") {
      var err = new TypeError("Path must be a string.");
      return process.nextTick(function() {
        cb(err);
      });
    }
    opts = normalizeOptions(x, opts);
    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs4.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
      var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
      return process.nextTick(function() {
        cb(conflictErr);
      });
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path5.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = path5.resolve(basedir);
    maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
      if (err2)
        cb(err2);
      else
        init(realStart);
    });
    var res;
    function init(basedir2) {
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        res = path5.resolve(basedir2, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        if (/\/$/.test(x) && res === basedir2) {
          loadAsDirectory(res, opts.package, onfile);
        } else
          loadAsFile(res, opts.package, onfile);
      } else if (includeCoreModules && isCore(x)) {
        return cb(null, x);
      } else
        loadNodeModules(x, basedir2, function(err2, n, pkg) {
          if (err2)
            cb(err2);
          else if (n) {
            return maybeRealpath(realpath, n, opts, function(err3, realN) {
              if (err3) {
                cb(err3);
              } else {
                cb(null, realN, pkg);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function onfile(err2, m, pkg) {
      if (err2)
        cb(err2);
      else if (m)
        cb(null, m, pkg);
      else
        loadAsDirectory(res, function(err3, d, pkg2) {
          if (err3)
            cb(err3);
          else if (d) {
            maybeRealpath(realpath, d, opts, function(err4, realD) {
              if (err4) {
                cb(err4);
              } else {
                cb(null, realD, pkg2);
              }
            });
          } else {
            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            moduleError.code = "MODULE_NOT_FOUND";
            cb(moduleError);
          }
        });
    }
    function loadAsFile(x2, thePackage, callback2) {
      var loadAsFilePackage = thePackage;
      var cb2 = callback2;
      if (typeof loadAsFilePackage === "function") {
        cb2 = loadAsFilePackage;
        loadAsFilePackage = void 0;
      }
      var exts = [""].concat(extensions);
      load(exts, x2, loadAsFilePackage);
      function load(exts2, x3, loadPackage) {
        if (exts2.length === 0)
          return cb2(null, void 0, loadPackage);
        var file = x3 + exts2[0];
        var pkg = loadPackage;
        if (pkg)
          onpkg(null, pkg);
        else
          loadpkg(path5.dirname(file), onpkg);
        function onpkg(err2, pkg_, dir) {
          pkg = pkg_;
          if (err2)
            return cb2(err2);
          if (dir && pkg && opts.pathFilter) {
            var rfile = path5.relative(dir, file);
            var rel = rfile.slice(0, rfile.length - exts2[0].length);
            var r = opts.pathFilter(pkg, x3, rel);
            if (r)
              return load([""].concat(extensions.slice()), path5.resolve(dir, r), pkg);
          }
          isFile(file, onex);
        }
        function onex(err2, ex) {
          if (err2)
            return cb2(err2);
          if (ex)
            return cb2(null, file, pkg);
          load(exts2.slice(1), x3, pkg);
        }
      }
    }
    function loadpkg(dir, cb2) {
      if (dir === "" || dir === "/")
        return cb2(null);
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return cb2(null);
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return cb2(null);
      maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return loadpkg(path5.dirname(dir), cb2);
        var pkgfile = path5.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (!ex)
            return loadpkg(path5.dirname(dir), cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            cb2(null, pkg, dir);
          });
        });
      });
    }
    function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
      var cb2 = callback2;
      var fpkg = loadAsDirectoryPackage;
      if (typeof fpkg === "function") {
        cb2 = fpkg;
        fpkg = opts.package;
      }
      maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
        if (unwrapErr)
          return cb2(unwrapErr);
        var pkgfile = path5.join(pkgdir, "package.json");
        isFile(pkgfile, function(err2, ex) {
          if (err2)
            return cb2(err2);
          if (!ex)
            return loadAsFile(path5.join(x2, "index"), fpkg, cb2);
          readPackage(readFile, pkgfile, function(err3, pkgParam) {
            if (err3)
              return cb2(err3);
            var pkg = pkgParam;
            if (pkg && opts.packageFilter) {
              pkg = opts.packageFilter(pkg, pkgfile);
            }
            if (pkg && pkg.main) {
              if (typeof pkg.main !== "string") {
                var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                mainError.code = "INVALID_PACKAGE_MAIN";
                return cb2(mainError);
              }
              if (pkg.main === "." || pkg.main === "./") {
                pkg.main = "index";
              }
              loadAsFile(path5.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                if (err4)
                  return cb2(err4);
                if (m)
                  return cb2(null, m, pkg2);
                if (!pkg2)
                  return loadAsFile(path5.join(x2, "index"), pkg2, cb2);
                var dir = path5.resolve(x2, pkg2.main);
                loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                  if (err5)
                    return cb2(err5);
                  if (n)
                    return cb2(null, n, pkg3);
                  loadAsFile(path5.join(x2, "index"), pkg3, cb2);
                });
              });
              return;
            }
            loadAsFile(path5.join(x2, "/index"), pkg, cb2);
          });
        });
      });
    }
    function processDirs(cb2, dirs) {
      if (dirs.length === 0)
        return cb2(null, void 0);
      var dir = dirs[0];
      isDirectory(path5.dirname(dir), isdir);
      function isdir(err2, isdir2) {
        if (err2)
          return cb2(err2);
        if (!isdir2)
          return processDirs(cb2, dirs.slice(1));
        loadAsFile(dir, opts.package, onfile2);
      }
      function onfile2(err2, m, pkg) {
        if (err2)
          return cb2(err2);
        if (m)
          return cb2(null, m, pkg);
        loadAsDirectory(dir, opts.package, ondir);
      }
      function ondir(err2, n, pkg) {
        if (err2)
          return cb2(err2);
        if (n)
          return cb2(null, n, pkg);
        processDirs(cb2, dirs.slice(1));
      }
    }
    function loadNodeModules(x2, start, cb2) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
    }
  };
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS((exports2, module2) => {
  module2.exports = {
    assert: true,
    "node:assert": [">= 14.18 && < 15", ">= 16"],
    "assert/strict": ">= 15",
    "node:assert/strict": ">= 16",
    async_hooks: ">= 8",
    "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
    buffer_ieee754: ">= 0.5 && < 0.9.7",
    buffer: true,
    "node:buffer": [">= 14.18 && < 15", ">= 16"],
    child_process: true,
    "node:child_process": [">= 14.18 && < 15", ">= 16"],
    cluster: ">= 0.5",
    "node:cluster": [">= 14.18 && < 15", ">= 16"],
    console: true,
    "node:console": [">= 14.18 && < 15", ">= 16"],
    constants: true,
    "node:constants": [">= 14.18 && < 15", ">= 16"],
    crypto: true,
    "node:crypto": [">= 14.18 && < 15", ">= 16"],
    _debug_agent: ">= 1 && < 8",
    _debugger: "< 8",
    dgram: true,
    "node:dgram": [">= 14.18 && < 15", ">= 16"],
    diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
    "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
    dns: true,
    "node:dns": [">= 14.18 && < 15", ">= 16"],
    "dns/promises": ">= 15",
    "node:dns/promises": ">= 16",
    domain: ">= 0.7.12",
    "node:domain": [">= 14.18 && < 15", ">= 16"],
    events: true,
    "node:events": [">= 14.18 && < 15", ">= 16"],
    freelist: "< 6",
    fs: true,
    "node:fs": [">= 14.18 && < 15", ">= 16"],
    "fs/promises": [">= 10 && < 10.1", ">= 14"],
    "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
    _http_agent: ">= 0.11.1",
    "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
    _http_client: ">= 0.11.1",
    "node:_http_client": [">= 14.18 && < 15", ">= 16"],
    _http_common: ">= 0.11.1",
    "node:_http_common": [">= 14.18 && < 15", ">= 16"],
    _http_incoming: ">= 0.11.1",
    "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
    _http_outgoing: ">= 0.11.1",
    "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
    _http_server: ">= 0.11.1",
    "node:_http_server": [">= 14.18 && < 15", ">= 16"],
    http: true,
    "node:http": [">= 14.18 && < 15", ">= 16"],
    http2: ">= 8.8",
    "node:http2": [">= 14.18 && < 15", ">= 16"],
    https: true,
    "node:https": [">= 14.18 && < 15", ">= 16"],
    inspector: ">= 8",
    "node:inspector": [">= 14.18 && < 15", ">= 16"],
    _linklist: "< 8",
    module: true,
    "node:module": [">= 14.18 && < 15", ">= 16"],
    net: true,
    "node:net": [">= 14.18 && < 15", ">= 16"],
    "node-inspect/lib/_inspect": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
    "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
    os: true,
    "node:os": [">= 14.18 && < 15", ">= 16"],
    path: true,
    "node:path": [">= 14.18 && < 15", ">= 16"],
    "path/posix": ">= 15.3",
    "node:path/posix": ">= 16",
    "path/win32": ">= 15.3",
    "node:path/win32": ">= 16",
    perf_hooks: ">= 8.5",
    "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
    process: ">= 1",
    "node:process": [">= 14.18 && < 15", ">= 16"],
    punycode: ">= 0.5",
    "node:punycode": [">= 14.18 && < 15", ">= 16"],
    querystring: true,
    "node:querystring": [">= 14.18 && < 15", ">= 16"],
    readline: true,
    "node:readline": [">= 14.18 && < 15", ">= 16"],
    "readline/promises": ">= 17",
    "node:readline/promises": ">= 17",
    repl: true,
    "node:repl": [">= 14.18 && < 15", ">= 16"],
    smalloc: ">= 0.11.5 && < 3",
    _stream_duplex: ">= 0.9.4",
    "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
    _stream_transform: ">= 0.9.4",
    "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
    _stream_wrap: ">= 1.4.1",
    "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
    _stream_passthrough: ">= 0.9.4",
    "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
    _stream_readable: ">= 0.9.4",
    "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
    _stream_writable: ">= 0.9.4",
    "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
    stream: true,
    "node:stream": [">= 14.18 && < 15", ">= 16"],
    "stream/consumers": ">= 16.7",
    "node:stream/consumers": ">= 16.7",
    "stream/promises": ">= 15",
    "node:stream/promises": ">= 16",
    "stream/web": ">= 16.5",
    "node:stream/web": ">= 16.5",
    string_decoder: true,
    "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
    sys: [">= 0.4 && < 0.7", ">= 0.8"],
    "node:sys": [">= 14.18 && < 15", ">= 16"],
    timers: true,
    "node:timers": [">= 14.18 && < 15", ">= 16"],
    "timers/promises": ">= 15",
    "node:timers/promises": ">= 16",
    _tls_common: ">= 0.11.13",
    "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
    _tls_legacy: ">= 0.11.3 && < 10",
    _tls_wrap: ">= 0.11.3",
    "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
    tls: true,
    "node:tls": [">= 14.18 && < 15", ">= 16"],
    trace_events: ">= 10",
    "node:trace_events": [">= 14.18 && < 15", ">= 16"],
    tty: true,
    "node:tty": [">= 14.18 && < 15", ">= 16"],
    url: true,
    "node:url": [">= 14.18 && < 15", ">= 16"],
    util: true,
    "node:util": [">= 14.18 && < 15", ">= 16"],
    "util/types": ">= 15.3",
    "node:util/types": ">= 16",
    "v8/tools/arguments": ">= 10 && < 12",
    "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
    v8: ">= 1",
    "node:v8": [">= 14.18 && < 15", ">= 16"],
    vm: true,
    "node:vm": [">= 14.18 && < 15", ">= 16"],
    wasi: ">= 13.4 && < 13.5",
    worker_threads: ">= 11.7",
    "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
    zlib: ">= 0.5",
    "node:zlib": [">= 14.18 && < 15", ">= 16"]
  };
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS((exports2, module2) => {
  var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
  function specifierIncluded(specifier) {
    var parts = specifier.split(" ");
    var op = parts.length > 1 ? parts[0] : "=";
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
    for (var i = 0; i < 3; ++i) {
      var cur = parseInt(current[i] || 0, 10);
      var ver = parseInt(versionParts[i] || 0, 10);
      if (cur === ver) {
        continue;
      }
      if (op === "<") {
        return cur < ver;
      } else if (op === ">=") {
        return cur >= ver;
      }
      return false;
    }
    return op === ">=";
  }
  function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
      return false;
    }
    for (var i = 0; i < specifiers.length; ++i) {
      if (!specifierIncluded(specifiers[i])) {
        return false;
      }
    }
    return true;
  }
  function versionIncluded(specifierValue) {
    if (typeof specifierValue === "boolean") {
      return specifierValue;
    }
    if (specifierValue && typeof specifierValue === "object") {
      for (var i = 0; i < specifierValue.length; ++i) {
        if (matchesRange(specifierValue[i])) {
          return true;
        }
      }
      return false;
    }
    return matchesRange(specifierValue);
  }
  var data = require_core2();
  var core = {};
  for (var mod in data) {
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
      core[mod] = versionIncluded(data[mod]);
    }
  }
  module2.exports = core;
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS((exports2, module2) => {
  var isCoreModule = require_is_core_module();
  module2.exports = function isCore(x) {
    return isCoreModule(x);
  };
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS((exports2, module2) => {
  var isCore = require_is_core_module();
  var fs4 = require("fs");
  var path5 = require("path");
  var getHomedir = require_homedir();
  var caller = require_caller();
  var nodeModulesPaths = require_node_modules_paths();
  var normalizeOptions = require_normalize_options();
  var realpathFS = fs4.realpathSync && typeof fs4.realpathSync.native === "function" ? fs4.realpathSync.native : fs4.realpathSync;
  var homedir2 = getHomedir();
  var defaultPaths = function() {
    return [
      path5.join(homedir2, ".node_modules"),
      path5.join(homedir2, ".node_libraries")
    ];
  };
  var defaultIsFile = function isFile(file) {
    try {
      var stat = fs4.statSync(file, {throwIfNoEntry: false});
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
  };
  var defaultIsDir = function isDirectory(dir) {
    try {
      var stat = fs4.statSync(dir, {throwIfNoEntry: false});
    } catch (e) {
      if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
        return false;
      throw e;
    }
    return !!stat && stat.isDirectory();
  };
  var defaultRealpathSync = function realpathSync(x) {
    try {
      return realpathFS(x);
    } catch (realpathErr) {
      if (realpathErr.code !== "ENOENT") {
        throw realpathErr;
      }
    }
    return x;
  };
  var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
      return realpathSync(x);
    }
    return x;
  };
  var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync2, pkgfile) {
    var body = readFileSync2(pkgfile);
    try {
      var pkg = JSON.parse(body);
      return pkg;
    } catch (jsonErr) {
    }
  };
  var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
      dirs[i] = path5.join(dirs[i], x);
    }
    return dirs;
  };
  module2.exports = function resolveSync(x, options) {
    if (typeof x !== "string") {
      throw new TypeError("Path must be a string.");
    }
    var opts = normalizeOptions(x, options);
    var isFile = opts.isFile || defaultIsFile;
    var readFileSync2 = opts.readFileSync || fs4.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
      throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
    }
    var packageIterator = opts.packageIterator;
    var extensions = opts.extensions || [".js"];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path5.dirname(caller());
    var parent = opts.filename || basedir;
    opts.paths = opts.paths || defaultPaths();
    var absoluteStart = maybeRealpathSync(realpathSync, path5.resolve(basedir), opts);
    if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
      var res = path5.resolve(absoluteStart, x);
      if (x === "." || x === ".." || x.slice(-1) === "/")
        res += "/";
      var m = loadAsFileSync(res) || loadAsDirectorySync(res);
      if (m)
        return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
      return x;
    } else {
      var n = loadNodeModulesSync(x, absoluteStart);
      if (n)
        return maybeRealpathSync(realpathSync, n, opts);
    }
    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
    function loadAsFileSync(x2) {
      var pkg = loadpkg(path5.dirname(x2));
      if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
        var rfile = path5.relative(pkg.dir, x2);
        var r = opts.pathFilter(pkg.pkg, x2, rfile);
        if (r) {
          x2 = path5.resolve(pkg.dir, r);
        }
      }
      if (isFile(x2)) {
        return x2;
      }
      for (var i = 0; i < extensions.length; i++) {
        var file = x2 + extensions[i];
        if (isFile(file)) {
          return file;
        }
      }
    }
    function loadpkg(dir) {
      if (dir === "" || dir === "/")
        return;
      if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
        return;
      }
      if (/[/\\]node_modules[/\\]*$/.test(dir))
        return;
      var pkgfile = path5.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
      if (!isFile(pkgfile)) {
        return loadpkg(path5.dirname(dir));
      }
      var pkg = readPackageSync(readFileSync2, pkgfile);
      if (pkg && opts.packageFilter) {
        pkg = opts.packageFilter(pkg, dir);
      }
      return {pkg, dir};
    }
    function loadAsDirectorySync(x2) {
      var pkgfile = path5.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
      if (isFile(pkgfile)) {
        try {
          var pkg = readPackageSync(readFileSync2, pkgfile);
        } catch (e) {
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, x2);
        }
        if (pkg && pkg.main) {
          if (typeof pkg.main !== "string") {
            var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
            mainError.code = "INVALID_PACKAGE_MAIN";
            throw mainError;
          }
          if (pkg.main === "." || pkg.main === "./") {
            pkg.main = "index";
          }
          try {
            var m2 = loadAsFileSync(path5.resolve(x2, pkg.main));
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(path5.resolve(x2, pkg.main));
            if (n2)
              return n2;
          } catch (e) {
          }
        }
      }
      return loadAsFileSync(path5.join(x2, "/index"));
    }
    function loadNodeModulesSync(x2, start) {
      var thunk = function() {
        return getPackageCandidates(x2, start, opts);
      };
      var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
      for (var i = 0; i < dirs.length; i++) {
        var dir = dirs[i];
        if (isDirectory(path5.dirname(dir))) {
          var m2 = loadAsFileSync(dir);
          if (m2)
            return m2;
          var n2 = loadAsDirectorySync(dir);
          if (n2)
            return n2;
        }
      }
    }
  };
});

// node_modules/resolve/index.js
var require_resolve = __commonJS((exports2, module2) => {
  var async = require_async();
  async.core = require_core3();
  async.isCore = require_is_core();
  async.sync = require_sync();
  module2.exports = async;
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports2, module2) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  module2.exports = {
    SEMVER_SPEC_VERSION,
    MAX_LENGTH,
    MAX_SAFE_INTEGER,
    MAX_SAFE_COMPONENT_LENGTH
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module2.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports2, module2) => {
  var {MAX_SAFE_COMPONENT_LENGTH} = require_constants();
  var debug = require_debug();
  exports2 = module2.exports = {};
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.t = {};
  var R = 0;
  var createToken = (name2, value, isGlobal) => {
    const index = R++;
    debug(index, value);
    t[name2] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports2, module2) => {
  var opts = ["includePrerelease", "loose", "rtl"];
  var parseOptions = (options) => !options ? {} : typeof options !== "object" ? {loose: true} : opts.filter((k) => options[k]).reduce((options2, k) => {
    options2[k] = true;
    return options2;
  }, {});
  module2.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports2, module2) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module2.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports2, module2) => {
  var debug = require_debug();
  var {MAX_LENGTH, MAX_SAFE_INTEGER} = require_constants();
  var {re, t} = require_re();
  var parseOptions = require_parse_options();
  var {compareIdentifiers} = require_identifiers();
  var SemVer = class {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.format();
      this.raw = this.version;
      return this;
    }
  };
  module2.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports2, module2) => {
  var {MAX_LENGTH} = require_constants();
  var {re, t} = require_re();
  var SemVer = require_semver();
  var parseOptions = require_parse_options();
  var parse = (version2, options) => {
    options = parseOptions(options);
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 !== "string") {
      return null;
    }
    if (version2.length > MAX_LENGTH) {
      return null;
    }
    const r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version2)) {
      return null;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      return null;
    }
  };
  module2.exports = parse;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var valid = (version2, options) => {
    const v = parse(version2, options);
    return v ? v.version : null;
  };
  module2.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var clean = (version2, options) => {
    const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module2.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var inc = (version2, release, options, identifier) => {
    if (typeof options === "string") {
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(version2, options).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  module2.exports = inc;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module2.exports = compare;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module2.exports = eq;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var eq = require_eq();
  var diff = (version1, version2) => {
    if (eq(version1, version2)) {
      return null;
    } else {
      const v1 = parse(version1);
      const v2 = parse(version2);
      const hasPre = v1.prerelease.length || v2.prerelease.length;
      const prefix = hasPre ? "pre" : "";
      const defaultResult = hasPre ? "prerelease" : "";
      for (const key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  module2.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module2.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module2.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module2.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var prerelease = (version2, options) => {
    const parsed = parse(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module2.exports = prerelease;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module2.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module2.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module2.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module2.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module2.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module2.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module2.exports = lt;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module2.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gte2 = (a, b, loose) => compare(a, b, loose) >= 0;
  module2.exports = gte2;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module2.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports2, module2) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte2 = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte2(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module2.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse = require_parse();
  var {re, t} = require_re();
  var coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(re[t.COERCE]);
    } else {
      let next;
      while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null)
      return null;
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
  };
  module2.exports = coerce;
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
      self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }
    return self;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
      self.tail = inserted;
    }
    if (inserted.prev === null) {
      self.head = inserted;
    }
    self.length++;
    return inserted;
  }
  function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
      self.head = self.tail;
    }
    self.length++;
  }
  function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
      self.tail = self.head;
    }
    self.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports2, module2) => {
  "use strict";
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;
  var LRUCache = class {
    constructor(options) {
      if (typeof options === "number")
        options = {max: options};
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1; l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  };
  var get = (self, key, doUse) => {
    const node = self[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          return void 0;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self, hit) => {
    if (!hit || !hit.maxAge && !self[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
  };
  var trim = (self) => {
    if (self[LENGTH] > self[MAX]) {
      for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self, walker);
        walker = prev;
      }
    }
  };
  var del = (self, node) => {
    if (node) {
      const hit = node.value;
      if (self[DISPOSE])
        self[DISPOSE](hit.key, hit.value);
      self[LENGTH] -= hit.length;
      self[CACHE].delete(hit.key);
      self[LRU_LIST].removeNode(node);
    }
  };
  var Entry = class {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  };
  var forEachStep = (self, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE])
        hit = void 0;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self);
  };
  module2.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports2, module2) => {
  var Range2 = class {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range2) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range2(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0)
          this.set = [first];
        else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      range = range.trim();
      const memoOpts = Object.keys(this.options).join(",");
      const memoKey = `parseRange:${memoOpts}:${range}`;
      const cached = cache.get(memoKey);
      if (cached)
        return cached;
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
      const l = rangeList.length;
      const rangeMap = new Map();
      for (const comp of rangeList) {
        if (isNullSet(comp))
          return [comp];
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has(""))
        rangeMap.delete("");
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  };
  module2.exports = Range2;
  var LRU = require_lru_cache();
  var cache = new LRU({max: 1e3});
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceTilde(comp2, options);
  }).join(" ");
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceCaret(comp2, options);
  }).join(" ");
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((comp2) => {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<")
          pr = "-0";
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version2, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports2, module2) => {
  var ANY = Symbol("SemVer ANY");
  var Comparator = class {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  };
  module2.exports = Comparator;
  var parseOptions = require_parse_options();
  var {re, t} = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range2 = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports2, module2) => {
  var Range2 = require_range();
  var satisfies = (version2, range, options) => {
    try {
      range = new Range2(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  };
  module2.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports2, module2) => {
  var Range2 = require_range();
  var toComparators = (range, options) => new Range2(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module2.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range2 = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range2(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module2.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range2 = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range2(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module2.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range2 = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range2(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin)))
        minver = setMin;
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module2.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports2, module2) => {
  var Range2 = require_range();
  var validRange = (range, options) => {
    try {
      return new Range2(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module2.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var {ANY} = Comparator;
  var Range2 = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte2 = require_gte();
  var outside = (version2, range, hilo, options) => {
    version2 = new SemVer(version2, options);
    range = new Range2(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte2;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module2.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var gtr = (version2, range, options) => outside(version2, range, ">", options);
  module2.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var ltr = (version2, range, options) => outside(version2, range, "<", options);
  module2.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports2, module2) => {
  var Range2 = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range2(r1, options);
    r2 = new Range2(r2, options);
    return r1.intersects(r2);
  };
  module2.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports2, module2) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module2.exports = (versions, range, options) => {
    const set = [];
    let min = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range, options);
      if (included) {
        prev = version2;
        if (!min)
          min = version2;
      } else {
        if (prev) {
          set.push([min, prev]);
        }
        prev = null;
        min = null;
      }
    }
    if (min)
      set.push([min, null]);
    const ranges = [];
    for (const [min2, max] of set) {
      if (min2 === max)
        ranges.push(min2);
      else if (!max && min2 === v[0])
        ranges.push("*");
      else if (!max)
        ranges.push(`>=${min2}`);
      else if (min2 === v[0])
        ranges.push(`<=${max}`);
      else
        ranges.push(`${min2} - ${max}`);
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports2, module2) => {
  var Range2 = require_range();
  var Comparator = require_comparator();
  var {ANY} = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom)
      return true;
    sub = new Range2(sub, options);
    dom = new Range2(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub)
            continue OUTER;
        }
        if (sawNonNull)
          return false;
      }
    return true;
  };
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom)
      return true;
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY)
        return true;
      else if (options.includePrerelease)
        sub = [new Comparator(">=0.0.0-0")];
      else
        sub = [new Comparator(">=0.0.0")];
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease)
        return true;
      else
        dom = [new Comparator(">=0.0.0")];
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=")
        gt = higherGT(gt, c, options);
      else if (c.operator === "<" || c.operator === "<=")
        lt = lowerLT(lt, c, options);
      else
        eqSet.add(c.semver);
    }
    if (eqSet.size > 1)
      return null;
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0)
        return null;
      else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
        return null;
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options))
        return null;
      if (lt && !satisfies(eq, String(lt), options))
        return null;
      for (const c of dom) {
        if (!satisfies(eq, String(c), options))
          return false;
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt)
            return false;
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
          return false;
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt)
            return false;
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
          return false;
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0)
        return false;
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0)
      return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0)
      return false;
    if (needDomGTPre || needDomLTPre)
      return false;
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module2.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports2, module2) => {
  var internalRe = require_re();
  module2.exports = {
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
    SemVer: require_semver(),
    compareIdentifiers: require_identifiers().compareIdentifiers,
    rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
    parse: require_parse(),
    valid: require_valid(),
    clean: require_clean(),
    inc: require_inc(),
    diff: require_diff(),
    major: require_major(),
    minor: require_minor(),
    patch: require_patch(),
    prerelease: require_prerelease(),
    compare: require_compare(),
    rcompare: require_rcompare(),
    compareLoose: require_compare_loose(),
    compareBuild: require_compare_build(),
    sort: require_sort(),
    rsort: require_rsort(),
    gt: require_gt(),
    lt: require_lt(),
    eq: require_eq(),
    neq: require_neq(),
    gte: require_gte(),
    lte: require_lte(),
    cmp: require_cmp(),
    coerce: require_coerce(),
    Comparator: require_comparator(),
    Range: require_range(),
    satisfies: require_satisfies(),
    toComparators: require_to_comparators(),
    maxSatisfying: require_max_satisfying(),
    minSatisfying: require_min_satisfying(),
    minVersion: require_min_version(),
    validRange: require_valid2(),
    outside: require_outside(),
    gtr: require_gtr(),
    ltr: require_ltr(),
    intersects: require_intersects(),
    simplifyRange: require_simplify(),
    subset: require_subset()
  };
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate
});
var import_coc8 = __toModule(require("coc.nvim"));

// src/commands.ts
var import_coc = __toModule(require("coc.nvim"));
var import_fs = __toModule(require("fs"));
var createConfigFile = (templateService) => async () => {
  const folderResult = await import_coc.window.requestInput("Choose folder:", process.cwd());
  if (folderResult && import_fs.default.existsSync(folderResult)) {
    await templateService.writeConfigFile(import_coc.Uri.file(folderResult));
  }
};

// src/LoggingService.ts
var import_coc2 = __toModule(require("coc.nvim"));
var LoggingService = class {
  constructor() {
    this.outputChannel = import_coc2.window.createOutputChannel("Prettier");
    this.logLevel = "INFO";
  }
  setOutputLevel(logLevel) {
    this.logLevel = logLevel;
  }
  logDebug(message, data) {
    if (this.logLevel === "NONE" || this.logLevel === "INFO" || this.logLevel === "WARN" || this.logLevel === "ERROR") {
      return;
    }
    this.logMessage(message, "DEBUG");
    if (data) {
      this.logObject(data);
    }
  }
  logInfo(message, data) {
    if (this.logLevel === "NONE" || this.logLevel === "WARN" || this.logLevel === "ERROR") {
      return;
    }
    this.logMessage(message, "INFO");
    if (data) {
      this.logObject(data);
    }
  }
  logWarning(message, data) {
    if (this.logLevel === "NONE" || this.logLevel === "ERROR") {
      return;
    }
    this.logMessage(message, "WARN");
    if (data) {
      this.logObject(data);
    }
  }
  logError(message, error) {
    if (this.logLevel === "NONE") {
      return;
    }
    this.logMessage(message, "ERROR");
    if (typeof error === "string") {
      this.outputChannel.appendLine(error);
    } else if (error instanceof Error) {
      if (error == null ? void 0 : error.message) {
        this.logMessage(error.message, "ERROR");
      }
      if (error == null ? void 0 : error.stack) {
        this.outputChannel.appendLine(error.stack);
      }
    } else if (error) {
      this.logObject(error);
    }
  }
  show() {
    this.outputChannel.show();
  }
  logObject(data) {
    const message = JSON.stringify(data, null, 2);
    this.outputChannel.appendLine(message);
  }
  logMessage(message, logLevel) {
    const title = new Date().toLocaleTimeString();
    this.outputChannel.appendLine(`["${logLevel}" - ${title}] ${message}`);
  }
};

// src/ModuleResolver.ts
var import_child_process2 = __toModule(require("child_process"));
var import_coc4 = __toModule(require("coc.nvim"));
var findUp = __toModule(require_find_up());
var fs2 = __toModule(require("fs"));
var path3 = __toModule(require("path"));
var prettier = __toModule(require("prettier"));
var resolve = __toModule(require_resolve());
var semver = __toModule(require_semver2());

// src/Files.ts
var import_child_process = __toModule(require("child_process"));
var path = __toModule(require("path"));
function isWindows() {
  return process.platform === "win32";
}
function resolveGlobalNodePath(tracer) {
  let npmCommand = "npm";
  const options = {
    encoding: "utf8"
  };
  if (isWindows()) {
    npmCommand = "npm.cmd";
    options.shell = true;
  }
  const handler = () => {
  };
  try {
    process.on("SIGPIPE", handler);
    const stdout = import_child_process.spawnSync(npmCommand, ["config", "get", "prefix"], options).stdout;
    if (!stdout) {
      if (tracer) {
        tracer(`'npm config get prefix' didn't return a value.`);
      }
      return void 0;
    }
    const prefix = stdout.trim();
    if (tracer) {
      tracer(`'npm config get prefix' value is: ${prefix}`);
    }
    if (prefix.length > 0) {
      if (isWindows()) {
        return path.join(prefix, "node_modules");
      } else {
        return path.join(prefix, "lib", "node_modules");
      }
    }
    return void 0;
  } catch (err) {
    return void 0;
  } finally {
    process.removeListener("SIGPIPE", handler);
  }
}
function resolveGlobalYarnPath(tracer) {
  let yarnCommand = "yarn";
  const options = {
    encoding: "utf8"
  };
  if (isWindows()) {
    yarnCommand = "yarn.cmd";
    options.shell = true;
  }
  const handler = () => {
  };
  try {
    process.on("SIGPIPE", handler);
    const results = import_child_process.spawnSync(yarnCommand, ["global", "dir", "--json"], options);
    const stdout = results.stdout;
    if (!stdout) {
      if (tracer) {
        tracer(`'yarn global dir' didn't return a value.`);
        if (results.stderr) {
          tracer(results.stderr);
        }
      }
      return void 0;
    }
    const lines = stdout.trim().split(/\r?\n/);
    for (const line of lines) {
      try {
        const yarn = JSON.parse(line);
        if (yarn.type === "log") {
          return path.join(yarn.data, "node_modules");
        }
      } catch (e) {
      }
    }
    return void 0;
  } catch (err) {
    return void 0;
  } finally {
    process.removeListener("SIGPIPE", handler);
  }
}

// src/message.ts
var OUTDATED_PRETTIER_VERSION_MESSAGE = "Your project is configured to use an outdated version of prettier that cannot be used by this extension. Upgrade to the latest version of prettier.";
var INVALID_PRETTIER_PATH_MESSAGE = "`prettierPath` option does not reference a valid instance of Prettier. Please ensure you are passing a path to the prettier module, not the binary. Falling back to bundled version of prettier.";
var FAILED_TO_LOAD_MODULE_MESSAGE = "Failed to load module. If you have prettier or plugins referenced in package.json, ensure you have run `npm install`";
var INVALID_PRETTIER_CONFIG = "Invalid prettier configuration file detected. See log for details.";
var RESTART_TO_ENABLE = "To enable or disable prettier after changing the `enable` setting, you must restart coc.nvim by :CocRestart";
var USING_BUNDLED_PRETTIER = "Using bundled version of prettier.";
var EXTENSION_DISABLED = "Extension is disabled. No formatters will be registered. To enable, change the `prettier.enable` to `true` and restart coc.nvim by :CocRestart.";

// src/util.ts
var os = __toModule(require("os"));
var path2 = __toModule(require("path"));
var import_coc3 = __toModule(require("coc.nvim"));
function getWorkspaceRelativePath(filePath, pathToResolve) {
  if (process.platform === "darwin" && pathToResolve.indexOf("~") === 0 && os.homedir()) {
    return pathToResolve.replace(/^~(?=$|\/|\\)/, os.homedir());
  }
  if (import_coc3.workspace.workspaceFolders) {
    const folder = import_coc3.workspace.getWorkspaceFolder(import_coc3.Uri.file(filePath).toString());
    return folder ? path2.isAbsolute(pathToResolve) ? pathToResolve : path2.join(import_coc3.Uri.parse(folder.uri).fsPath, pathToResolve) : void 0;
  }
}
function getConfig(uri) {
  const config = import_coc3.workspace.getConfiguration("prettier", uri ? uri.toString() : void 0);
  return config;
}

// src/ModuleResolver.ts
var minPrettierVersion = "1.13.0";
var globalPaths = {
  npm: {
    cache: void 0,
    get() {
      return resolveGlobalNodePath();
    }
  },
  pnpm: {
    cache: void 0,
    get() {
      const pnpmPath = import_child_process2.execSync("pnpm root -g").toString().trim();
      return pnpmPath;
    }
  },
  yarn: {
    cache: void 0,
    get() {
      return resolveGlobalYarnPath();
    }
  }
};
function globalPathGet(packageManager) {
  const pm = globalPaths[packageManager];
  if (pm) {
    if (pm.cache === void 0) {
      pm.cache = pm.get();
    }
    return pm.cache;
  }
  return void 0;
}
var ModuleResolver = class {
  constructor(loggingService) {
    this.loggingService = loggingService;
    this.path2Module = new Map();
    this.findPkgCache = new Map();
  }
  getGlobalPrettierInstance() {
    return prettier;
  }
  async getPrettierInstance(fileName) {
    const {prettierPath, resolveGlobalModules, onlyUseLocalVersion} = getConfig(import_coc4.Uri.file(fileName));
    let modulePath = void 0;
    try {
      modulePath = prettierPath ? getWorkspaceRelativePath(fileName, prettierPath) : this.findPkg(fileName, "prettier");
    } catch (error) {
      let moduleDirectory = "";
      if (!modulePath && error instanceof Error) {
        const resolveSyncPathRegex = /Cannot find module '.*' from '(.*)'/;
        const resolveErrorMatches = resolveSyncPathRegex.exec(error.message);
        if (resolveErrorMatches && resolveErrorMatches[1]) {
          moduleDirectory = resolveErrorMatches[1];
        }
      }
      this.loggingService.logInfo(`Attempted to load Prettier module from ${modulePath || moduleDirectory || "package.json"}`);
      this.loggingService.logError(FAILED_TO_LOAD_MODULE_MESSAGE, error);
      return void 0;
    }
    if (resolveGlobalModules && !modulePath) {
      let items = ["npm", "pnpm", "yarn"];
      const idx = await import_coc4.window.showMenuPicker(items, {title: "Choose package manager"});
      if (idx !== -1) {
        const packageManager = items[idx];
        const resolvedGlobalPackageManagerPath = globalPathGet(packageManager);
        if (resolvedGlobalPackageManagerPath) {
          const globalModulePath = path3.join(resolvedGlobalPackageManagerPath, "prettier");
          if (fs2.existsSync(globalModulePath)) {
            modulePath = globalModulePath;
          }
        }
      }
    }
    let moduleInstance = void 0;
    if (modulePath !== void 0) {
      moduleInstance = this.path2Module.get(modulePath);
      if (moduleInstance) {
        return moduleInstance;
      } else {
        try {
          moduleInstance = this.loadNodeModule(modulePath);
          if (moduleInstance) {
            this.path2Module.set(modulePath, moduleInstance);
          }
        } catch (error) {
          this.loggingService.logInfo(`Attempted to load Prettier module from ${modulePath || "package.json"}`);
          this.loggingService.logError(FAILED_TO_LOAD_MODULE_MESSAGE, error);
          return void 0;
        }
      }
    }
    if (moduleInstance) {
      const isPrettierInstance = !!moduleInstance.format;
      const isValidVersion = moduleInstance.version && !!moduleInstance.getSupportInfo && !!moduleInstance.getFileInfo && !!moduleInstance.resolveConfig && semver.gte(moduleInstance.version, minPrettierVersion);
      if (!isPrettierInstance && prettierPath) {
        this.loggingService.logError(INVALID_PRETTIER_PATH_MESSAGE);
        return void 0;
      }
      if (!isValidVersion) {
        this.loggingService.logInfo(`Attempted to load Prettier module from ${modulePath}`);
        this.loggingService.logError(OUTDATED_PRETTIER_VERSION_MESSAGE);
        return void 0;
      }
      return moduleInstance;
    } else {
      if (onlyUseLocalVersion) {
        this.loggingService.logInfo("Ignored bundled prettier by onlyUseLocalVersion configuration.");
        return void 0;
      }
      this.loggingService.logDebug(USING_BUNDLED_PRETTIER);
      return prettier;
    }
  }
  async getResolvedConfig(textDocument, vscodeConfig) {
    var _a;
    const uri = import_coc4.Uri.parse(textDocument.uri);
    const fileName = uri.fsPath;
    const isVirtual = uri.scheme !== "file";
    let configPath;
    try {
      if (!isVirtual) {
        configPath = (_a = await prettier.resolveConfigFile(fileName)) != null ? _a : void 0;
      }
    } catch (error) {
      this.loggingService.logError(`Error resolving prettier configuration for ${fileName}`, error);
      return "error";
    }
    const resolveConfigOptions = {
      config: isVirtual ? void 0 : vscodeConfig.configPath ? getWorkspaceRelativePath(fileName, vscodeConfig.configPath) : configPath,
      editorconfig: isVirtual ? void 0 : vscodeConfig.useEditorConfig
    };
    let resolvedConfig;
    try {
      resolvedConfig = isVirtual ? null : await prettier.resolveConfig(fileName, resolveConfigOptions);
    } catch (error) {
      this.loggingService.logError("Invalid prettier configuration file detected.", error);
      this.loggingService.logError(INVALID_PRETTIER_CONFIG);
      return "error";
    }
    if (resolveConfigOptions.config) {
      this.loggingService.logInfo(`Using config file at '${resolveConfigOptions.config}'`);
    }
    if (!isVirtual && !resolvedConfig && vscodeConfig.requireConfig) {
      this.loggingService.logInfo("Require config set to true and no config present. Skipping file.");
      return "disabled";
    }
    return resolvedConfig;
  }
  async dispose() {
    prettier.clearConfigCache();
    this.path2Module.forEach((module2) => {
      try {
        module2.clearConfigCache();
      } catch (error) {
        this.loggingService.logError("Error clearing module cache.", error);
      }
    });
    this.path2Module.clear();
  }
  loadNodeModule(moduleName) {
    try {
      return require(moduleName);
    } catch (error) {
      this.loggingService.logError(`Error loading node module '${moduleName}'`, error);
    }
    return void 0;
  }
  isInternalTestRoot(dir) {
    if (process.env.NODE_ENV !== "production") {
      return fs2.existsSync(path3.join(dir, ".do-not-use-prettier-vscode-root"));
    } else {
      return false;
    }
  }
  findPkg(fsPath, pkgName) {
    const cacheKey = `${fsPath}:${pkgName}`;
    const packagePathState = this.findPkgCache.get(cacheKey);
    if (packagePathState) {
      return packagePathState;
    }
    const splitPath = fsPath.split("/");
    let finalPath = fsPath;
    const nodeModulesIndex = splitPath.indexOf("node_modules");
    if (nodeModulesIndex > 1) {
      finalPath = splitPath.slice(0, nodeModulesIndex).join("/");
    }
    const packageJsonResDir = findUp.sync((dir) => {
      if (fs2.existsSync(path3.join(dir, "package.json"))) {
        let packageJson;
        try {
          packageJson = JSON.parse(fs2.readFileSync(path3.join(dir, "package.json"), "utf8"));
        } catch (e) {
        }
        if (packageJson && (packageJson.dependencies && packageJson.dependencies[pkgName] || packageJson.devDependencies && packageJson.devDependencies[pkgName])) {
          return dir;
        }
      }
      if (this.isInternalTestRoot(dir)) {
        return findUp.stop;
      }
    }, {cwd: finalPath, type: "directory"});
    if (packageJsonResDir) {
      const packagePath = resolve.sync(pkgName, {basedir: packageJsonResDir});
      this.findPkgCache.set(cacheKey, packagePath);
      return packagePath;
    }
    const nodeModulesResDir = findUp.sync((dir) => {
      if (fs2.existsSync(path3.join(dir, "node_modules", pkgName))) {
        return dir;
      }
      if (this.isInternalTestRoot(dir)) {
        return findUp.stop;
      }
    }, {cwd: finalPath, type: "directory"});
    if (nodeModulesResDir) {
      const packagePath = resolve.sync(pkgName, {basedir: nodeModulesResDir});
      this.findPkgCache.set(cacheKey, packagePath);
      return packagePath;
    }
    return;
  }
};

// src/PrettierEditService.ts
var import_coc6 = __toModule(require("coc.nvim"));

// src/languageFilters.ts
function getParserFromLanguageId(languages2, uri, languageId) {
  var _a;
  const languageParsers = ["html", "json"];
  if (uri.scheme !== "file" && languageParsers.includes(languageId)) {
    return languageId;
  }
  const language = languages2.find((lang) => lang && lang.extensions && Array.isArray(lang.vscodeLanguageIds) && lang.vscodeLanguageIds.includes(languageId));
  if (language && ((_a = language.parsers) == null ? void 0 : _a.length) > 0) {
    return language.parsers[0];
  }
}

// src/PrettierEditProvider.ts
var PrettierEditProvider = class {
  constructor(provideEdits) {
    this.provideEdits = provideEdits;
  }
  async provideDocumentRangeFormattingEdits(document, range, options, token) {
    return this.provideEdits(document, {
      rangeEnd: document.offsetAt(range.end),
      rangeStart: document.offsetAt(range.start),
      force: false
    });
  }
  async provideDocumentFormattingEdits(document, options, token) {
    return this.provideEdits(document, {
      force: false
    });
  }
};

// src/StatusBar.ts
var import_coc5 = __toModule(require("coc.nvim"));
var FormatterStatus;
(function(FormatterStatus2) {
  FormatterStatus2["Ready"] = "";
  FormatterStatus2["Success"] = "";
  FormatterStatus2["Warn"] = "Warn";
  FormatterStatus2["Error"] = "Error";
  FormatterStatus2["Ignore"] = "x";
  FormatterStatus2["Disabled"] = "x";
})(FormatterStatus || (FormatterStatus = {}));
var StatusBar = class {
  constructor(text) {
    this.text = text;
    this.statusBarItem = import_coc5.window.createStatusBarItem(0, {});
    this.statusBarItem.text = this.text;
  }
  update(result) {
    this.statusBarItem.text = `${this.text} ${result.toString()}`;
    this.statusBarItem.show();
  }
  hide() {
    this.statusBarItem.hide();
  }
};

// src/PrettierEditService.ts
var PRETTIER_CONFIG_FILES = [
  ".prettierrc",
  ".prettierrc.json",
  ".prettierrc.json5",
  ".prettierrc.yaml",
  ".prettierrc.yml",
  ".prettierrc.toml",
  ".prettierrc.js",
  ".prettierrc.cjs",
  "package.json",
  "prettier.config.js",
  "prettier.config.cjs",
  ".editorconfig"
];
var PrettierEditService = class {
  constructor(moduleResolver, loggingService, statusBar) {
    this.moduleResolver = moduleResolver;
    this.loggingService = loggingService;
    this.statusBar = statusBar;
    this.registeredWorkspaces = new Set();
    this.allLanguages = [];
    this.allExtensions = [];
    this.allRangeLanguages = [
      "javascript",
      "javascriptreact",
      "typescript",
      "typescriptreact",
      "json",
      "graphql",
      "handlebars"
    ];
    this.forceFormatDocument = async () => {
      try {
        const doc = await import_coc6.workspace.document;
        if (!doc || !doc.attached) {
          this.loggingService.logInfo("No active document. Nothing was formatted.");
          return;
        }
        this.loggingService.logInfo("Forced formatting will not use ignore files.");
        const edits = await this.provideEdits(doc.textDocument, {force: true});
        if (edits.length !== 1) {
          return;
        }
        await doc.applyEdits(edits);
      } catch (e) {
        this.loggingService.logError("Error formatting document", e);
      }
    };
    this.prettierConfigChanged = async (uri) => this.resetFormatters(uri);
    this.resetFormatters = async (uri) => {
      if (uri) {
        const workspaceFolder = import_coc6.workspace.getWorkspaceFolder(uri.toString());
        const fsPath = workspaceFolder ? import_coc6.Uri.parse(workspaceFolder.uri).fsPath : void 0;
        this.registeredWorkspaces.delete(fsPath != null ? fsPath : "global");
      } else {
        this.registeredWorkspaces.clear();
      }
      this.statusBar.update(FormatterStatus.Ready);
    };
    this.handleActiveTextEditorChanged = async (bufnr) => {
      let doc = import_coc6.workspace.getDocument(bufnr);
      if (!doc || !doc.attached) {
        this.statusBar.hide();
        return;
      }
      const {disableLanguages} = getConfig(import_coc6.Uri.parse(doc.uri));
      const uri = import_coc6.Uri.parse(doc.uri);
      if (uri.scheme !== "file") {
        return;
      }
      const workspaceFolder = import_coc6.workspace.getWorkspaceFolder(doc.uri);
      if (!workspaceFolder) {
        return;
      }
      const workspaceUri = import_coc6.Uri.parse(workspaceFolder.uri);
      const prettierInstance = await this.moduleResolver.getPrettierInstance(workspaceUri.fsPath);
      const isRegistered = this.registeredWorkspaces.has(workspaceUri.fsPath);
      if (!prettierInstance) {
        this.statusBar.update(FormatterStatus.Error);
        return;
      }
      const selectors = await this.getSelectors(prettierInstance, workspaceUri);
      if (!isRegistered) {
        this.registerDocumentFormatEditorProviders(selectors);
        this.registeredWorkspaces.add(workspaceUri.fsPath);
        this.loggingService.logDebug(`Enabling Prettier for Workspace ${workspaceUri.fsPath}`, selectors);
      }
      if (Array.isArray(disableLanguages) && disableLanguages.includes(doc.languageId)) {
        this.statusBar.hide();
        return;
      }
      const score = import_coc6.workspace.match(selectors.languageSelector, doc.textDocument);
      if (score > 0) {
        this.statusBar.update(FormatterStatus.Ready);
      } else {
        this.statusBar.hide();
      }
    };
    this.dispose = () => {
      var _a, _b;
      this.moduleResolver.dispose();
      (_a = this.formatterHandler) == null ? void 0 : _a.dispose();
      (_b = this.rangeFormatterHandler) == null ? void 0 : _b.dispose();
      this.formatterHandler = void 0;
      this.rangeFormatterHandler = void 0;
    };
    this.getSelectors = async (prettierInstance, uri) => {
      const {languages: languages2} = prettierInstance.getSupportInfo();
      const {documentSelectors, disableLanguages} = getConfig(uri);
      languages2.forEach((lang) => {
        if (lang && lang.vscodeLanguageIds) {
          this.allLanguages.push(...lang.vscodeLanguageIds);
        }
      });
      this.allLanguages = this.allLanguages.filter((value, index, self) => {
        if (Array.isArray(disableLanguages) && disableLanguages.includes(value))
          return false;
        return self.indexOf(value) === index;
      });
      languages2.forEach((lang) => {
        if (lang && lang.extensions) {
          this.allExtensions.push(...lang.extensions);
        }
      });
      this.allExtensions = this.allExtensions.filter((value, index, self) => {
        return self.indexOf(value) === index;
      });
      const customLanguageSelectors = uri ? documentSelectors.map((pattern) => ({
        pattern: `${uri.fsPath}/${pattern}`,
        scheme: "file"
      })) : [];
      const defaultLanguageSelectors = [
        ...this.allLanguages.map((language) => ({language})),
        {language: "jsonc", scheme: "vscode-userdata"}
      ];
      const languageSelector = [
        ...customLanguageSelectors,
        ...defaultLanguageSelectors
      ];
      const rangeLanguageSelector = [
        ...this.allRangeLanguages.map((language) => ({
          language
        }))
      ].filter((o) => {
        if (Array.isArray(disableLanguages) && disableLanguages.includes(o.language))
          return false;
        return true;
      });
      return {languageSelector, rangeLanguageSelector};
    };
    this.provideEdits = async (document, options) => {
      const startTime = new Date().getTime();
      const result = await this.format(document.getText(), document, options);
      if (!result) {
        return [];
      }
      const duration = new Date().getTime() - startTime;
      this.loggingService.logInfo(`Formatting completed in ${duration / 1e3}ms.`);
      return [import_coc6.TextEdit.replace(this.fullDocumentRange(document), result)];
    };
  }
  registerDisposables() {
    const packageWatcher = import_coc6.workspace.createFileSystemWatcher("**/package.json");
    packageWatcher.onDidChange(this.resetFormatters);
    packageWatcher.onDidCreate(this.resetFormatters);
    packageWatcher.onDidDelete(this.resetFormatters);
    const configurationWatcher = import_coc6.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration("prettier.enable")) {
        this.loggingService.logWarning(RESTART_TO_ENABLE);
      } else if (event.affectsConfiguration("prettier")) {
        this.resetFormatters();
      }
    });
    const prettierConfigWatcher = import_coc6.workspace.createFileSystemWatcher(`**/{${PRETTIER_CONFIG_FILES.join(",")}}`);
    prettierConfigWatcher.onDidChange(this.prettierConfigChanged);
    prettierConfigWatcher.onDidCreate(this.prettierConfigChanged);
    prettierConfigWatcher.onDidDelete(this.prettierConfigChanged);
    const textEditorChange = import_coc6.events.on("BufEnter", async () => {
      let doc = await import_coc6.workspace.document;
      this.handleActiveTextEditorChanged(doc.bufnr);
    });
    this.handleActiveTextEditorChanged(import_coc6.workspace.bufnr);
    return [
      packageWatcher,
      configurationWatcher,
      prettierConfigWatcher,
      textEditorChange
    ];
  }
  async registerGlobal() {
    const selectors = await this.getSelectors(this.moduleResolver.getGlobalPrettierInstance());
    this.registerDocumentFormatEditorProviders(selectors);
    this.loggingService.logDebug("Enabling Prettier globally", selectors);
  }
  registerDocumentFormatEditorProviders({
    languageSelector,
    rangeLanguageSelector
  }) {
    this.dispose();
    const editProvider = new PrettierEditProvider(this.provideEdits);
    const {formatterPriority} = getConfig();
    let priority = formatterPriority != null ? formatterPriority : -1;
    this.rangeFormatterHandler = import_coc6.languages.registerDocumentRangeFormatProvider(rangeLanguageSelector, editProvider, priority);
    this.formatterHandler = import_coc6.languages.registerDocumentFormatProvider(languageSelector, editProvider, priority);
  }
  async format(text, document, options) {
    const {uri, languageId} = document;
    const fileName = import_coc6.Uri.parse(uri).fsPath;
    this.loggingService.logInfo(`Formatting ${uri}`);
    const vscodeConfig = getConfig(import_coc6.Uri.parse(uri));
    const resolvedConfig = await this.moduleResolver.getResolvedConfig(document, vscodeConfig);
    if (resolvedConfig === "error") {
      this.statusBar.update(FormatterStatus.Error);
      return;
    }
    if (resolvedConfig === "disabled") {
      this.statusBar.hide();
      return;
    }
    const prettierInstance = await this.moduleResolver.getPrettierInstance(fileName);
    if (!prettierInstance) {
      this.loggingService.logError("Prettier could not be loaded. See previous logs for more information.");
      this.statusBar.update(FormatterStatus.Error);
      return;
    }
    let resolvedIgnorePath;
    if (vscodeConfig.ignorePath) {
      resolvedIgnorePath = getWorkspaceRelativePath(fileName, vscodeConfig.ignorePath);
      if (resolvedIgnorePath) {
        this.loggingService.logInfo(`Using ignore file (if present) at ${resolvedIgnorePath}`);
      }
    }
    let fileInfo;
    if (fileName) {
      fileInfo = await prettierInstance.getFileInfo(fileName, {
        ignorePath: resolvedIgnorePath,
        resolveConfig: true,
        withNodeModules: vscodeConfig.withNodeModules
      });
      this.loggingService.logInfo("File Info:", fileInfo);
    }
    if (!options.force && fileInfo && fileInfo.ignored) {
      this.loggingService.logInfo("File is ignored, skipping.");
      this.statusBar.hide();
      return;
    }
    let parser;
    if (fileInfo && fileInfo.inferredParser) {
      parser = fileInfo.inferredParser;
    } else if (languageId !== "plaintext" && languageId !== "txt") {
      this.loggingService.logWarning(`Parser not inferred, trying languageId.`);
      const languages2 = prettierInstance.getSupportInfo().languages;
      parser = getParserFromLanguageId(languages2, import_coc6.Uri.parse(uri), languageId);
    }
    if (!parser) {
      this.loggingService.logError(`Failed to resolve a parser, skipping file. If you registered a custom file extension, be sure to configure the parser.`);
      this.statusBar.update(FormatterStatus.Error);
      return;
    }
    const prettierOptions = this.getPrettierOptions(fileName, parser, vscodeConfig, resolvedConfig, options);
    this.loggingService.logInfo("Prettier Options:", prettierOptions);
    try {
      const formattedText = prettierInstance.format(text, prettierOptions);
      this.statusBar.update(FormatterStatus.Success);
      return formattedText;
    } catch (error) {
      this.loggingService.logError("Error formatting document.", error);
      this.statusBar.update(FormatterStatus.Error);
      return text;
    }
  }
  getPrettierOptions(fileName, parser, vsCodeConfig, configOptions, extentionFormattingOptions) {
    const fallbackToVSCodeConfig = configOptions === null;
    const vsOpts = {};
    if (fallbackToVSCodeConfig) {
      vsOpts.arrowParens = vsCodeConfig.arrowParens;
      vsOpts.bracketSpacing = vsCodeConfig.bracketSpacing;
      vsOpts.endOfLine = vsCodeConfig.endOfLine;
      vsOpts.htmlWhitespaceSensitivity = vsCodeConfig.htmlWhitespaceSensitivity;
      vsOpts.insertPragma = vsCodeConfig.insertPragma;
      vsOpts.jsxBracketSameLine = vsCodeConfig.jsxBracketSameLine;
      vsOpts.jsxSingleQuote = vsCodeConfig.jsxSingleQuote;
      vsOpts.printWidth = vsCodeConfig.printWidth;
      vsOpts.proseWrap = vsCodeConfig.proseWrap;
      vsOpts.quoteProps = vsCodeConfig.quoteProps;
      vsOpts.requirePragma = vsCodeConfig.requirePragma;
      vsOpts.semi = vsCodeConfig.semi;
      vsOpts.singleQuote = vsCodeConfig.singleQuote;
      vsOpts.tabWidth = vsCodeConfig.tabWidth;
      vsOpts.trailingComma = vsCodeConfig.trailingComma;
      vsOpts.useTabs = vsCodeConfig.useTabs;
      vsOpts.vueIndentScriptAndStyle = vsCodeConfig.vueIndentScriptAndStyle;
    }
    this.loggingService.logInfo(fallbackToVSCodeConfig ? "No local configuration (i.e. .prettierrc or .editorconfig) detected, falling back to coc-prettier configuration" : "Detected local configuration (i.e. .prettierrc or .editorconfig), coc-prettier configuration will not be used");
    let rangeFormattingOptions;
    if (extentionFormattingOptions.rangeEnd && extentionFormattingOptions.rangeStart) {
      rangeFormattingOptions = {
        rangeEnd: extentionFormattingOptions.rangeEnd,
        rangeStart: extentionFormattingOptions.rangeStart
      };
    }
    const options = {
      ...fallbackToVSCodeConfig ? vsOpts : {},
      ...{
        filepath: fileName,
        parser
      },
      ...rangeFormattingOptions || {},
      ...configOptions || {}
    };
    if (extentionFormattingOptions.force && options.requirePragma === true) {
      options.requirePragma = false;
    }
    return options;
  }
  fullDocumentRange(document) {
    const lastLineId = document.lineCount - 1;
    let doc = import_coc6.workspace.getDocument(document.uri);
    return import_coc6.Range.create(0, 0, lastLineId, doc.getline(lastLineId).length);
  }
};
var PrettierEditService_default = PrettierEditService;

// src/TemplateService.ts
var import_coc7 = __toModule(require("coc.nvim"));
var import_fs2 = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var import_util3 = __toModule(require("util"));
var TemplateService = class {
  constructor(loggingService, prettierModule) {
    this.loggingService = loggingService;
    this.prettierModule = prettierModule;
  }
  async writeConfigFile(folderPath) {
    const settings = {tabWidth: 2, useTabs: false};
    const outputPath = import_path.default.join(folderPath.fsPath, ".prettierrc");
    const formatterOptions = {
      filepath: folderPath.scheme === "file" ? outputPath : void 0,
      tabWidth: settings.tabWidth,
      useTabs: settings.useTabs
    };
    const templateSource = this.prettierModule.format(JSON.stringify(settings, null, 2), formatterOptions);
    this.loggingService.logInfo(`Writing .prettierrc to '${outputPath}'`);
    await import_util3.promisify(import_fs2.default.writeFile)(outputPath, templateSource, {encoding: "utf8"});
    await import_coc7.workspace.jumpTo(import_coc7.Uri.file(outputPath).toString());
  }
};

// package.json
var name = "coc-prettier";
var version = "9.2.3";
var description = "prettier extension for coc.nvim";
var main = "lib/index.js";
var publisher = "chemzqm";
var keywords = [
  "coc.nvim",
  "prettier"
];
var engines = {
  coc: ">= 0.0.80"
};
var repository = {
  type: "git",
  url: "https://github.com/neoclide/coc-prettier.git"
};
var bugs = {
  url: "https://github.com/neoclide/coc-prettier/issues"
};
var scripts = {
  prepare: "node esbuild.js"
};
var activationEvents = [
  "*"
];
var contributes = {
  configuration: {
    type: "object",
    title: "Prettier - Code formatter configuration",
    properties: {
      "prettier.formatterPriority": {
        type: "number",
        default: 1,
        description: "Priority of format provider, default to 1 that higher than other languageserver formatter, change to -1 to make it lower priority."
      },
      "prettier.disableLanguages": {
        type: "array",
        items: {
          type: "string"
        },
        default: [],
        description: "A list of languages IDs to disable this extension on",
        scope: "window"
      },
      "prettier.documentSelectors": {
        type: "array",
        items: {
          type: "string"
        },
        default: [],
        markdownDescription: "A list of [glob patterns](https://code.visualstudio.com/api/references/vscode-api#GlobPattern) to register Prettier formatter",
        scope: "window"
      },
      "prettier.enable": {
        type: "boolean",
        default: true,
        markdownDescription: "Controls whether prettier is enabled or not.",
        scope: "resource"
      },
      "prettier.requireConfig": {
        type: "boolean",
        default: false,
        markdownDescription: "Require a prettier configuration file to format. See [documentation for valid configuration files](https://prettier.io/docs/en/configuration.html).\n\n> _Note, untitled files will still be formatted using the coc-prettier settings even when this setting is set._",
        scope: "resource"
      },
      "prettier.resolveGlobalModules": {
        type: "boolean",
        default: false,
        markdownDescription: "When enabled, this extension will attempt to use global npm or yarn modules if local modules cannot be resolved.\n> _This setting can have a negative performance impact, particularly on Windows when you have attached network drives. Only enable this if you must use global modules._",
        scope: "resource"
      },
      "prettier.withNodeModules": {
        type: "boolean",
        default: false,
        markdownDescription: "If true, this extension will process files in node_modules",
        scope: "resource"
      },
      "prettier.packageManager": {
        scope: "resource",
        type: "string",
        enum: [
          "npm",
          "yarn",
          "pnpm"
        ],
        default: "npm",
        deprecationMessage: "Package manager is now automatically detected by coc-prettier. This setting is no longer used.",
        markdownDescription: "The package manager you use to install node modules."
      },
      "prettier.useEditorConfig": {
        type: "boolean",
        default: true,
        markdownDescription: "Whether or not to take `.editorconfig` into account when parsing configuration. See the [prettier.resolveConfig](https://prettier.io/docs/en/api.html) docs for details.",
        scope: "resource"
      },
      "prettier.prettierPath": {
        type: "string",
        markdownDescription: "Path to the prettier module",
        scope: "resource"
      },
      "prettier.configPath": {
        type: "string",
        markdownDescription: "Path to the prettier configuration file",
        scope: "resource"
      },
      "prettier.enableDebugLogs": {
        type: "boolean",
        default: false,
        markdownDescription: "Enable debug logs for troubleshooting.",
        scope: "resource"
      },
      "prettier.onlyUseLocalVersion": {
        type: "boolean",
        default: false,
        description: "Only use the version of prettier installed by the client, ignoring the version bundled with coc-prettier",
        scope: "resource"
      },
      "prettier.statusItemText": {
        type: "string",
        default: "Prettier",
        description: "Text shown in status item.",
        scope: "resource"
      },
      "prettier.ignorePath": {
        type: "string",
        default: ".prettierignore",
        description: "Path to a .prettierignore or similar file",
        scope: "resource"
      },
      "prettier.printWidth": {
        type: "integer",
        default: 80,
        description: "Fit code within this line limit",
        scope: "resource"
      },
      "prettier.tabWidth": {
        type: "integer",
        default: 2,
        description: "Number of spaces it should use per tab",
        scope: "resource"
      },
      "prettier.singleQuote": {
        type: "boolean",
        default: false,
        description: "If true, will use single instead of double quotes",
        scope: "resource"
      },
      "prettier.trailingComma": {
        type: "string",
        enum: [
          "none",
          "es5",
          "all"
        ],
        default: "es5",
        description: "Controls the printing of trailing commas wherever possible.\n Valid options:\n    'none' - No trailing commas\n    'es5' - Trailing commas where valid in ES5 (objects, arrays, etc)\n    'all' - Trailing commas wherever possible (function arguments)",
        scope: "resource"
      },
      "prettier.bracketSpacing": {
        type: "boolean",
        default: true,
        description: "Controls the printing of spaces inside object literals",
        scope: "resource"
      },
      "prettier.jsxSingleQuote": {
        type: "boolean",
        default: false,
        description: "Use single quotes instead of double quotes in JSX"
      },
      "prettier.jsxBracketSameLine": {
        type: "boolean",
        default: false,
        markdownDescription: "If true, puts the `>` of a multi-line jsx element at the end of the last line instead of being alone on the next line",
        scope: "resource"
      },
      "prettier.htmlWhitespaceSensitivity": {
        type: "string",
        enum: [
          "css",
          "strict",
          "ignore"
        ],
        default: "css",
        description: "Specify the global whitespace sensitivity for HTML files.\n Valid options: \n'css' - Respect the default value of CSS display property. \n'strict' - Whitespaces are considered sensitive. \n'ignore' - Whitespaces are considered insensitive."
      },
      "prettier.vueIndentScriptAndStyle": {
        type: "boolean",
        default: false,
        markdownDescription: "Whether or not to indent the code inside `<script>` and `<style>` tags in Vue files. Some people (like the creator of Vue) don\u2019t indent to save an indentation level, but this might break code folding in your editor.",
        scope: "resource"
      },
      "prettier.endOfLine": {
        type: "string",
        enum: [
          "auto",
          "lf",
          "crlf",
          "cr"
        ],
        default: "lf",
        description: "Specify the end of line used by prettier"
      },
      "prettier.semi": {
        type: "boolean",
        default: true,
        description: "Whether to add a semicolon at the end of every line",
        scope: "resource"
      },
      "prettier.requirePragma": {
        type: "boolean",
        default: false,
        markdownDescription: "Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to prettier.",
        scope: "resource"
      },
      "prettier.insertPragma": {
        type: "boolean",
        default: false,
        markdownDescription: "Prettier can insert a special @format marker at the top of files specifying that the file has been formatted with prettier. This works well when used in tandem with the `--require-pragma` option. If there is already a docblock at the top of the file then this option will add a newline to it with the @format marker.",
        scope: "resource"
      },
      "prettier.useTabs": {
        type: "boolean",
        default: false,
        description: "Indent lines with tabs",
        scope: "resource"
      },
      "prettier.proseWrap": {
        type: "string",
        enum: [
          "preserve",
          "always",
          "never"
        ],
        default: "preserve",
        description: "(Markdown) wrap prose over multiple lines"
      },
      "prettier.arrowParens": {
        type: "string",
        enum: [
          "avoid",
          "always"
        ],
        default: "always",
        description: "Include parentheses around a sole arrow function parameter",
        scope: "resource"
      },
      "prettier.quoteProps": {
        type: "string",
        enum: [
          "as-needed",
          "consistent",
          "preserve"
        ],
        default: "as-needed",
        markdownDescription: "Change when properties in objects are quoted",
        scope: "resource"
      },
      "prettier.embeddedLanguageFormatting": {
        type: "string",
        enum: [
          "auto",
          "off"
        ],
        default: "auto",
        markdownDescription: "Control whether Prettier formats quoted code embedded in the file.",
        scope: "resource"
      }
    }
  },
  jsonValidation: [
    {
      fileMatch: ".prettierrc",
      url: "http://json.schemastore.org/prettierrc"
    },
    {
      fileMatch: ".prettierrc.json",
      url: "http://json.schemastore.org/prettierrc"
    },
    {
      fileMatch: "package.json",
      url: "./package-json-schema.json"
    }
  ],
  commands: [
    {
      command: "prettier.createConfigFile",
      title: "Prettier: Create Configuration File"
    },
    {
      command: "prettier.forceFormatDocument",
      title: "Format Document (Forced)"
    }
  ]
};
var author = "chemzqm@gmail.com";
var license = "MIT";
var devDependencies = {
  "@chemzqm/tsconfig": "^0.0.3",
  "@types/node": "12.12.0",
  "@types/semver": "^7.3.4",
  "coc.nvim": "^0.0.81-next.20",
  esbuild: "^0.8.54",
  "find-up": "5.0.0",
  ignore: "^5.1.8",
  resolve: "^1.21.0",
  "resolve-from": "^5.0.0",
  rimraf: "^3.0.2",
  semver: "^7.3.5",
  typescript: "^4.2.2"
};
var dependencies = {
  prettier: "^2.5.1"
};
var package_default = {
  name,
  version,
  description,
  main,
  publisher,
  keywords,
  engines,
  repository,
  bugs,
  scripts,
  activationEvents,
  contributes,
  author,
  license,
  devDependencies,
  dependencies
};

// src/index.ts
var extensionName = package_default.name;
var extensionVersion = package_default.version;
function activate(context) {
  const loggingService = new LoggingService();
  loggingService.logInfo(`Extension Name: ${extensionName}.`);
  loggingService.logInfo(`Extension Version: ${extensionVersion}.`);
  const {enable, enableDebugLogs, statusItemText} = getConfig();
  if (enableDebugLogs) {
    loggingService.setOutputLevel("DEBUG");
  }
  if (!enable) {
    loggingService.logInfo(EXTENSION_DISABLED);
    context.subscriptions.push(import_coc8.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration("prettier.enable")) {
        loggingService.logWarning(RESTART_TO_ENABLE);
      }
    }));
    return;
  }
  const moduleResolver = new ModuleResolver(loggingService);
  const templateService = new TemplateService(loggingService, moduleResolver.getGlobalPrettierInstance());
  const statusBar = new StatusBar(statusItemText != null ? statusItemText : "Prettier");
  const editService = new PrettierEditService_default(moduleResolver, loggingService, statusBar);
  editService.registerGlobal();
  const createConfigFileFunc = createConfigFile(templateService);
  const createConfigFileCommand = import_coc8.commands.registerCommand("prettier.createConfigFile", createConfigFileFunc);
  const openOutputCommand = import_coc8.commands.registerCommand("prettier.openOutput", () => {
    loggingService.show();
  });
  const forceFormatDocumentCommand = import_coc8.commands.registerCommand("prettier.forceFormatDocument", editService.forceFormatDocument);
  const formatDocumentCommand = import_coc8.commands.registerCommand("prettier.formatFile", editService.forceFormatDocument);
  context.subscriptions.push(editService, formatDocumentCommand, createConfigFileCommand, openOutputCommand, forceFormatDocumentCommand, ...editService.registerDisposables());
}
//# sourceMappingURL=index.js.map
