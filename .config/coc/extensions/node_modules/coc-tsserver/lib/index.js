var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable15;
    (function(Disposable16) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable16.create = create;
    })(Disposable15 = exports.Disposable || (exports.Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
          clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
          return setImmediate(callback, ...args);
        },
        clearImmediate(handle) {
          clearImmediate(handle);
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string2;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
    })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      const candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports.isResponseMessage = isResponseMessage;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event6;
    (function(Event7) {
      const _disposable = { dispose() {
      } };
      Event7.None = function() {
        return _disposable;
      };
    })(Event6 = exports.Event || (exports.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            ral_1.default().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter8 = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter8._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter8;
    Emitter8._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var CancellationToken23;
    (function(CancellationToken24) {
      CancellationToken24.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken24.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken24.None || candidate === CancellationToken24.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken24.is = is;
    })(CancellationToken23 = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        ral_1.default().timer.clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource4 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken23.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken23.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource4;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options !== null && options !== void 0 ? options : "utf-8";
        } else {
          charset = (_a = options.charset) !== null && _a !== void 0 ? _a : "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = ral_1.default().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          ral_1.default().timer.clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength2 = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        var _a, _b;
        if (options === void 0 || typeof options === "string") {
          return { charset: options !== null && options !== void 0 ? options : "utf-8", contentTypeEncoder: ral_1.default().applicationJson.encoder };
        } else {
          return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength2, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[Symbol.toStringTag] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a;
        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
      }
      get last() {
        var _a;
        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace2;
    (function(Trace3) {
      Trace3[Trace3["Off"] = 0] = "Off";
      Trace3[Trace3["Messages"] = 1] = "Messages";
      Trace3[Trace3["Verbose"] = 2] = "Verbose";
    })(Trace2 = exports.Trace || (exports.Trace = {}));
    (function(Trace3) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace3.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace3.Off;
          case "messages":
            return Trace3.Messages;
          case "verbose":
            return Trace3.Verbose;
          default:
            return Trace3.Off;
        }
      }
      Trace3.fromString = fromString;
      function toString2(value) {
        switch (value) {
          case Trace3.Off:
            return "off";
          case Trace3.Messages:
            return "messages";
          case Trace3.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace3.toString = toString2;
    })(Trace2 = exports.Trace || (exports.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ Object.create(null);
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ Object.create(null);
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ Object.create(null);
      let requestTokens = /* @__PURE__ */ Object.create(null);
      let trace = Trace2.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            const key = createRequestQueueKey(message.params.id);
            const toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = String(requestMessage.id);
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = String(responseMessage.id);
          const responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            const id = params.id;
            const source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          const element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                if (type !== void 0) {
                  if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                  }
                  if (type.numberOfParams !== message.params.length) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);
                  }
                }
                notificationHandler(...message.params);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = String(responseMessage.id);
          const responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace2.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace2.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
            break;
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Recevied parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is2.string(type)) {
              method = type;
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              method = type.method;
              notificationHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                delete notificationHandlers[method];
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              cancellationStrategy.sender.sendCancellation(connection, id);
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is2.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers[type] = { handler, type: void 0 };
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                delete requestHandlers[method];
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace2.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace2.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is2.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          ral_1.default().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace2.Verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
    exports.CancellationStrategy = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    var path9 = require("path");
    var os3 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api(), exports);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path9.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path9.join(os3.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = net_1.createConnection(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return api_1.createMessageConnection(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  AnnotatedTextEdit: () => AnnotatedTextEdit,
  ChangeAnnotation: () => ChangeAnnotation,
  ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeDescription: () => CodeDescription,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InsertReplaceEdit: () => InsertReplaceEdit,
  InsertTextFormat: () => InsertTextFormat,
  InsertTextMode: () => InsertTextMode,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectionRange: () => SelectionRange,
  SignatureInformation: () => SignatureInformation,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit,
  integer: () => integer,
  uinteger: () => uinteger
});
var integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, DocumentSymbol, CodeActionKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
    })(integer || (integer = {}));
    (function(uinteger2) {
      uinteger2.MIN_VALUE = 0;
      uinteger2.MAX_VALUE = 2147483647;
    })(uinteger || (uinteger = {}));
    (function(Position11) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position11.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position11.is = is;
    })(Position || (Position = {}));
    (function(Range20) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
      }
      Range20.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range20.is = is;
    })(Range || (Range = {}));
    (function(Location4) {
      function create(uri, range) {
        return { uri, range };
      }
      Location4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location4.is = is;
    })(Location || (Location = {}));
    (function(LocationLink2) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink2.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color2) {
      function create(red, green, blue, alpha) {
        return {
          red,
          green,
          blue,
          alpha
        };
      }
      Color2.create = create;
      function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color2.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation2) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation2.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation2) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation2.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind2) {
      FoldingRangeKind2["Comment"] = "comment";
      FoldingRangeKind2["Imports"] = "imports";
      FoldingRangeKind2["Region"] = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange2) {
      function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        return result;
      }
      FoldingRange2.create = create;
      function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange2.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation3) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation3.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity4) {
      DiagnosticSeverity4.Error = 1;
      DiagnosticSeverity4.Warning = 2;
      DiagnosticSeverity4.Information = 3;
      DiagnosticSeverity4.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag4) {
      DiagnosticTag4.Unnecessary = 1;
      DiagnosticTag4.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription2) {
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic7) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic7.create = create;
      function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic7.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command6) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command6.is = is;
    })(Command || (Command = {}));
    (function(TextEdit7) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit7.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit7.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit7.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit7.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation2) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation2.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        var candidate = value;
        return typeof candidate === "string";
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit2) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit2.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile2) {
      function create(uri, options, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile2.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile2) {
      function create(oldUri, newUri, options, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile2.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile2) {
      function create(uri, options, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile2.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit7) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit7.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = function() {
      function TextEditChangeImpl2(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.delete = function(range, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.add = function(edit) {
        this.edits.push(edit);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl2;
    }();
    ChangeAnnotations = function() {
      function ChangeAnnotations2(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations2.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations2.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations2;
    }();
    WorkspaceChange = function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange2.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange2;
    }();
    (function(TextDocumentIdentifier2) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier2.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind4) {
      MarkupKind4.PlainText = "plaintext";
      MarkupKind4.Markdown = "markdown";
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupKind4) {
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind4.PlainText || candidate === MarkupKind4.Markdown;
      }
      MarkupKind4.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent4) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent4.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind5) {
      CompletionItemKind5.Text = 1;
      CompletionItemKind5.Method = 2;
      CompletionItemKind5.Function = 3;
      CompletionItemKind5.Constructor = 4;
      CompletionItemKind5.Field = 5;
      CompletionItemKind5.Variable = 6;
      CompletionItemKind5.Class = 7;
      CompletionItemKind5.Interface = 8;
      CompletionItemKind5.Module = 9;
      CompletionItemKind5.Property = 10;
      CompletionItemKind5.Unit = 11;
      CompletionItemKind5.Value = 12;
      CompletionItemKind5.Enum = 13;
      CompletionItemKind5.Keyword = 14;
      CompletionItemKind5.Snippet = 15;
      CompletionItemKind5.Color = 16;
      CompletionItemKind5.File = 17;
      CompletionItemKind5.Reference = 18;
      CompletionItemKind5.Folder = 19;
      CompletionItemKind5.EnumMember = 20;
      CompletionItemKind5.Constant = 21;
      CompletionItemKind5.Struct = 22;
      CompletionItemKind5.Event = 23;
      CompletionItemKind5.Operator = 24;
      CompletionItemKind5.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat5) {
      InsertTextFormat5.PlainText = 1;
      InsertTextFormat5.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag3) {
      CompletionItemTag3.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit2) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit2.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode2) {
      InsertTextMode2.asIs = 1;
      InsertTextMode2.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItem6) {
      function create(label) {
        return { label };
      }
      CompletionItem6.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList4) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList4.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString2) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString2.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString2.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover2) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover2.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind3) {
      DocumentHighlightKind3.Text = 1;
      DocumentHighlightKind3.Read = 2;
      DocumentHighlightKind3.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight3) {
      function create(range, kind) {
        var result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight3.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind6) {
      SymbolKind6.File = 1;
      SymbolKind6.Module = 2;
      SymbolKind6.Namespace = 3;
      SymbolKind6.Package = 4;
      SymbolKind6.Class = 5;
      SymbolKind6.Method = 6;
      SymbolKind6.Property = 7;
      SymbolKind6.Field = 8;
      SymbolKind6.Constructor = 9;
      SymbolKind6.Enum = 10;
      SymbolKind6.Interface = 11;
      SymbolKind6.Function = 12;
      SymbolKind6.Variable = 13;
      SymbolKind6.Constant = 14;
      SymbolKind6.String = 15;
      SymbolKind6.Number = 16;
      SymbolKind6.Boolean = 17;
      SymbolKind6.Array = 18;
      SymbolKind6.Object = 19;
      SymbolKind6.Key = 20;
      SymbolKind6.Null = 21;
      SymbolKind6.EnumMember = 22;
      SymbolKind6.Struct = 23;
      SymbolKind6.Event = 24;
      SymbolKind6.Operator = 25;
      SymbolKind6.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag5) {
      SymbolTag5.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation3) {
      function create(name, kind, range, uri, containerName) {
        var result = {
          name,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation3.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(DocumentSymbol3) {
      function create(name, detail, kind, range, selectionRange, children) {
        var result = {
          name,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol3.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind7) {
      CodeActionKind7.Empty = "";
      CodeActionKind7.QuickFix = "quickfix";
      CodeActionKind7.Refactor = "refactor";
      CodeActionKind7.RefactorExtract = "refactor.extract";
      CodeActionKind7.RefactorInline = "refactor.inline";
      CodeActionKind7.RefactorRewrite = "refactor.rewrite";
      CodeActionKind7.Source = "source";
      CodeActionKind7.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind7.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionContext7) {
      function create(diagnostics, only) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        return result;
      }
      CodeActionContext7.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
      }
      CodeActionContext7.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction7) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction7.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction7.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens4) {
      function create(range, data) {
        var result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens4.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions2) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions2.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink2) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink2.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange2) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
      }
      SelectionRange2.is = is;
    })(SelectionRange || (SelectionRange = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function(TextDocument18) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument18.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument18.is = is;
      function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document.offsetAt(e.range.start);
          var endOffset = document.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument18.applyEdits = applyEdits;
      function mergeSort(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = function() {
      function FullTextDocument2(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument2.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument2.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument2.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument2.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument2.prototype.update = function(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = void 0;
      };
      FullTextDocument2.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument2.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument2.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument2;
    }();
    (function(Is2) {
      var toString2 = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean2(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean2;
      function string2(value) {
        return toString2.call(value) === "[object String]";
      }
      Is2.string = string2;
      function number(value) {
        return toString2.call(value) === "[object Number]";
      }
      Is2.number = number;
      function numberRange(value, min, max) {
        return toString2.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString2.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger2(value) {
        return toString2.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger2;
      function func(value) {
        return toString2.call(value) === "[object Function]";
      }
      Is2.func = func;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string2;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeKind2;
    (function(FoldingRangeKind3) {
      FoldingRangeKind3["Comment"] = "comment";
      FoldingRangeKind3["Imports"] = "imports";
      FoldingRangeKind3["Region"] = "region";
    })(FoldingRangeKind2 = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
    })(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
    })(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
    var messages_1 = require_messages2();
    var SemanticTokenTypes;
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
    })(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
    var SemanticTokenModifiers;
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
    var SemanticTokens2;
    (function(SemanticTokens3) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens3.is = is;
    })(SemanticTokens2 = exports.SemanticTokens || (exports.SemanticTokens = {}));
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    })(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
    })(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    })(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2["document"] = "document";
      UniquenessLevel2["project"] = "project";
      UniquenessLevel2["group"] = "group";
      UniquenessLevel2["scheme"] = "scheme";
      UniquenessLevel2["global"] = "global";
    })(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2["import"] = "import";
      MonikerKind2["export"] = "export";
      MonikerKind2["local"] = "local";
    })(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "SemanticTokenTypes", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenTypes;
    } });
    Object.defineProperty(exports, "SemanticTokenModifiers", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenModifiers;
    } });
    Object.defineProperty(exports, "SemanticTokens", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokens;
    } });
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var DocumentFilter;
    (function(DocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern);
      }
      DocumentFilter2.is = is;
    })(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
    var DocumentSelector2;
    (function(DocumentSelector3) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !DocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector3.is = is;
    })(DocumentSelector2 = exports.DocumentSelector || (exports.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector2.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
    var InitializeError;
    (function(InitializeError2) {
      InitializeError2.unknownProtocolVersion = 1;
    })(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent2;
    (function(TextDocumentContentChangeEvent3) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent3.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent3.isFull = isFull;
    })(TextDocumentContentChangeEvent2 = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(require_main(), exports);
    __exportStar((init_main(), __toCommonJS(main_exports)), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_protocol(), exports);
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    __exportStar(require_api2(), exports);
    function createProtocolConnection(input, output, logger, options) {
      return node_1.createMessageConnection(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse = (version, options) => {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module2) {
    var parse = require_parse();
    var valid2 = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid2;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module2) {
    var parse = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    var compare = require_compare();
    var gte2 = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte2;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte2 = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte2(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self, key, doUse) => {
      const node = self[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self, hit) => {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    };
    var trim = (self) => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self, walker);
          walker = prev;
        }
      }
    };
    var del = (self, node) => {
      if (node) {
        const hit = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    var Range20 = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range20) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range20(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = /* @__PURE__ */ new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range20)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range20;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range20(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range20(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range20 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range20 = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range20(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    var Range20 = require_range();
    var toComparators = (range, options) => new Range20(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range20 = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range20(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range20 = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range20(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module2) {
    var SemVer = require_semver();
    var Range20 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range20(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module2) {
    var Range20 = require_range();
    var validRange = (range, options) => {
      try {
        return new Range20(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range20 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte2 = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range20(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte2;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module2) {
    var Range20 = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range20(r1, options);
      r2 = new Range20(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module2) {
    var Range20 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range20(sub, options);
      dom = new Range20(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs5 = require("fs");
    function checkPathExt(path9, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path9.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path9, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path9, options);
    }
    function isexe(path9, options, cb) {
      fs5.stat(path9, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path9, options));
      });
    }
    function sync(path9, options) {
      return checkStat(fs5.statSync(path9), path9, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs5 = require("fs");
    function isexe(path9, options, cb) {
      fs5.stat(path9, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path9, options) {
      return checkStat(fs5.statSync(path9), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs5 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path9, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path9, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path9, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path9, options) {
      try {
        return core.sync(path9, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path9 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which2 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path9.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path9.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
var import_coc42 = require("coc.nvim");

// src/server/index.ts
var import_coc40 = require("coc.nvim");
var import_vscode_languageserver_protocol24 = __toESM(require_main2());

// src/server/commands.ts
var import_coc2 = require("coc.nvim");
init_main();

// src/server/utils/api.ts
var semver = __toESM(require_semver2());
var _API = class {
  constructor(versionString, version) {
    this.versionString = versionString;
    this.version = version;
  }
  static fromSimpleString(value) {
    return new _API(value, value);
  }
  static fromVersionString(versionString) {
    let version = semver.valid(versionString);
    if (!version) {
      return new _API("invalid version", "1.0.0");
    }
    const index = versionString.indexOf("-");
    if (index >= 0) {
      version = version.substr(0, index);
    }
    return new _API(versionString, version);
  }
  gte(other) {
    return semver.gte(this.version, other.version);
  }
  lt(other) {
    return !this.gte(other);
  }
};
var API = _API;
API.defaultVersion = _API.fromSimpleString("1.0.0");
API.v203 = _API.fromSimpleString("2.0.3");
API.v206 = _API.fromSimpleString("2.0.6");
API.v208 = _API.fromSimpleString("2.0.8");
API.v213 = _API.fromSimpleString("2.1.3");
API.v220 = _API.fromSimpleString("2.2.0");
API.v222 = _API.fromSimpleString("2.2.2");
API.v230 = _API.fromSimpleString("2.3.0");
API.v234 = _API.fromSimpleString("2.3.4");
API.v240 = _API.fromSimpleString("2.4.0");
API.v250 = _API.fromSimpleString("2.5.0");
API.v260 = _API.fromSimpleString("2.6.0");
API.v270 = _API.fromSimpleString("2.7.0");
API.v280 = _API.fromSimpleString("2.8.0");
API.v290 = _API.fromSimpleString("2.9.0");
API.v291 = _API.fromSimpleString("2.9.1");
API.v292 = _API.fromSimpleString("2.9.2");
API.v300 = _API.fromSimpleString("3.0.0");
API.v310 = _API.fromSimpleString("3.1.0");
API.v314 = _API.fromSimpleString("3.1.4");
API.v320 = _API.fromSimpleString("3.2.0");
API.v330 = _API.fromSimpleString("3.3.0");
API.v333 = _API.fromSimpleString("3.3.3");
API.v340 = _API.fromSimpleString("3.4.0");
API.v345 = _API.fromSimpleString("3.4.5");
API.v350 = _API.fromSimpleString("3.5.0");
API.v370 = _API.fromSimpleString("3.7.0");
API.v380 = _API.fromSimpleString("3.8.0");
API.v381 = _API.fromSimpleString("3.8.1");
API.v390 = _API.fromSimpleString("3.9.0");
API.v400 = _API.fromSimpleString("4.0.0");
API.v401 = _API.fromSimpleString("4.0.1");
API.v420 = _API.fromSimpleString("4.2.0");
API.v430 = _API.fromSimpleString("4.3.0");
API.v440 = _API.fromSimpleString("4.4.0");

// src/server/utils/helper.ts
var nodeModules = [
  "assert",
  "cluster",
  "crypto",
  "dns",
  "domain",
  "events",
  "fs",
  "http",
  "http2",
  "https",
  "inspector",
  "net",
  "os",
  "path",
  "punycode",
  "querystring",
  "readline",
  "repl",
  "stream",
  "string_decoder",
  "tls",
  "tty",
  "url",
  "util",
  "v8",
  "vm",
  "zlib",
  "perf_hooks"
];

// src/server/utils/modules.ts
var import_child_process = require("child_process");
var import_coc = require("coc.nvim");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
function runCommand(cmd, cwd, timeout) {
  return new Promise((resolve, reject) => {
    let timer;
    if (timeout) {
      timer = setTimeout(() => {
        reject(new Error(`timeout after ${timeout}s`));
      }, timeout * 1e3);
    }
    (0, import_child_process.exec)(cmd, { cwd }, (err, stdout) => {
      if (timer)
        clearTimeout(timer);
      if (err) {
        reject(new Error(`exited with ${err.code}`));
        return;
      }
      resolve(stdout);
    });
  });
}
async function getManager() {
  let res = await import_coc.workspace.findUp(["yarn.lock", "package-lock.json"]);
  if (!res)
    return "yarn";
  return res.endsWith("yarn.lock") ? "yarn" : "npm";
}
async function moduleExists(name) {
  try {
    let content = await runCommand(`npm info ${name} --json`, process.cwd());
    if (!content)
      return false;
    let obj = JSON.parse(content);
    if (obj.error != null)
      return false;
    return true;
  } catch (e) {
    return false;
  }
  return false;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => {
      return array.indexOf(element) === position;
    });
  }
  const seen = /* @__PURE__ */ Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
async function installModules(uri, names) {
  names = distinct(names);
  let workspaceFolder = import_coc.workspace.getWorkspaceFolder(uri);
  let root = workspaceFolder ? import_coc.Uri.parse(workspaceFolder.uri).fsPath : void 0;
  if (!root || !import_fs.default.existsSync(import_path.default.join(root, "package.json"))) {
    import_coc.window.showMessage(`package.json not found from workspaceFolder: ${root}`, "error");
    return;
  }
  let arr = names.concat(names.map((s) => `@types/${s}`));
  let statusItem = import_coc.window.createStatusBarItem(99, { progress: true });
  statusItem.text = `Checking module ${arr.join(" ")}`;
  statusItem.show();
  let exists = await Promise.all(arr.map((name) => {
    return moduleExists(name).then((exists2) => {
      return exists2 ? name : null;
    });
  }));
  let manager = await getManager();
  exists = exists.filter((s) => s != null);
  if (!exists.length)
    return;
  let devs = exists.filter((s) => s.startsWith("@types"));
  let deps = exists.filter((s) => devs.indexOf(s) == -1);
  statusItem.text = `Installing ${exists.join(" ")}`;
  try {
    let cmd = manager == "npm" ? `npm i ${deps.join(" ")}` : `yarn add ${deps.join(" ")}`;
    await runCommand(cmd, root);
    cmd = manager == "npm" ? `npm i ${deps.join(" ")} --save-dev` : `yarn add ${deps.join(" ")} --save-dev`;
    await runCommand(cmd, root);
  } catch (e) {
    statusItem.dispose();
    import_coc.window.showMessage(`Install error ${e.message}`, "error");
    return;
  }
  statusItem.dispose();
  import_coc.window.showMessage(`Installed: ${exists.join(" ")}`, "more");
}

// src/server/utils/typeConverters.ts
var language = __toESM(require_main2());

// src/server/protocol.const.ts
var Kind = class {
};
Kind.alias = "alias";
Kind.callSignature = "call";
Kind.class = "class";
Kind.const = "const";
Kind.constructorImplementation = "constructor";
Kind.constructSignature = "construct";
Kind.directory = "directory";
Kind.enum = "enum";
Kind.enumMember = "enum member";
Kind.externalModuleName = "external module name";
Kind.function = "function";
Kind.indexSignature = "index";
Kind.interface = "interface";
Kind.keyword = "keyword";
Kind.let = "let";
Kind.localFunction = "local function";
Kind.localVariable = "local var";
Kind.method = "method";
Kind.memberGetAccessor = "getter";
Kind.memberSetAccessor = "setter";
Kind.memberVariable = "property";
Kind.module = "module";
Kind.primitiveType = "primitive type";
Kind.script = "script";
Kind.type = "type";
Kind.variable = "var";
Kind.warning = "warning";
Kind.string = "string";
Kind.parameter = "parameter";
Kind.typeParameter = "type parameter";
var DiagnosticCategory = class {
};
DiagnosticCategory.error = "error";
DiagnosticCategory.warning = "warning";
DiagnosticCategory.suggestion = "suggestion";
var _KindModifiers = class {
};
var KindModifiers = _KindModifiers;
KindModifiers.optional = "optional";
KindModifiers.deprecated = "deprecated";
KindModifiers.color = "color";
KindModifiers.dtsFile = ".d.ts";
KindModifiers.tsFile = ".ts";
KindModifiers.tsxFile = ".tsx";
KindModifiers.jsFile = ".js";
KindModifiers.jsxFile = ".jsx";
KindModifiers.jsonFile = ".json";
KindModifiers.fileExtensionKindModifiers = [
  _KindModifiers.dtsFile,
  _KindModifiers.tsFile,
  _KindModifiers.tsxFile,
  _KindModifiers.jsFile,
  _KindModifiers.jsxFile,
  _KindModifiers.jsonFile
];
var DisplayPartKind = class {
};
DisplayPartKind.functionName = "functionName";
DisplayPartKind.methodName = "methodName";
DisplayPartKind.parameterName = "parameterName";
DisplayPartKind.propertyName = "propertyName";
DisplayPartKind.punctuation = "punctuation";
DisplayPartKind.text = "text";

// src/server/utils/typeConverters.ts
var Range3;
((Range20) => {
  Range20.fromTextSpan = (span) => {
    return {
      start: {
        line: span.start.line - 1,
        character: span.start.offset - 1
      },
      end: {
        line: span.end.line - 1,
        character: span.end.offset - 1
      }
    };
  };
  Range20.fromLocations = (start, end) => language.Range.create(Math.max(0, start.line - 1), Math.max(start.offset - 1, 0), Math.max(0, end.line - 1), Math.max(0, end.offset - 1));
  Range20.toFormattingRequestArgs = (file2, range) => ({
    file: file2,
    line: range.start.line + 1,
    offset: range.start.character + 1,
    endLine: range.end.line + 1,
    endOffset: range.end.character + 1
  });
  Range20.toFileRangeRequestArgs = (file2, range) => ({
    file: file2,
    startLine: range.start.line + 1,
    startOffset: range.start.character + 1,
    endLine: range.end.line + 1,
    endOffset: range.end.character + 1
  });
})(Range3 || (Range3 = {}));
var Position2;
((Position11) => {
  Position11.fromLocation = (tslocation) => {
    return {
      line: tslocation.line - 1,
      character: tslocation.offset - 1
    };
  };
  Position11.toLocation = (position) => ({
    line: position.line + 1,
    offset: position.character + 1
  });
  Position11.toFileLocationRequestArgs = (file2, position) => ({
    file: file2,
    line: position.line + 1,
    offset: position.character + 1
  });
})(Position2 || (Position2 = {}));
var Location2;
((Location4) => {
  Location4.fromTextSpan = (uri, tsTextSpan) => {
    return {
      uri,
      range: Range3.fromTextSpan(tsTextSpan)
    };
  };
})(Location2 || (Location2 = {}));
var TextEdit2;
((TextEdit7) => {
  TextEdit7.fromCodeEdit = (edit) => {
    return {
      range: Range3.fromTextSpan(edit),
      newText: edit.newText
    };
  };
})(TextEdit2 || (TextEdit2 = {}));
var WorkspaceEdit2;
((WorkspaceEdit7) => {
  function fromFileCodeEdits(client, edits) {
    let documentChanges = [];
    for (const edit of edits) {
      let uri = client.toResource(edit.fileName);
      documentChanges.push({
        textDocument: {
          uri,
          version: null
        },
        edits: edit.textChanges.map((change) => {
          return TextEdit2.fromCodeEdit(change);
        })
      });
    }
    return { documentChanges };
  }
  WorkspaceEdit7.fromFileCodeEdits = fromFileCodeEdits;
})(WorkspaceEdit2 || (WorkspaceEdit2 = {}));
var SymbolKind3;
((SymbolKind6) => {
  function fromProtocolScriptElementKind(kind) {
    switch (kind) {
      case Kind.module:
        return language.SymbolKind.Module;
      case Kind.class:
        return language.SymbolKind.Class;
      case Kind.enum:
        return language.SymbolKind.Enum;
      case Kind.enumMember:
        return language.SymbolKind.EnumMember;
      case Kind.interface:
        return language.SymbolKind.Interface;
      case Kind.indexSignature:
        return language.SymbolKind.Method;
      case Kind.callSignature:
        return language.SymbolKind.Method;
      case Kind.method:
        return language.SymbolKind.Method;
      case Kind.memberVariable:
        return language.SymbolKind.Property;
      case Kind.memberGetAccessor:
        return language.SymbolKind.Property;
      case Kind.memberSetAccessor:
        return language.SymbolKind.Property;
      case Kind.variable:
        return language.SymbolKind.Variable;
      case Kind.let:
        return language.SymbolKind.Variable;
      case Kind.const:
        return language.SymbolKind.Variable;
      case Kind.localVariable:
        return language.SymbolKind.Variable;
      case Kind.alias:
        return language.SymbolKind.Variable;
      case Kind.function:
        return language.SymbolKind.Function;
      case Kind.localFunction:
        return language.SymbolKind.Function;
      case Kind.constructSignature:
        return language.SymbolKind.Constructor;
      case Kind.constructorImplementation:
        return language.SymbolKind.Constructor;
      case Kind.typeParameter:
        return language.SymbolKind.TypeParameter;
      case Kind.string:
        return language.SymbolKind.String;
      default:
        return language.SymbolKind.Variable;
    }
  }
  SymbolKind6.fromProtocolScriptElementKind = fromProtocolScriptElementKind;
})(SymbolKind3 || (SymbolKind3 = {}));

// src/server/commands.ts
var ReloadProjectsCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.reloadProjects";
  }
  async execute() {
    let client = await this.service.getClientHost();
    client.reloadProjects();
    import_coc2.window.showMessage("projects reloaded");
  }
};
var OpenTsServerLogCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.openTsServerLog";
  }
  async execute() {
    let client = await this.service.getClientHost();
    client.serviceClient.openTsServerLogFile();
  }
};
var TypeScriptGoToProjectConfigCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.goToProjectConfig";
  }
  async execute() {
    let client = await this.service.getClientHost();
    let doc = await import_coc2.workspace.document;
    let { languageId } = doc.textDocument;
    if (client.serviceClient.modeIds.indexOf(languageId) == -1) {
      throw new Error(`Could not determine TypeScript or JavaScript project. Unsupported file type: ${languageId}`);
      return;
    }
    await goToProjectConfig(client, doc.uri);
  }
};
async function goToProjectConfig(clientHost, uri) {
  const client = clientHost.serviceClient;
  const file2 = client.toPath(uri);
  let res;
  try {
    res = await client.execute("projectInfo", { file: file2, needFileNameList: false }, import_coc2.CancellationToken.None);
  } catch {
  }
  if (!res || !res.body) {
    import_coc2.window.showMessage("Could not determine TypeScript or JavaScript project.", "warning");
    return;
  }
  const { configFileName } = res.body;
  if (configFileName && !isImplicitProjectConfigFile(configFileName)) {
    await import_coc2.workspace.openResource(import_coc2.Uri.file(configFileName).toString());
    return;
  }
  import_coc2.window.showMessage("Config file not found", "warning");
}
function isImplicitProjectConfigFile(configFileName) {
  return configFileName.indexOf("/dev/null/") === 0;
}
var autoFixableDiagnosticCodes = /* @__PURE__ */ new Set([
  2420,
  2552,
  2304
]);
var AutoFixCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.executeAutofix";
  }
  async execute() {
    if (this.service.state != import_coc2.ServiceStat.Running) {
      throw new Error("service not running");
      return;
    }
    let client = await this.service.getClientHost();
    let document = await import_coc2.workspace.document;
    let handles = await client.handles(document.textDocument);
    if (!handles) {
      throw new Error(`Document ${document.uri} is not handled by tsserver.`);
      return;
    }
    let file2 = client.serviceClient.toPath(document.uri);
    let diagnostics = client.serviceClient.diagnosticsManager.getDiagnostics(document.uri);
    let missingDiagnostics = diagnostics.filter((o) => o.code == 2307);
    if (missingDiagnostics.length) {
      let names2 = missingDiagnostics.map((o) => {
        let ms = o.message.match(/module\s'(.+)'\./);
        return ms ? ms[1] : null;
      });
      names2 = names2.filter((s) => s != null);
      if (names2.length) {
        installModules(document.uri, names2).catch((e) => {
          console.error(e.message);
        });
      }
    }
    diagnostics = diagnostics.filter((x) => autoFixableDiagnosticCodes.has(x.code));
    if (diagnostics.length == 0)
      return;
    diagnostics = diagnostics.reduce((arr, curr) => {
      if (curr.code == 2304 && arr.findIndex((o) => o.message == curr.message) != -1)
        return arr;
      arr.push(curr);
      return arr;
    }, []);
    let edits = [];
    let command;
    let names = [];
    for (let diagnostic of diagnostics) {
      const args = __spreadProps(__spreadValues({}, Range3.toFileRangeRequestArgs(file2, diagnostic.range)), {
        errorCodes: [+diagnostic.code]
      });
      const response = await client.serviceClient.execute("getCodeFixes", args, import_coc2.CancellationToken.None);
      if (response.type !== "response" || !response.body || response.body.length < 1) {
        if (diagnostic.code == 2304) {
          let { range } = diagnostic;
          let line = document.getline(range.start.line);
          let name = line.slice(range.start.character, range.end.character);
          if (nodeModules.indexOf(name) !== -1 && names.indexOf(name) == -1) {
            names.push(name);
            edits.push({
              range: Range.create(0, 0, 0, 0),
              newText: `import ${name} from '${name}'
`
            });
            command = "tsserver.organizeImports";
          }
        }
        continue;
      }
      const fix = response.body[0];
      for (let change of fix.changes) {
        if (change.fileName != file2)
          continue;
        for (let ch of change.textChanges) {
          edits.push({
            range: Range3.fromTextSpan(ch),
            newText: ch.newText
          });
        }
      }
    }
    if (edits.length)
      await document.applyEdits(edits);
    if (command)
      import_coc2.commands.executeCommand(command);
  }
};
var ConfigurePluginCommand = class {
  constructor(pluginManager) {
    this.pluginManager = pluginManager;
    this.id = "_typescript.configurePlugin";
  }
  execute(pluginId, configuration) {
    this.pluginManager.setConfiguration(pluginId, configuration);
  }
};
var _FileReferencesCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.findAllFileReferences";
  }
  async execute() {
    const client = await this.service.getClientHost();
    if (client.serviceClient.apiVersion.lt(_FileReferencesCommand.minVersion)) {
      import_coc2.window.showMessage("Find file references failed. Requires TypeScript 4.2+.", "error");
      return;
    }
    const doc = await import_coc2.workspace.document;
    let { languageId } = doc.textDocument;
    if (client.serviceClient.modeIds.indexOf(languageId) == -1)
      return;
    const openedFiledPath = client.serviceClient.toOpenedFilePath(doc.uri);
    if (!openedFiledPath)
      return;
    const response = await client.serviceClient.execute("fileReferences", { file: openedFiledPath }, import_coc2.CancellationToken.None);
    if (response.type !== "response" || !response.body)
      return;
    const locations = response.body.refs.map((r) => Location2.fromTextSpan(client.serviceClient.toResource(r.file), r));
    await import_coc2.commands.executeCommand("editor.action.showReferences", doc.uri, Position.create(0, 0), locations);
  }
};
var FileReferencesCommand = _FileReferencesCommand;
FileReferencesCommand.minVersion = API.v420;
function registCommand(cmd) {
  let { id, execute } = cmd;
  return import_coc2.commands.registerCommand(id, execute, cmd);
}

// src/server/organizeImports.ts
var import_coc3 = require("coc.nvim");
var import_vscode_languageserver_protocol = __toESM(require_main2());
var OrganizeImportsCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.organizeImports";
  }
  async _execute(client, document, sortOnly = false) {
    let file2 = client.toPath(document.uri);
    const args = {
      skipDestructiveCodeActions: sortOnly,
      scope: {
        type: "file",
        args: {
          file: file2
        }
      }
    };
    const response = await client.interruptGetErr(() => client.execute("organizeImports", args, import_vscode_languageserver_protocol.CancellationToken.None));
    if (!response || response.type != "response" || !response.success) {
      return;
    }
    const edit = WorkspaceEdit2.fromFileCodeEdits(client, response.body);
    let keys = Object.keys(edit.changes || {});
    if (keys.length == 1) {
      let doc = import_coc3.workspace.getDocument(keys[0]);
      if (doc) {
        await doc.applyEdits(edit.changes[keys[0]]);
        return;
      }
    }
    if (edit)
      await import_coc3.workspace.applyEdit(edit);
  }
  async execute(document, sortOnly = false) {
    let client = await this.service.getClientHost();
    if (!document) {
      let doc = await import_coc3.workspace.document;
      if (!doc.attached) {
        throw new Error(`Document not attached.`);
      }
      if (client.serviceClient.modeIds.indexOf(doc.filetype) == -1) {
        throw new Error(`filetype "${doc.filetype}" not supported by tsserver.`);
      }
      document = doc.textDocument;
    }
    await this._execute(client.serviceClient, document, sortOnly);
  }
};
var SourceImportsCommand = class extends OrganizeImportsCommand {
  constructor() {
    super(...arguments);
    this.id = "tsserver.sortImports";
  }
};
var OrganizeImportsCodeActionProvider = class {
  constructor(client, fileConfigManager) {
    this.client = client;
    this.fileConfigManager = fileConfigManager;
    this.metadata = {
      providedCodeActionKinds: [import_vscode_languageserver_protocol.CodeActionKind.SourceOrganizeImports]
    };
  }
  async provideCodeActions(document, _range, context, token) {
    if (this.client.modeIds.indexOf(document.languageId) == -1)
      return;
    if (!context.only || !context.only.includes(import_vscode_languageserver_protocol.CodeActionKind.SourceOrganizeImports)) {
      return [];
    }
    await this.fileConfigManager.ensureConfigurationForDocument(document, token);
    const organizeImportsAction = import_vscode_languageserver_protocol.CodeAction.create("Organize Imports", {
      title: "",
      command: "tsserver.organizeImports",
      arguments: [document]
    }, import_vscode_languageserver_protocol.CodeActionKind.SourceOrganizeImports);
    const sortImportsAction = import_vscode_languageserver_protocol.CodeAction.create("Sort Imports", {
      title: "",
      command: "tsserver.sortImports",
      arguments: [document, true]
    }, "source.sortImports");
    return [organizeImportsAction, sortImportsAction];
  }
};

// src/server/typescriptServiceClientHost.ts
var import_coc39 = require("coc.nvim");
var import_vscode_languageserver_protocol23 = __toESM(require_main2());

// src/utils/arrays.ts
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function flatten(arr) {
  return [].concat.apply([], arr);
}

// src/server/features/fileConfigurationManager.ts
var import_coc4 = require("coc.nvim");
var import_vscode_languageserver_protocol2 = __toESM(require_main2());
function objAreEqual(a, b) {
  let keys = Object.keys(a);
  for (let i = 0; i < keys.length; i++) {
    let key = keys[i];
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
var FileConfigurationManager = class {
  constructor(client) {
    this.client = client;
    this.cachedMap = /* @__PURE__ */ new Map();
    this.disposables = [];
    import_coc4.workspace.onDidCloseTextDocument((textDocument) => {
      this.cachedMap.delete(textDocument.uri);
    }, void 0, this.disposables);
  }
  async ensureConfigurationOptions(document, insertSpaces, tabSize, token) {
    const file2 = this.client.toPath(document.uri);
    let options = {
      tabSize,
      insertSpaces
    };
    let cachedOption = this.cachedMap.get(document.uri);
    const currentOptions = this.getFileOptions(options, document);
    if (cachedOption && objAreEqual(cachedOption.formatOptions, currentOptions.formatOptions) && objAreEqual(cachedOption.preferences, currentOptions.preferences))
      return;
    this.cachedMap.set(document.uri, currentOptions);
    const args = __spreadValues({
      file: file2
    }, currentOptions);
    await this.client.execute("configure", args, import_vscode_languageserver_protocol2.CancellationToken.None);
    try {
      const response = await this.client.execute("configure", args, token);
      if (response.type !== "response") {
        this.cachedMap.delete(document.uri);
      }
    } catch (_e) {
      this.cachedMap.delete(document.uri);
    }
  }
  async ensureConfigurationForDocument(document, token) {
    let opts;
    let cached = this.cachedMap.get(document.uri);
    if (cached) {
      opts = { insertSpaces: cached.formatOptions.convertTabsToSpaces, tabSize: cached.formatOptions.tabSize };
    } else {
      opts = await import_coc4.workspace.getFormatOptions(document.uri);
    }
    return this.ensureConfigurationOptions(document, opts.insertSpaces, opts.tabSize, token);
  }
  reset() {
    this.cachedMap.clear();
  }
  getLanguageConfiguration(languageId) {
    return import_coc4.workspace.getConfiguration(languageId);
  }
  isTypeScriptDocument(languageId) {
    return languageId.startsWith("typescript");
  }
  formatEnabled(document) {
    let { languageId, uri } = document;
    let language2 = languageId.startsWith("typescript") ? "typescript" : "javascript";
    const config = import_coc4.workspace.getConfiguration(`${language2}.format`, uri);
    return config.get("enabled");
  }
  enableJavascript() {
    const config = import_coc4.workspace.getConfiguration("tsserver");
    return !!config.get("enableJavascript");
  }
  getFileOptions(options, document) {
    const lang = this.isTypeScriptDocument(document.languageId) ? "typescript" : "javascript";
    return {
      formatOptions: this.getFormatOptions(options, lang, document.uri),
      preferences: this.getPreferences(lang, document.uri)
    };
  }
  getFormatOptions(options, language2, uri) {
    const config = import_coc4.workspace.getConfiguration(`${language2}.format`, uri);
    return {
      tabSize: options.tabSize,
      indentSize: options.tabSize,
      convertTabsToSpaces: options.insertSpaces,
      newLineCharacter: "\n",
      insertSpaceAfterCommaDelimiter: config.get("insertSpaceAfterCommaDelimiter"),
      insertSpaceAfterConstructor: config.get("insertSpaceAfterConstructor"),
      insertSpaceAfterSemicolonInForStatements: config.get("insertSpaceAfterSemicolonInForStatements"),
      insertSpaceBeforeAndAfterBinaryOperators: config.get("insertSpaceBeforeAndAfterBinaryOperators"),
      insertSpaceAfterKeywordsInControlFlowStatements: config.get("insertSpaceAfterKeywordsInControlFlowStatements"),
      insertSpaceAfterFunctionKeywordForAnonymousFunctions: config.get("insertSpaceAfterFunctionKeywordForAnonymousFunctions"),
      insertSpaceBeforeFunctionParenthesis: config.get("insertSpaceBeforeFunctionParenthesis"),
      insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis"),
      insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets"),
      insertSpaceAfterOpeningAndBeforeClosingEmptyBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingEmptyBraces"),
      insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces"),
      insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces"),
      insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces"),
      insertSpaceAfterTypeAssertion: config.get("insertSpaceAfterTypeAssertion"),
      placeOpenBraceOnNewLineForFunctions: config.get("placeOpenBraceOnNewLineForFunctions"),
      placeOpenBraceOnNewLineForControlBlocks: config.get("placeOpenBraceOnNewLineForControlBlocks"),
      semicolons: config.get("semicolons", void 0)
    };
  }
  getCompleteOptions(languageId) {
    const lang = this.isTypeScriptDocument(languageId) ? "typescript" : "javascript";
    const config = import_coc4.workspace.getConfiguration(`${lang}.suggest`);
    return {
      enabled: config.get("enabled", true),
      names: config.get("names", true),
      paths: config.get("paths", true),
      completeFunctionCalls: config.get("completeFunctionCalls", true),
      autoImports: config.get("autoImports", true),
      includeCompletionsWithObjectLiteralMethodSnippets: config.get("suggest.objectLiteralMethodSnippets.enabled", true),
      generateReturnInDocTemplate: config.get("jsdoc.generateReturns", true),
      importStatementSuggestions: config.get("importStatements", true),
      includeCompletionsForImportStatements: config.get("includeCompletionsForImportStatements", true),
      includeCompletionsWithSnippetText: config.get("includeCompletionsWithSnippetText", true),
      includeCompletionsWithClassMemberSnippets: config.get("classMemberSnippets.enabled", true),
      includeAutomaticOptionalChainCompletions: config.get("includeAutomaticOptionalChainCompletions", true)
    };
  }
  getPreferences(language2, uri) {
    if (this.client.apiVersion.lt(API.v290)) {
      return {};
    }
    const config = import_coc4.workspace.getConfiguration(language2, uri);
    const preferencesConfig = import_coc4.workspace.getConfiguration(`${language2}.preferences`, uri);
    const suggestConfig = this.getCompleteOptions(language2);
    const preferences = __spreadValues({
      quotePreference: this.getQuoteStyle(preferencesConfig),
      importModuleSpecifierPreference: getImportModuleSpecifier(preferencesConfig),
      importModuleSpecifierEnding: getImportModuleSpecifierEndingPreference(preferencesConfig),
      jsxAttributeCompletionStyle: getJsxAttributeCompletionStyle(preferencesConfig),
      allowTextChangesInNewFiles: uri.startsWith("file:"),
      allowRenameOfImportPath: true,
      provideRefactorNotApplicableReason: false,
      providePrefixAndSuffixTextForRename: preferencesConfig.get("renameShorthandProperties", true) === false ? false : preferencesConfig.get("useAliasesForRenames", true),
      generateReturnInDocTemplate: suggestConfig.generateReturnInDocTemplate,
      includeCompletionsForImportStatements: suggestConfig.includeCompletionsForImportStatements,
      includeCompletionsWithClassMemberSnippets: suggestConfig.includeCompletionsWithClassMemberSnippets,
      includeCompletionsWithSnippetText: suggestConfig.includeCompletionsWithSnippetText,
      includeCompletionsWithObjectLiteralMethodSnippets: suggestConfig.includeCompletionsWithObjectLiteralMethodSnippets,
      includeAutomaticOptionalChainCompletions: suggestConfig.includeAutomaticOptionalChainCompletions,
      useLabelDetailsInCompletionEntries: true,
      allowIncompleteCompletions: true,
      displayPartsForJSDoc: true
    }, getInlayHintsPreferences(config));
    return preferences;
  }
  getQuoteStyle(config) {
    let quoteStyle = config.get("quoteStyle", "auto");
    if (this.client.apiVersion.gte(API.v333) || quoteStyle != "auto")
      return quoteStyle;
    return "single";
  }
  dispose() {
    (0, import_coc4.disposeAll)(this.disposables);
  }
};
function getImportModuleSpecifier(config) {
  let val = config.get("importModuleSpecifier");
  switch (val) {
    case "project-relative":
      return "project-relative";
    case "relative":
      return "relative";
    case "non-relative":
      return "non-relative";
    default:
      return void 0;
  }
}
function getImportModuleSpecifierEndingPreference(config) {
  switch (config.get("importModuleSpecifierEnding")) {
    case "minimal":
      return "minimal";
    case "index":
      return "index";
    case "js":
      return "js";
    default:
      return "auto";
  }
}
function getJsxAttributeCompletionStyle(config) {
  switch (config.get("jsxAttributeCompletionStyle")) {
    case "braces":
      return "braces";
    case "none":
      return "none";
    default:
      return "auto";
  }
}
var InlayHintSettingNames = class {
};
InlayHintSettingNames.parameterNamesSuppressWhenArgumentMatchesName = "inlayHints.parameterNames.suppressWhenArgumentMatchesName";
InlayHintSettingNames.parameterNamesEnabled = "inlayHints.parameterTypes.enabled";
InlayHintSettingNames.variableTypesEnabled = "inlayHints.variableTypes.enabled";
InlayHintSettingNames.propertyDeclarationTypesEnabled = "inlayHints.propertyDeclarationTypes.enabled";
InlayHintSettingNames.functionLikeReturnTypesEnabled = "inlayHints.functionLikeReturnTypes.enabled";
InlayHintSettingNames.enumMemberValuesEnabled = "inlayHints.enumMemberValues.enabled";
function getInlayHintsPreferences(config) {
  return {
    includeInlayParameterNameHints: getInlayParameterNameHintsPreference(config),
    includeInlayParameterNameHintsWhenArgumentMatchesName: !config.get(InlayHintSettingNames.parameterNamesSuppressWhenArgumentMatchesName, true),
    includeInlayFunctionParameterTypeHints: config.get(InlayHintSettingNames.parameterNamesEnabled, false),
    includeInlayVariableTypeHints: config.get(InlayHintSettingNames.variableTypesEnabled, false),
    includeInlayPropertyDeclarationTypeHints: config.get(InlayHintSettingNames.propertyDeclarationTypesEnabled, false),
    includeInlayFunctionLikeReturnTypeHints: config.get(InlayHintSettingNames.functionLikeReturnTypesEnabled, false),
    includeInlayEnumMemberValueHints: config.get(InlayHintSettingNames.enumMemberValuesEnabled, false)
  };
}
function getInlayParameterNameHintsPreference(config) {
  switch (config.get("inlayHints.parameterNames.enabled")) {
    case "none":
      return "none";
    case "literals":
      return "literals";
    case "all":
      return "all";
    default:
      return void 0;
  }
}

// src/server/features/watchBuild.ts
var import_coc5 = require("coc.nvim");
var import_path2 = __toESM(require("path"));
var countRegex = /Found\s+(\d+)\s+error/;
var errorRegex = /^(.+)\((\d+),(\d+)\):\s(\w+)\sTS(\d+):\s*(.+)$/;
var _WatchProject = class {
  constructor(client) {
    this.client = client;
    this.disposables = [];
    this.statusItem = import_coc5.window.createStatusBarItem(1, { progress: true });
    let task = this.task = import_coc5.workspace.createTask("TSC");
    this.disposables.push(import_coc5.commands.registerCommand(_WatchProject.id, async () => {
      let opts = this.options = await this.getOptions();
      await this.start(opts);
    }));
    task.onExit((code) => {
      if (code != 0) {
        import_coc5.window.showMessage(`TSC exit with code ${code}`, "warning");
      }
      this.onStop();
    });
    task.onStdout((lines) => {
      for (let line of lines) {
        this.onLine(line);
      }
    });
    task.onStderr((lines) => {
      import_coc5.window.showMessage(`TSC error: ` + lines.join("\n"), "error");
    });
    this.disposables.push(import_coc5.Disposable.create(() => {
      task.dispose();
    }));
    this.check().catch((_e) => {
    });
  }
  async check() {
    let running = await this.task.running;
    if (running) {
      this.options = await this.getOptions();
      this.statusItem.isProgress = false;
      this.statusItem.text = "?";
      this.statusItem.show();
    } else {
      this.onStop();
    }
  }
  async start(options) {
    await this.task.start(options);
  }
  onStop() {
    this.statusItem.hide();
  }
  onStart() {
    this.statusItem.text = "compiling";
    this.statusItem.isProgress = true;
    this.statusItem.show();
    import_coc5.workspace.nvim.call("setqflist", [[]], true);
  }
  onLine(line) {
    if (countRegex.test(line)) {
      let ms = line.match(countRegex);
      this.statusItem.text = ms[1] == "0" ? "\u2713" : "\u2717";
      this.statusItem.isProgress = false;
    } else if (_WatchProject.startTexts.findIndex((s) => line.indexOf(s) !== -1) != -1) {
      this.onStart();
    } else {
      let ms = line.match(errorRegex);
      if (!ms)
        return;
      let fullpath = import_path2.default.join(this.options.cwd, ms[1]);
      let uri = import_coc5.Uri.file(fullpath).toString();
      let doc = import_coc5.workspace.getDocument(uri);
      let bufnr = doc ? doc.bufnr : null;
      let item = {
        filename: fullpath,
        lnum: Number(ms[2]),
        col: Number(ms[3]),
        text: `[tsc ${ms[5]}] ${ms[6]}`,
        type: /error/i.test(ms[4]) ? "E" : "W"
      };
      if (bufnr)
        item.bufnr = bufnr;
      import_coc5.workspace.nvim.call("setqflist", [[item], "a"]);
    }
  }
  async getOptions() {
    let { tscPath } = this.client;
    if (!tscPath) {
      import_coc5.window.showMessage(`Local & global tsc not found`, "error");
      return;
    }
    const tsconfigPath = import_coc5.workspace.getConfiguration("tsserver").get("tsconfigPath", "tsconfig.json");
    let find = await import_coc5.workspace.findUp([tsconfigPath]);
    if (!find) {
      import_coc5.window.showMessage(`${tsconfigPath} not found!`, "error");
      return;
    }
    let root = import_path2.default.dirname(find);
    return {
      cmd: tscPath,
      args: ["-p", tsconfigPath, "--watch", "true", "--pretty", "false"],
      cwd: root
    };
  }
  dispose() {
    (0, import_coc5.disposeAll)(this.disposables);
  }
};
var WatchProject = _WatchProject;
WatchProject.id = "tsserver.watchBuild";
WatchProject.startTexts = ["Starting compilation in watch mode", "Starting incremental compilation"];

// src/server/features/workspaceSymbols.ts
var import_coc6 = require("coc.nvim");
var import_vscode_languageserver_protocol3 = __toESM(require_main2());
function parseKindModifier(kindModifiers) {
  return new Set(kindModifiers.split(/,|\s+/g));
}
function getSymbolKind(item) {
  switch (item.kind) {
    case "method":
      return import_vscode_languageserver_protocol3.SymbolKind.Method;
    case "enum":
      return import_vscode_languageserver_protocol3.SymbolKind.Enum;
    case "function":
      return import_vscode_languageserver_protocol3.SymbolKind.Function;
    case "class":
      return import_vscode_languageserver_protocol3.SymbolKind.Class;
    case "interface":
      return import_vscode_languageserver_protocol3.SymbolKind.Interface;
    case "var":
      return import_vscode_languageserver_protocol3.SymbolKind.Variable;
    default:
      return import_vscode_languageserver_protocol3.SymbolKind.Variable;
  }
}
var TypeScriptWorkspaceSymbolProvider = class {
  constructor(client, languageIds) {
    this.client = client;
    this.languageIds = languageIds;
  }
  async provideWorkspaceSymbols(search, token) {
    let filepath;
    if (this.searchAllOpenProjects) {
      filepath = void 0;
    } else {
      let uri = this.getUri();
      filepath = uri ? this.client.toPath(uri) : void 0;
      if (!filepath && this.client.apiVersion.lt(API.v390)) {
        return [];
      }
    }
    const args = {
      file: filepath,
      searchValue: search,
      maxResultCount: 256
    };
    const response = await this.client.execute("navto", args, token);
    if (response.type !== "response" || response.body == null)
      return [];
    const result = [];
    for (const item of response.body) {
      if (!item.containerName && item.kind === "alias") {
        continue;
      }
      const label = TypeScriptWorkspaceSymbolProvider.getLabel(item);
      const range = {
        start: Position2.fromLocation(item.start),
        end: Position2.fromLocation(item.end)
      };
      const symbolInfo = import_vscode_languageserver_protocol3.SymbolInformation.create(label, getSymbolKind(item), range, this.client.toResource(item.file));
      const kindModifiers = item.kindModifiers ? parseKindModifier(item.kindModifiers) : void 0;
      if (kindModifiers == null ? void 0 : kindModifiers.has(KindModifiers.deprecated)) {
        symbolInfo.tags = [import_vscode_languageserver_protocol3.SymbolTag.Deprecated];
      }
      result.push(symbolInfo);
    }
    return result;
  }
  static getLabel(item) {
    let label = item.name;
    if (item.kind === "method" || item.kind === "function") {
      label += "()";
    }
    return label;
  }
  getUri() {
    const documents = import_coc6.workspace.textDocuments;
    for (const document of documents) {
      if (this.languageIds.indexOf(document.languageId) >= 0) {
        return document.uri;
      }
    }
    return void 0;
  }
  get searchAllOpenProjects() {
    return this.client.apiVersion.gte(API.v390) && import_coc6.workspace.getConfiguration("typescript").get("workspaceSymbols.scope", "allOpenProjects") === "allOpenProjects";
  }
};

// src/server/languageProvider.ts
var import_coc27 = require("coc.nvim");
var import_path5 = __toESM(require("path"));
var import_vscode_languageserver_protocol17 = __toESM(require_main2());

// src/server/features/baseCodeLensProvider.ts
var import_vscode_languageserver_protocol4 = __toESM(require_main2());

// src/server/utils/regexp.ts
function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}

// src/server/features/baseCodeLensProvider.ts
var CachedNavTreeResponse = class {
  constructor() {
    this.version = -1;
    this.document = "";
  }
  execute(document, f) {
    if (this.matches(document)) {
      return this.response;
    }
    return this.update(document, f());
  }
  matches(document) {
    return this.version === document.version && this.document === document.uri.toString();
  }
  update(document, response) {
    this.response = response;
    this.version = document.version;
    this.document = document.uri.toString();
    return response;
  }
};
var TypeScriptBaseCodeLensProvider = class {
  constructor(client, cachedResponse, modeId) {
    this.client = client;
    this.cachedResponse = cachedResponse;
    this.modeId = modeId;
    this.onDidChangeCodeLensesEmitter = new import_vscode_languageserver_protocol4.Emitter();
  }
  get onDidChangeCodeLenses() {
    return this.onDidChangeCodeLensesEmitter.event;
  }
  async provideCodeLenses(document, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return [];
    }
    try {
      const response = await this.cachedResponse.execute(document, () => this.client.execute("navtree", { file: filepath }, token));
      if (!response) {
        return [];
      }
      const tree = response.body;
      const referenceableSpans = [];
      if (tree && tree.childItems) {
        tree.childItems.forEach((item) => this.walkNavTree(document, item, null, referenceableSpans));
      }
      return referenceableSpans.map((range) => {
        return {
          range,
          data: { uri: document.uri }
        };
      });
    } catch {
      return [];
    }
  }
  walkNavTree(document, item, parent, results) {
    if (!item) {
      return;
    }
    const range = this.extractSymbol(document, item, parent);
    if (range) {
      results.push(range);
    }
    if (item.childItems) {
      item.childItems.forEach((child) => this.walkNavTree(document, child, item, results));
    }
  }
};
function getSymbolRange(document, item) {
  if (item.nameSpan) {
    return Range3.fromTextSpan(item.nameSpan);
  }
  const span = item.spans && item.spans[0];
  if (!span) {
    return null;
  }
  const range = Range3.fromTextSpan(span);
  const text = document.getText(range);
  const identifierMatch = new RegExp(`^(.*?(\\b|\\W))${escapeRegExp(item.text || "")}(\\b|\\W)`, "gm");
  const match = identifierMatch.exec(text);
  const prefixLength = match ? match.index + match[1].length : 0;
  const startOffset = document.offsetAt(range.start) + prefixLength;
  return {
    start: document.positionAt(startOffset),
    end: document.positionAt(startOffset + item.text.length)
  };
}

// src/server/features/callHierarchy.ts
var import_coc7 = require("coc.nvim");
var import_path3 = __toESM(require("path"));
var import_vscode_languageserver_protocol5 = __toESM(require_main2());
var TypeScriptCallHierarchySupport = class {
  constructor(client) {
    this.client = client;
  }
  async prepareCallHierarchy(document, position, token) {
    const filepath = this.client.toOpenedFilePath(document.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position2.toFileLocationRequestArgs(filepath, position);
    const response = await this.client.execute("prepareCallHierarchy", args, token);
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    return Array.isArray(response.body) ? response.body.map(fromProtocolCallHierarchyItem) : fromProtocolCallHierarchyItem(response.body);
  }
  async provideCallHierarchyIncomingCalls(item, token) {
    const filepath = this.client.toPath(item.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position2.toFileLocationRequestArgs(filepath, item.selectionRange.start);
    const response = await this.client.execute("provideCallHierarchyIncomingCalls", args, token);
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    return response.body.map(fromProtocolCallHierarchyIncomingCall);
  }
  async provideCallHierarchyOutgoingCalls(item, token) {
    const filepath = this.client.toPath(item.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position2.toFileLocationRequestArgs(filepath, item.selectionRange.start);
    const response = await this.client.execute("provideCallHierarchyOutgoingCalls", args, token);
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    return response.body.map(fromProtocolCallHierarchyOutgoingCall);
  }
};
TypeScriptCallHierarchySupport.minVersion = API.v380;
function isSourceFileItem(item) {
  return item.kind === Kind.script || item.kind === Kind.module && item.selectionSpan.start.line === 1 && item.selectionSpan.start.offset === 1;
}
function parseKindModifier2(kindModifiers) {
  return new Set(kindModifiers.split(/,|\s+/g));
}
function fromProtocolCallHierarchyItem(item) {
  var _a;
  const useFileName = isSourceFileItem(item);
  const name = useFileName ? import_path3.default.basename(item.file) : item.name;
  const detail = useFileName ? import_path3.default.relative(import_coc7.workspace.cwd, import_path3.default.dirname(item.file)) : (_a = item.containerName) != null ? _a : "";
  const result = {
    name,
    detail,
    uri: import_coc7.Uri.file(item.file).toString(),
    kind: SymbolKind3.fromProtocolScriptElementKind(item.kind),
    range: Range3.fromTextSpan(item.span),
    selectionRange: Range3.fromTextSpan(item.selectionSpan)
  };
  const kindModifiers = item.kindModifiers ? parseKindModifier2(item.kindModifiers) : void 0;
  if (kindModifiers == null ? void 0 : kindModifiers.has(KindModifiers.deprecated)) {
    result.tags = [import_vscode_languageserver_protocol5.SymbolTag.Deprecated];
  }
  return result;
}
function fromProtocolCallHierarchyIncomingCall(item) {
  return {
    from: fromProtocolCallHierarchyItem(item.from),
    fromRanges: item.fromSpans.map(Range3.fromTextSpan)
  };
}
function fromProtocolCallHierarchyOutgoingCall(item) {
  return {
    to: fromProtocolCallHierarchyItem(item.to),
    fromRanges: item.fromSpans.map(Range3.fromTextSpan)
  };
}

// src/server/features/completionItemProvider.ts
var import_coc11 = require("coc.nvim");
var import_vscode_languageserver_protocol9 = __toESM(require_main2());

// src/server/utils/codeAction.ts
var import_vscode_languageserver_protocol6 = __toESM(require_main2());
var import_coc8 = require("coc.nvim");
function getEditForCodeAction(client, action) {
  return action.changes && action.changes.length ? WorkspaceEdit2.fromFileCodeEdits(client, action.changes) : void 0;
}
async function applyCodeAction(client, action) {
  const workspaceEdit = getEditForCodeAction(client, action);
  if (workspaceEdit) {
    if (!await import_coc8.workspace.applyEdit(workspaceEdit)) {
      return false;
    }
  }
  return applyCodeActionCommands(client, action);
}
async function applyCodeActionCommands(client, action) {
  if (action.commands && action.commands.length) {
    for (const command of action.commands) {
      const response = await client.execute("applyCodeActionCommand", { command }, import_vscode_languageserver_protocol6.CancellationToken.None);
      if (!response || response.type != "response" || !response.body) {
        return false;
      }
    }
  }
  return true;
}

// src/server/utils/completionItem.ts
var import_coc9 = require("coc.nvim");
var import_vscode_languageserver_protocol7 = __toESM(require_main2());
function convertCompletionEntry(tsEntry, uri, position, context) {
  let label = tsEntry.name;
  let sortText = tsEntry.sortText;
  let preselect = false;
  let detail;
  if (tsEntry.isRecommended) {
    preselect = true;
  }
  if (tsEntry.source && tsEntry.hasAction) {
    sortText = "\uFFFF" + sortText;
  } else {
    sortText = tsEntry.sortText;
  }
  let kind = convertKind(tsEntry.kind);
  let insertTextFormat = context.enableCallCompletions && (kind === import_coc9.CompletionItemKind.Function || kind === import_coc9.CompletionItemKind.Method) ? import_coc9.InsertTextFormat.Snippet : import_coc9.InsertTextFormat.PlainText;
  let insertText = tsEntry.insertText;
  let commitCharacters = getCommitCharacters(tsEntry, context);
  let tags;
  if (tsEntry.isImportStatementCompletion) {
    insertText = label;
    insertTextFormat = import_coc9.InsertTextFormat.Snippet;
  }
  if (tsEntry.isSnippet) {
    insertTextFormat = import_coc9.InsertTextFormat.Snippet;
  }
  let textEdit = null;
  if (tsEntry.replacementSpan) {
    let { start, end } = tsEntry.replacementSpan;
    if (start.line == end.line) {
      textEdit = {
        range: import_coc9.Range.create(start.line - 1, start.offset - 1, end.line - 1, end.offset - 1),
        newText: tsEntry.insertText || label
      };
    }
  }
  if (tsEntry.kindModifiers) {
    const kindModifiers = new Set(tsEntry.kindModifiers.split(/,|\s+/g));
    if (kindModifiers.has(KindModifiers.optional)) {
      insertText = insertText != null ? insertText : label;
      label += "?";
    }
    if (kindModifiers.has(KindModifiers.deprecated)) {
      tags = [import_vscode_languageserver_protocol7.CompletionItemTag.Deprecated];
    }
    if (kindModifiers.has(KindModifiers.color)) {
      kind = import_coc9.CompletionItemKind.Color;
    }
    if (tsEntry.kind === Kind.script) {
      for (const extModifier of KindModifiers.fileExtensionKindModifiers) {
        if (kindModifiers.has(extModifier)) {
          if (tsEntry.name.toLowerCase().endsWith(extModifier)) {
            detail = tsEntry.name;
          } else {
            detail = tsEntry.name + extModifier;
          }
          break;
        }
      }
    }
  }
  return {
    label,
    insertText,
    textEdit,
    kind,
    tags,
    preselect,
    insertTextFormat,
    sortText,
    commitCharacters,
    detail,
    data: {
      uri,
      position,
      name: tsEntry.name,
      data: tsEntry.data,
      source: tsEntry.source || ""
    }
  };
}
function convertKind(kind) {
  switch (kind) {
    case Kind.primitiveType:
    case Kind.keyword:
      return import_coc9.CompletionItemKind.Keyword;
    case Kind.const:
      return import_coc9.CompletionItemKind.Constant;
    case Kind.let:
    case Kind.variable:
    case Kind.localVariable:
    case Kind.alias:
      return import_coc9.CompletionItemKind.Variable;
    case Kind.memberVariable:
    case Kind.memberGetAccessor:
    case Kind.memberSetAccessor:
      return import_coc9.CompletionItemKind.Field;
    case Kind.function:
    case Kind.localFunction:
      return import_coc9.CompletionItemKind.Function;
    case Kind.method:
    case Kind.constructSignature:
    case Kind.callSignature:
    case Kind.indexSignature:
      return import_coc9.CompletionItemKind.Method;
    case Kind.enum:
      return import_coc9.CompletionItemKind.Enum;
    case Kind.module:
    case Kind.externalModuleName:
      return import_coc9.CompletionItemKind.Module;
    case Kind.class:
    case Kind.type:
      return import_coc9.CompletionItemKind.Class;
    case Kind.interface:
      return import_coc9.CompletionItemKind.Interface;
    case Kind.warning:
    case Kind.script:
      return import_coc9.CompletionItemKind.File;
    case Kind.directory:
      return import_coc9.CompletionItemKind.Folder;
  }
  return import_coc9.CompletionItemKind.Variable;
}
function getCommitCharacters(tsEntry, context) {
  if (context.isNewIdentifierLocation || !context.isInValidCommitCharacterContext) {
    return void 0;
  }
  const commitCharacters = [];
  switch (tsEntry.kind) {
    case Kind.memberGetAccessor:
    case Kind.memberSetAccessor:
    case Kind.constructSignature:
    case Kind.callSignature:
    case Kind.indexSignature:
    case Kind.enum:
    case Kind.interface:
      commitCharacters.push(".", ";");
      break;
    case Kind.module:
    case Kind.alias:
    case Kind.const:
    case Kind.let:
    case Kind.variable:
    case Kind.localVariable:
    case Kind.memberVariable:
    case Kind.class:
    case Kind.function:
    case Kind.method:
    case Kind.keyword:
    case Kind.parameter:
      commitCharacters.push(".", ",", ";");
      if (context.enableCallCompletions) {
        commitCharacters.push("(");
      }
      break;
  }
  return commitCharacters.length === 0 ? void 0 : commitCharacters;
}
function getParameterListParts(displayParts) {
  const parts = [];
  let isInMethod = false;
  let hasOptionalParameters = false;
  let parenCount = 0;
  let braceCount = 0;
  outer:
    for (let i = 0; i < displayParts.length; ++i) {
      const part = displayParts[i];
      switch (part.kind) {
        case DisplayPartKind.methodName:
        case DisplayPartKind.functionName:
        case DisplayPartKind.text:
        case DisplayPartKind.propertyName:
          if (parenCount === 0 && braceCount === 0) {
            isInMethod = true;
          }
          break;
        case DisplayPartKind.parameterName:
          if (parenCount === 1 && braceCount === 0 && isInMethod) {
            const next = displayParts[i + 1];
            const nameIsFollowedByOptionalIndicator = next && next.text === "?";
            const nameIsThis = part.text === "this";
            if (!nameIsFollowedByOptionalIndicator && !nameIsThis) {
              parts.push(part);
            }
            hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;
          }
          break;
        case DisplayPartKind.punctuation:
          if (part.text === "(") {
            ++parenCount;
          } else if (part.text === ")") {
            --parenCount;
            if (parenCount <= 0 && isInMethod) {
              break outer;
            }
          } else if (part.text === "..." && parenCount === 1) {
            hasOptionalParameters = true;
            break outer;
          } else if (part.text === "{") {
            ++braceCount;
          } else if (part.text === "}") {
            --braceCount;
          }
          break;
      }
    }
  return { hasOptionalParameters, parts };
}

// src/server/utils/previewer.ts
var import_vscode_languageserver_protocol8 = __toESM(require_main2());
var import_coc10 = require("coc.nvim");
function toResource(filepath) {
  return import_coc10.Uri.file(filepath);
}
function replaceLinks(text) {
  return text.replace(/\{@(link|linkplain|linkcode) (https?:\/\/[^ |}]+?)(?:[| ]([^{}\n]+?))?\}/gi, (_, tag, link, text2) => {
    switch (tag) {
      case "linkcode":
        return `[\`${text2 ? text2.trim() : link}\`](${link})`;
      default:
        return `[${text2 ? text2.trim() : link}](${link})`;
    }
  });
}
function processInlineTags(text) {
  return replaceLinks(text);
}
function getTagBodyText(tag) {
  if (!tag.text) {
    return void 0;
  }
  function makeCodeblock(text2) {
    if (text2.match(/^\s*[~`]{3}/g)) {
      return text2;
    }
    return "```\n" + text2 + "\n```";
  }
  const text = convertLinkTags(tag.text);
  switch (tag.name) {
    case "example":
      const captionTagMatches = text.match(/<caption>(.*?)<\/caption>\s*(\r\n|\n)/);
      if (captionTagMatches && captionTagMatches.index === 0) {
        return captionTagMatches[1] + "\n\n" + makeCodeblock(text.substr(captionTagMatches[0].length));
      } else {
        return makeCodeblock(text);
      }
    case "author":
      const emailMatch = text.match(/(.+)\s<([-.\w]+@[-.\w]+)>/);
      if (emailMatch === null) {
        return text;
      } else {
        return `${emailMatch[1]} ${emailMatch[2]}`;
      }
    case "default":
      return makeCodeblock(text);
  }
  return processInlineTags(text);
}
function getTagDocumentation(tag) {
  switch (tag.name) {
    case "augments":
    case "extends":
    case "param":
    case "template":
      const body = convertLinkTags(tag.text).split(/^(\S+)\s*-?\s*/);
      if ((body == null ? void 0 : body.length) === 3) {
        const param = body[1];
        const doc = body[2];
        const label2 = `*@${tag.name}* \`${param}\``;
        if (!doc) {
          return label2;
        }
        return label2 + (doc.match(/\r\n|\n/g) ? "  \n" + processInlineTags(doc) : ` \u2014 ${processInlineTags(doc)}`);
      }
  }
  const label = `*@${tag.name}*`;
  const text = getTagBodyText(tag);
  if (!text) {
    return label;
  }
  return label + (text.match(/\r\n|\n/g) ? "  \n" + text : ` \u2014 ${text}`);
}
function tagsMarkdownPreview(tags) {
  return (tags || []).map(getTagDocumentation).join("  \n\n");
}
function markdownDocumentation(documentation, tags) {
  let out = plainWithLinks(documentation);
  const tagsPreview = tagsMarkdownPreview(tags);
  if (tagsPreview) {
    out = out + ("\n\n" + tagsPreview);
  }
  return {
    kind: import_vscode_languageserver_protocol8.MarkupKind.Markdown,
    value: out
  };
}
function plainWithLinks(parts) {
  return processInlineTags(convertLinkTags(parts));
}
function convertLinkTags(parts) {
  var _a;
  if (!parts) {
    return "";
  }
  if (typeof parts === "string") {
    return parts;
  }
  const out = [];
  let currentLink;
  for (const part of parts) {
    switch (part.kind) {
      case "link":
        if (currentLink) {
          const text = (_a = currentLink.text) != null ? _a : currentLink.name;
          if (currentLink.target) {
            const link = toResource(currentLink.target.file).with({
              fragment: `L${currentLink.target.start.line},${currentLink.target.start.offset}`
            });
            out.push(`[${text}](${link.toString()})`);
          } else {
            if (text) {
              if (/^https?:/.test(text)) {
                const parts2 = text.split(" ");
                if (parts2.length === 1) {
                  out.push(parts2[0]);
                } else if (parts2.length > 1) {
                  out.push(`[${parts2.slice(1).join(" ")}](${parts2[0]})`);
                }
              } else {
                out.push(text);
              }
            }
          }
          currentLink = void 0;
        } else {
          currentLink = {};
        }
        break;
      case "linkName":
        if (currentLink) {
          currentLink.name = part.text;
          currentLink.target = part.target;
        }
        break;
      case "linkText":
        if (currentLink) {
          currentLink.text = part.text;
        }
        break;
      default:
        out.push(part.text);
        break;
    }
  }
  return processInlineTags(out.join(""));
}

// src/server/utils/SnippetString.ts
var SnippetString = class {
  constructor(value) {
    this._tabstop = 1;
    this.value = value || "";
  }
  static isSnippetString(thing) {
    if (thing instanceof SnippetString) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.value === "string";
  }
  static _escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  appendText(str) {
    this.value += SnippetString._escape(str);
    return this;
  }
  appendTabstop(n = this._tabstop++) {
    this.value += "$";
    this.value += n;
    return this;
  }
  appendPlaceholder(value, n = this._tabstop++) {
    if (typeof value === "function") {
      const nested = new SnippetString();
      nested._tabstop = this._tabstop;
      value(nested);
      this._tabstop = nested._tabstop;
      value = nested.value;
    } else {
      value = SnippetString._escape(value);
    }
    this.value += "${";
    this.value += n;
    this.value += ":";
    this.value += value;
    this.value += "}";
    return this;
  }
  appendVariable(name, defaultValue) {
    if (typeof defaultValue === "function") {
      const nested = new SnippetString();
      nested._tabstop = this._tabstop;
      defaultValue(nested);
      this._tabstop = nested._tabstop;
      defaultValue = nested.value;
    } else if (typeof defaultValue === "string") {
      defaultValue = defaultValue.replace(/\$|}/g, "\\$&");
    }
    this.value += "${";
    this.value += name;
    if (defaultValue) {
      this.value += ":";
      this.value += defaultValue;
    }
    this.value += "}";
    return this;
  }
};

// src/server/features/completionItemProvider.ts
var _ApplyCompletionCodeActionCommand = class {
  constructor(client) {
    this.client = client;
    this.id = _ApplyCompletionCodeActionCommand.ID;
  }
  async execute(codeActions) {
    if (codeActions.length === 0) {
      return;
    }
    if (codeActions.length === 1) {
      await applyCodeAction(this.client, codeActions[0]);
      return;
    }
    const idx = await import_coc11.window.showQuickpick(codeActions.map((o) => o.description), "Select code action to apply");
    if (idx < 0)
      return;
    const action = codeActions[idx];
    await applyCodeAction(this.client, action);
    return;
  }
};
var ApplyCompletionCodeActionCommand = _ApplyCompletionCodeActionCommand;
ApplyCompletionCodeActionCommand.ID = "_typescript.applyCompletionCodeAction";
var TypeScriptCompletionItemProvider = class {
  constructor(client, typingsStatus, fileConfigurationManager, languageId) {
    this.client = client;
    this.typingsStatus = typingsStatus;
    this.fileConfigurationManager = fileConfigurationManager;
    this.setCompleteOption(languageId);
    import_coc11.commands.registerCommand(ApplyCompletionCodeActionCommand.ID, async (codeActions) => {
      let cmd = new ApplyCompletionCodeActionCommand(this.client);
      await cmd.execute(codeActions);
    });
    import_coc11.workspace.onDidChangeConfiguration((_e) => {
      this.setCompleteOption(languageId);
    });
  }
  setCompleteOption(languageId) {
    this.completeOption = this.fileConfigurationManager.getCompleteOptions(languageId);
  }
  async provideCompletionItems(document, position, token, context) {
    if (this.typingsStatus.isAcquiringTypings) {
      return Promise.resolve({
        isIncomplete: true,
        items: [{
          label: "Acquiring typings...",
          detail: "Acquiring typings definitions for IntelliSense."
        }]
      });
    }
    let { uri } = document;
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return null;
    let preText = document.getText({
      start: { line: position.line, character: 0 },
      end: position
    });
    let { triggerCharacter, option } = context;
    if (!this.shouldTrigger(triggerCharacter, preText, option)) {
      return null;
    }
    await this.client.interruptGetErr(() => this.fileConfigurationManager.ensureConfigurationForDocument(document, token));
    const { completeOption } = this;
    const args = __spreadProps(__spreadValues({}, Position2.toFileLocationRequestArgs(file2, position)), {
      includeExternalModuleExports: completeOption.autoImports,
      includeInsertTextCompletions: true,
      triggerCharacter: this.getTsTriggerCharacter(context),
      includeAutomaticOptionalChainCompletions: completeOption.includeAutomaticOptionalChainCompletions
    });
    let entries;
    let dotAccessorContext;
    let isNewIdentifierLocation = true;
    let isMemberCompletion = false;
    let isIncomplete = false;
    const isInValidCommitCharacterContext = this.isInValidCommitCharacterContext(document, position);
    if (this.client.apiVersion.gte(API.v300)) {
      try {
        const response = await this.client.interruptGetErr(() => this.client.execute("completionInfo", args, token));
        if (response.type !== "response" || !response.body) {
          return null;
        }
        isNewIdentifierLocation = response.body.isNewIdentifierLocation;
        isMemberCompletion = response.body.isMemberCompletion;
        if (isMemberCompletion) {
          const dotMatch = preText.slice(0, position.character).match(/\??\.\s*$/) || void 0;
          if (dotMatch) {
            const range = import_vscode_languageserver_protocol9.Range.create({
              line: position.line,
              character: position.character - dotMatch.length
            }, position);
            const text = document.getText(range);
            dotAccessorContext = { range, text };
          }
        }
        isIncomplete = !!response.body.isIncomplete || response.metadata && response.metadata.isIncomplete;
        entries = response.body.entries;
      } catch (e) {
        if (e.message == "No content available.") {
          return null;
        }
        throw e;
      }
    } else {
      const response = await this.client.interruptGetErr(() => this.client.execute("completions", args, token));
      if (response.type !== "response" || !response.body) {
        return null;
      }
      entries = response.body;
    }
    const completionItems = [];
    for (const element of entries) {
      if (shouldExcludeCompletionEntry(element, completeOption)) {
        continue;
      }
      const item = convertCompletionEntry(element, uri, position, {
        isNewIdentifierLocation,
        isMemberCompletion,
        enableCallCompletions: completeOption.completeFunctionCalls,
        isInValidCommitCharacterContext,
        dotAccessorContext
      });
      completionItems.push(item);
    }
    return { isIncomplete, items: completionItems };
  }
  getTsTriggerCharacter(context) {
    switch (context.triggerCharacter) {
      case "@":
        return this.client.apiVersion.gte(API.v310) && this.client.apiVersion.lt(API.v320) ? void 0 : "@";
      case "#":
        return this.client.apiVersion.lt(API.v381) ? void 0 : "#";
      case " ":
        return this.client.apiVersion.gte(API.v430) ? " " : void 0;
      case ".":
      case '"':
      case "'":
      case "`":
      case "/":
      case "<":
        return context.triggerCharacter;
    }
    return void 0;
  }
  async resolveCompletionItem(item, token) {
    if (item == null)
      return void 0;
    let { uri, position, source, name, data } = item.data;
    const filepath = this.client.toPath(uri);
    if (!filepath)
      return void 0;
    let document = import_coc11.workspace.getDocument(uri);
    if (!document)
      return void 0;
    const args = __spreadProps(__spreadValues({}, Position2.toFileLocationRequestArgs(filepath, position)), {
      entryNames: [source ? { name, source, data } : name]
    });
    let response;
    try {
      response = await this.client.interruptGetErr(() => this.client.execute("completionEntryDetails", args, token));
    } catch {
      return item;
    }
    if (response.type !== "response" || !response.body || !response.body.length) {
      return item;
    }
    const details = response.body;
    if (!details || !details.length || !details[0]) {
      return item;
    }
    const detail = details[0];
    if (!item.detail && detail.displayParts.length) {
      item.detail = plainWithLinks(detail.displayParts);
    }
    item.documentation = this.getDocumentation(detail);
    const { command, additionalTextEdits } = this.getCodeActions(detail, filepath);
    if (command)
      item.command = command;
    item.additionalTextEdits = additionalTextEdits;
    if (detail && item.insertTextFormat == import_vscode_languageserver_protocol9.InsertTextFormat.Snippet) {
      const shouldCompleteFunction = await this.isValidFunctionCompletionContext(filepath, position, token);
      if (shouldCompleteFunction && !item.insertText) {
        this.createSnippetOfFunctionCall(item, detail);
      }
    }
    return item;
  }
  getCodeActions(detail, filepath) {
    if (!detail.codeActions || !detail.codeActions.length) {
      return {};
    }
    const additionalTextEdits = [];
    let hasRemainingCommandsOrEdits = false;
    for (const tsAction of detail.codeActions) {
      if (tsAction.commands) {
        hasRemainingCommandsOrEdits = true;
      }
      if (tsAction.changes) {
        for (const change of tsAction.changes) {
          if (change.fileName === filepath) {
            additionalTextEdits.push(...change.textChanges.map(TextEdit2.fromCodeEdit));
          } else {
            hasRemainingCommandsOrEdits = true;
          }
        }
      }
    }
    let command = null;
    if (hasRemainingCommandsOrEdits) {
      command = {
        title: "",
        command: ApplyCompletionCodeActionCommand.ID,
        arguments: [
          detail.codeActions.map((x) => ({
            commands: x.commands,
            description: x.description,
            changes: x.changes.filter((x2) => x2.fileName !== filepath)
          }))
        ]
      };
    }
    return {
      command,
      additionalTextEdits: additionalTextEdits.length ? additionalTextEdits : void 0
    };
  }
  shouldTrigger(triggerCharacter, pre, option) {
    if (triggerCharacter && this.client.apiVersion.lt(API.v290)) {
      if (triggerCharacter === "@") {
        if (option.synname && /string/i.test(option.synname)) {
          return true;
        }
        if (!pre.match(/^\s*\*[ ]?@/) && !pre.match(/\/\*\*+[ ]?@/)) {
          return false;
        }
      } else if (triggerCharacter === "<") {
        return false;
      }
    }
    if (triggerCharacter === " ") {
      if (!this.completeOption.importStatementSuggestions || !this.client.apiVersion.lt(API.v430)) {
        return false;
      }
      return pre === "import ";
    }
    return true;
  }
  getDocumentation(detail) {
    let documentation = "";
    if (detail.source) {
      const importPath = `'${plainWithLinks(detail.source)}'`;
      const autoImportLabel = `Auto import from ${importPath}`;
      documentation += `${autoImportLabel}
`;
    }
    let parts = [
      plainWithLinks(detail.documentation),
      tagsMarkdownPreview(detail.tags)
    ];
    parts = parts.filter((s) => s && s.trim() != "");
    documentation += parts.join("\n\n");
    if (documentation.length) {
      return {
        kind: import_vscode_languageserver_protocol9.MarkupKind.Markdown,
        value: documentation
      };
    }
    return void 0;
  }
  createSnippetOfFunctionCall(item, detail) {
    let { displayParts } = detail;
    const parameterListParts = getParameterListParts(displayParts);
    const snippet = new SnippetString();
    snippet.appendText(`${item.insertText || item.label}(`);
    appendJoinedPlaceholders(snippet, parameterListParts.parts, ", ");
    if (parameterListParts.hasOptionalParameters) {
      snippet.appendTabstop();
    }
    snippet.appendText(")");
    snippet.appendTabstop(0);
    item.insertText = snippet.value;
  }
  async isValidFunctionCompletionContext(filepath, position, token) {
    try {
      const args = Position2.toFileLocationRequestArgs(filepath, position);
      const response = await this.client.execute("quickinfo", args, token);
      if (response.type !== "response") {
        return true;
      }
      const { body } = response;
      switch (body && body.kind) {
        case "var":
        case "let":
        case "const":
        case "alias":
          return false;
        default:
          return true;
      }
    } catch (e) {
      return true;
    }
  }
  isInValidCommitCharacterContext(document, position) {
    if (this.client.apiVersion.lt(API.v320)) {
      if (position.character > 1) {
        const preText = document.getText(import_vscode_languageserver_protocol9.Range.create(position.line, 0, position.line, position.character));
        return preText.match(/(\s|^)\.$/ig) === null;
      }
    }
    return true;
  }
};
TypeScriptCompletionItemProvider.triggerCharacters = [".", '"', "'", "`", "/", "@", "<", "#", " "];
function shouldExcludeCompletionEntry(element, completionConfiguration) {
  return !completionConfiguration.names && element.kind === Kind.warning || !completionConfiguration.paths && (element.kind === Kind.directory || element.kind === Kind.script || element.kind === Kind.externalModuleName) || !completionConfiguration.autoImports && element.hasAction;
}
function appendJoinedPlaceholders(snippet, parts, joiner) {
  for (let i = 0; i < parts.length; ++i) {
    const paramterPart = parts[i];
    snippet.appendPlaceholder(paramterPart.text);
    if (i !== parts.length - 1) {
      snippet.appendText(joiner);
    }
  }
}

// src/server/features/definitionProvider.ts
var TypeScriptDefinitionProvider = class {
  constructor(client) {
    this.client = client;
  }
  async getSymbolLocations(definitionType, document, position, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position2.toFileLocationRequestArgs(filepath, position);
    try {
      const response = await this.client.execute(definitionType, args, token);
      const locations = response.type == "response" && response.body || [];
      return locations.map((location) => Location2.fromTextSpan(this.client.toResource(location.file), location));
    } catch {
      return [];
    }
  }
  async provideDefinition(document, position, token) {
    if (this.client.apiVersion.gte(API.v270)) {
      const filepath = this.client.toOpenedFilePath(document.uri);
      if (!filepath) {
        return void 0;
      }
      const args = Position2.toFileLocationRequestArgs(filepath, position);
      const response = await this.client.execute("definitionAndBoundSpan", args, token);
      if (response.type !== "response" || !response.body) {
        return void 0;
      }
      const span = response.body.textSpan ? Range3.fromTextSpan(response.body.textSpan) : void 0;
      return response.body.definitions.map((location) => {
        const target = Location2.fromTextSpan(this.client.toResource(location.file), location);
        if (location.contextStart && location.contextEnd) {
          return {
            originSelectionRange: span,
            targetRange: Range3.fromLocations(location.contextStart, location.contextEnd),
            targetUri: target.uri,
            targetSelectionRange: target.range
          };
        }
        return {
          originSelectionRange: span,
          targetRange: target.range,
          targetUri: target.uri,
          targetSelectionRange: target.range
        };
      });
    }
    return await this.getSymbolLocations("definition", document, position, token);
  }
  provideTypeDefinition(document, position, token) {
    return this.getSymbolLocations("typeDefinition", document, position, token);
  }
  provideImplementation(document, position, token) {
    return this.getSymbolLocations("implementation", document, position, token);
  }
};

// src/server/features/directiveCommentCompletions.ts
var import_coc12 = require("coc.nvim");
var import_coc13 = require("coc.nvim");
var tsDirectives = [
  {
    value: "@ts-check",
    description: "Enables semantic checking in a JavaScript file. Must be at the top of a file."
  },
  {
    value: "@ts-nocheck",
    description: "Disables semantic checking in a JavaScript file. Must be at the top of a file."
  },
  {
    value: "@ts-ignore",
    description: "Suppresses @ts-check errors on the next line of a file."
  }
];
var tsDirectives390 = [
  ...tsDirectives,
  {
    value: "@ts-expect-error",
    description: "Suppresses @ts-check errors on the next line of a file, expecting at least one to exist."
  }
];
var DirectiveCommentCompletionProvider = class {
  constructor(client) {
    this.client = client;
  }
  provideCompletionItems(document, position, _token, context) {
    if (context.triggerCharacter != "@") {
      return [];
    }
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return [];
    }
    const doc = import_coc13.workspace.getDocument(document.uri);
    const line = doc.getline(position.line);
    const prefix = line.slice(0, position.character);
    const match = prefix.match(/^\s*\/\/+\s?(@[a-zA-Z\-]*)?$/);
    if (match) {
      const directives = this.client.apiVersion.gte(API.v390) ? tsDirectives390 : tsDirectives;
      let items = directives.map((directive) => {
        const item = { label: directive.value };
        item.kind = import_coc12.CompletionItemKind.Snippet;
        item.detail = directive.description;
        item.textEdit = {
          range: import_coc12.Range.create(position.line, Math.max(0, position.character - (match[1] ? match[1].length : 0)), position.line, position.character),
          newText: directive.value
        };
        return item;
      });
      let res = {
        isIncomplete: false,
        items
      };
      res.startcol = doc.fixStartcol(position, ["@"]);
      return res;
    }
    return [];
  }
};

// src/server/features/documentHighlight.ts
var import_vscode_languageserver_protocol10 = __toESM(require_main2());
var TypeScriptDocumentHighlightProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideDocumentHighlights(resource, position, token) {
    const file2 = this.client.toPath(resource.uri);
    if (!file2)
      return [];
    const args = __spreadProps(__spreadValues({}, Position2.toFileLocationRequestArgs(file2, position)), {
      filesToSearch: [file2]
    });
    try {
      const response = await this.client.execute("documentHighlights", args, token);
      if (response.type !== "response" || !response.body) {
        return [];
      }
      return flatten(response.body.filter((highlight) => highlight.file === file2).map(convertDocumentHighlight));
    } catch (_e) {
      return [];
    }
  }
};
function convertDocumentHighlight(highlight) {
  return highlight.highlightSpans.map((span) => {
    return {
      range: Range3.fromTextSpan(span),
      kind: span.kind === "writtenReference" ? import_vscode_languageserver_protocol10.DocumentHighlightKind.Write : import_vscode_languageserver_protocol10.DocumentHighlightKind.Read
    };
  });
}

// src/server/features/documentSymbol.ts
var import_vscode_languageserver_protocol11 = __toESM(require_main2());
var getSymbolKind2 = (kind) => {
  switch (kind) {
    case Kind.module:
      return import_vscode_languageserver_protocol11.SymbolKind.Module;
    case Kind.class:
      return import_vscode_languageserver_protocol11.SymbolKind.Class;
    case Kind.enum:
      return import_vscode_languageserver_protocol11.SymbolKind.Enum;
    case Kind.interface:
      return import_vscode_languageserver_protocol11.SymbolKind.Interface;
    case Kind.method:
      return import_vscode_languageserver_protocol11.SymbolKind.Method;
    case Kind.memberVariable:
      return import_vscode_languageserver_protocol11.SymbolKind.Property;
    case Kind.memberGetAccessor:
      return import_vscode_languageserver_protocol11.SymbolKind.Property;
    case Kind.memberSetAccessor:
      return import_vscode_languageserver_protocol11.SymbolKind.Property;
    case Kind.variable:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.const:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.localVariable:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.variable:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.constructSignature:
    case Kind.constructorImplementation:
      return import_vscode_languageserver_protocol11.SymbolKind.Constructor;
    case Kind.function:
    case Kind.localFunction:
      return import_vscode_languageserver_protocol11.SymbolKind.Function;
  }
  return import_vscode_languageserver_protocol11.SymbolKind.Variable;
};
var TypeScriptDocumentSymbolProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideDocumentSymbols(resource, token) {
    const filepath = this.client.toPath(resource.uri);
    if (!filepath)
      return [];
    const args = {
      file: filepath
    };
    try {
      const response = await this.client.execute("navtree", args, token);
      if (response.type == "response" && response.body) {
        const tree = response.body;
        if (tree.childItems) {
          const result = new Array();
          tree.childItems.forEach((item) => TypeScriptDocumentSymbolProvider.convertNavTree(result, item));
          return result;
        }
      }
      return [];
    } catch (e) {
      return [];
    }
  }
  static convertNavTree(output, item) {
    let shouldInclude = TypeScriptDocumentSymbolProvider.shouldInclueEntry(item);
    const children = new Set(item.childItems || []);
    for (const span of item.spans) {
      const range = Range3.fromTextSpan(span);
      const symbolInfo = TypeScriptDocumentSymbolProvider.convertSymbol(item, range);
      if (children.size)
        symbolInfo.children = [];
      for (const child of children) {
        if (child.spans.some((span2) => !!containsRange(range, Range3.fromTextSpan(span2)))) {
          const includedChild = TypeScriptDocumentSymbolProvider.convertNavTree(symbolInfo.children, child);
          shouldInclude = shouldInclude || includedChild;
          children.delete(child);
        }
      }
      if (shouldInclude) {
        output.push(symbolInfo);
      }
    }
    return shouldInclude;
  }
  static convertSymbol(item, range) {
    const selectionRange = item.nameSpan ? Range3.fromTextSpan(item.nameSpan) : range;
    let label = item.text;
    switch (item.kind) {
      case Kind.memberGetAccessor:
        label = `(get) ${label}`;
        break;
      case Kind.memberSetAccessor:
        label = `(set) ${label}`;
        break;
    }
    const symbolInfo = import_vscode_languageserver_protocol11.DocumentSymbol.create(label, "", getSymbolKind2(item.kind), range, containsRange(range, selectionRange) ? selectionRange : range);
    const kindModifiers = parseKindModifier3(item.kindModifiers);
    if (kindModifiers.has(KindModifiers.deprecated)) {
      symbolInfo.tags = [import_vscode_languageserver_protocol11.SymbolTag.Deprecated];
    }
    return symbolInfo;
  }
  static shouldInclueEntry(item) {
    if (item.kind === Kind.alias) {
      return false;
    }
    return !!(item.text && item.text !== "<function>" && item.text !== "<class>");
  }
};
function containsRange(range, otherRange) {
  if (otherRange.start.line < range.start.line || otherRange.end.line < range.start.line) {
    return false;
  }
  if (otherRange.start.line > range.end.line || otherRange.end.line > range.end.line) {
    return false;
  }
  if (otherRange.start.line === range.start.line && otherRange.start.character < range.start.character) {
    return false;
  }
  if (otherRange.end.line === range.end.line && otherRange.end.character > range.end.character) {
    return false;
  }
  return true;
}
function parseKindModifier3(kindModifiers) {
  return new Set(kindModifiers.split(/,|\s+/g));
}

// src/server/features/folding.ts
var import_coc14 = require("coc.nvim");
init_main();
var TypeScriptFoldingProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideFoldingRanges(document, _context, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return;
    }
    const args = { file: file2 };
    const res = await this.client.execute("getOutliningSpans", args, token);
    if (res.type != "response") {
      return;
    }
    const { body } = res;
    if (!body) {
      return;
    }
    return body.map((span) => this.convertOutliningSpan(span, document)).filter((foldingRange) => !!foldingRange);
  }
  convertOutliningSpan(span, document) {
    const range = Range3.fromTextSpan(span.textSpan);
    const kind = TypeScriptFoldingProvider.getFoldingRangeKind(span);
    if (span.kind === "comment") {
      let doc = import_coc14.workspace.getDocument(document.uri);
      const line = doc.getline(range.start.line);
      if (line.match(/\/\/\s*#endregion/gi)) {
        return void 0;
      }
    }
    let { start, end } = range;
    return FoldingRange.create(start.line, end.line, start.character, end.character, kind);
  }
  static getFoldingRangeKind(span) {
    switch (span.kind) {
      case "comment":
      case "region":
      case "imports":
      case "code":
        return span.kind;
      default:
        return void 0;
    }
  }
};

// src/server/features/formatting.ts
var import_coc15 = require("coc.nvim");
var TypeScriptFormattingProvider = class {
  constructor(client, formattingOptionsManager) {
    this.client = client;
    this.formattingOptionsManager = formattingOptionsManager;
  }
  enabled(document) {
    return this.formattingOptionsManager.formatEnabled(document);
  }
  async doFormat(document, options, args, token) {
    if (!this.enabled(document))
      return [];
    await this.formattingOptionsManager.ensureConfigurationOptions(document, options.insertSpaces, options.tabSize, token);
    try {
      const response = await this.client.execute("format", args, token);
      if (response.type == "response" && response.body) {
        let edits = response.body.map(TextEdit2.fromCodeEdit);
        return edits;
      }
    } catch {
    }
    return [];
  }
  async provideDocumentRangeFormattingEdits(document, range, options, token) {
    if (!this.enabled(document))
      return [];
    const filepath = this.client.toPath(document.uri);
    if (!filepath)
      return [];
    const args = {
      file: filepath,
      line: range.start.line + 1,
      offset: range.start.character + 1,
      endLine: range.end.line + 1,
      endOffset: range.end.character + 1
    };
    return this.doFormat(document, options, args, token);
  }
  async provideDocumentFormattingEdits(document, options, token) {
    if (!this.enabled(document))
      return [];
    const filepath = this.client.toPath(document.uri);
    if (!filepath)
      return [];
    const args = {
      file: filepath,
      line: 1,
      offset: 1,
      endLine: document.lineCount + 1,
      endOffset: 1
    };
    return this.doFormat(document, options, args, token);
  }
  async provideOnTypeFormattingEdits(document, position, ch, options, token) {
    if (!this.enabled(document))
      return [];
    if (!this.client.configuration.formatOnType)
      return [];
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return [];
    await this.formattingOptionsManager.ensureConfigurationOptions(document, options.insertSpaces, options.tabSize, token);
    const doc = import_coc15.workspace.getDocument(document.uri);
    const args = __spreadProps(__spreadValues({}, Position2.toFileLocationRequestArgs(file2, position)), {
      key: ch
    });
    try {
      const res = await this.client.execute("formatonkey", args, token);
      if (res.type != "response") {
        return [];
      }
      const { body } = res;
      const edits = body;
      const result = [];
      if (!edits) {
        return result;
      }
      for (const edit of edits) {
        const textEdit = TextEdit2.fromCodeEdit(edit);
        const range = textEdit.range;
        if (range.start.character === 0 && range.start.line === range.end.line && textEdit.newText === "") {
          const lText = doc.getline(range.start.line);
          if (lText.trim().length > 0 || lText.length > range.end.character) {
            result.push(textEdit);
          }
        } else {
          result.push(textEdit);
        }
      }
      return result;
    } catch {
    }
    return [];
  }
};

// src/server/features/hover.ts
var TypeScriptHoverProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideHover(document, position, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position2.toFileLocationRequestArgs(filepath, position);
    try {
      const response = await this.client.interruptGetErr(() => this.client.execute("quickinfo", args, token));
      if (response && response.type == "response" && response.body) {
        const data = response.body;
        return {
          contents: TypeScriptHoverProvider.getContents(data),
          range: Range3.fromTextSpan(data)
        };
      }
    } catch (e) {
    }
    return void 0;
  }
  static getContents(data) {
    const parts = [];
    if (data.displayString) {
      parts.push({ language: "typescript", value: data.displayString });
    }
    const markup = markdownDocumentation(data.documentation, data.tags);
    parts.push({
      language: "markdown",
      value: markup.value
    });
    return parts;
  }
};

// src/server/features/implementationsCodeLens.ts
var TypeScriptImplementationsCodeLensProvider = class extends TypeScriptBaseCodeLensProvider {
  async resolveCodeLens(codeLens, token) {
    let { uri } = codeLens.data;
    let filepath = this.client.toPath(uri);
    const args = Position2.toFileLocationRequestArgs(filepath, codeLens.range.start);
    const response = await this.client.execute("implementation", args, token, { lowPriority: true });
    if (response.type !== "response" || !response.body) {
      codeLens.command = {
        title: response.type === "cancelled" ? "cancelled" : "could not determine implementation",
        command: ""
      };
      return codeLens;
    }
    const locations = response.body.map((reference) => {
      return {
        uri: this.client.toResource(reference.file),
        range: {
          start: Position2.fromLocation(reference.start),
          end: {
            line: reference.start.line,
            character: 0
          }
        }
      };
    }).filter((location) => !(location.uri.toString() === uri && location.range.start.line === codeLens.range.start.line && location.range.start.character === codeLens.range.start.character));
    codeLens.command = this.getCommand(locations, codeLens);
    return codeLens;
  }
  getCommand(locations, codeLens) {
    let { uri } = codeLens.data;
    return {
      title: this.getTitle(locations),
      command: locations.length ? "editor.action.showReferences" : "",
      arguments: [uri, codeLens.range.start, locations]
    };
  }
  getTitle(locations) {
    return locations.length === 1 ? "1 implementation" : `${locations.length} implementations`;
  }
  extractSymbol(document, item, _parent) {
    switch (item.kind) {
      case Kind.interface:
        return getSymbolRange(document, item);
      case Kind.class:
      case Kind.method:
      case Kind.memberVariable:
      case Kind.memberGetAccessor:
      case Kind.memberSetAccessor:
        if (item.kindModifiers.match(/\babstract\b/g)) {
          return getSymbolRange(document, item);
        }
        break;
    }
    return null;
  }
};

// src/server/features/importFix.ts
var import_coc16 = require("coc.nvim");
var import_vscode_languageserver_protocol12 = __toESM(require_main2());
var ImportFixProvider = class {
  constructor(bufferSyncSupport) {
    this.bufferSyncSupport = bufferSyncSupport;
  }
  async provideCodeActions(document, _range, context, _token) {
    if (this.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {
      return [];
    }
    let diagnostics = context.diagnostics.filter((d) => d.code == 2304);
    if (!diagnostics.length)
      return [];
    let edits = [];
    let names = [];
    let doc = import_coc16.workspace.getDocument(document.uri);
    let command;
    for (const diagnostic of diagnostics) {
      let { range } = diagnostic;
      let line = doc.getline(range.start.line);
      let name = line.slice(range.start.character, range.end.character);
      if (names.indexOf(name) !== -1)
        continue;
      if (nodeModules.indexOf(name) !== -1) {
        names.push(name);
        edits.push({
          range: import_vscode_languageserver_protocol12.Range.create(0, 0, 0, 0),
          newText: `import ${name} from '${name}'
`
        });
        command = "tsserver.organizeImports";
      }
    }
    let edit = {
      changes: {
        [document.uri]: edits
      }
    };
    let cmd = null;
    if (command)
      cmd = {
        title: `fix import`,
        command: "tsserver.organizeImports"
      };
    return [{
      title: `Add import ${names.join(", ")}`,
      edit,
      command: cmd
    }];
  }
};

// src/server/features/inlayHints.ts
var import_coc17 = require("coc.nvim");
var TypeScriptInlayHintsProvider = class {
  constructor(language2, client, fileConfigurationManager) {
    this.language = language2;
    this.client = client;
    this.fileConfigurationManager = fileConfigurationManager;
    this.disposables = [];
    this._onDidChangeInlayHints = new import_coc17.Emitter();
    this.onDidChangeInlayHints = this._onDidChangeInlayHints.event;
    let section = `${language2.id}.inlayHints`;
    import_coc17.workspace.onDidChangeConfiguration(async (e) => {
      if (e.affectsConfiguration(section)) {
        this._onDidChangeInlayHints.fire();
      }
    }, null, this.disposables);
    import_coc17.workspace.onDidChangeTextDocument((e) => {
      let doc = import_coc17.workspace.getDocument(e.textDocument.uri);
      if (language2.languageIds.includes(doc.languageId)) {
        this._onDidChangeInlayHints.fire();
      }
    }, null, this.disposables);
  }
  dispose() {
    this._onDidChangeInlayHints.dispose();
    (0, import_coc17.disposeAll)(this.disposables);
  }
  async provideInlayHints(document, range, token) {
    const filepath = this.client.toOpenedFilePath(document.uri);
    if (!filepath)
      return [];
    if (!areInlayHintsEnabledForFile(this.language, document)) {
      return [];
    }
    const start = document.offsetAt(range.start);
    const length = document.offsetAt(range.end) - start;
    await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
    const response = await this.client.execute("provideInlayHints", { file: filepath, start, length }, token);
    if (response.type !== "response" || !response.success || !response.body) {
      return [];
    }
    return response.body.map((hint) => {
      return {
        label: hint.text,
        position: Position2.fromLocation(hint.position),
        kind: fromProtocolInlayHintKind(hint.kind),
        paddingLeft: hint.whitespaceBefore,
        paddingRight: hint.whitespaceAfter
      };
    });
  }
};
TypeScriptInlayHintsProvider.minVersion = API.v440;
function fromProtocolInlayHintKind(kind) {
  switch (kind) {
    case "Parameter":
      return 2;
    case "Type":
      return 1;
    case "Enum":
      return void 0;
    default:
      return void 0;
  }
}
function areInlayHintsEnabledForFile(language2, document) {
  const config = import_coc17.workspace.getConfiguration(language2.id, document.uri);
  const preferences = getInlayHintsPreferences(config);
  return preferences.includeInlayParameterNameHints === "literals" || preferences.includeInlayParameterNameHints === "all" || preferences.includeInlayEnumMemberValueHints || preferences.includeInlayFunctionLikeReturnTypeHints || preferences.includeInlayFunctionParameterTypeHints || preferences.includeInlayPropertyDeclarationTypeHints || preferences.includeInlayVariableTypeHints;
}

// src/server/features/moduleInstall.ts
var import_coc18 = require("coc.nvim");
var import_vscode_languageserver_protocol13 = __toESM(require_main2());
var InstallModuleProvider = class {
  constructor(client) {
    this.client = client;
    import_coc18.commands.registerCommand("_tsserver.installModule", async (uri, name) => {
      await installModules(uri, [name]);
    });
  }
  async provideCodeActions(document, _range, context, _token) {
    const uri = import_coc18.Uri.parse(document.uri);
    if (uri.scheme != "file")
      return null;
    let { diagnostics } = context;
    let diags = diagnostics.filter((s) => s.code == 2307);
    let names = diags.map((o) => {
      let ms = o.message.match(/module\s'(.+)'/);
      return ms ? ms[1] : null;
    });
    names = names.filter((s) => s != null);
    if (!names.length)
      return null;
    let actions = [];
    for (let name of names) {
      let title = `install ${name}`;
      let command = {
        title: `install ${name}`,
        command: "_tsserver.installModule",
        arguments: [document.uri, name]
      };
      let codeAction = import_vscode_languageserver_protocol13.CodeAction.create(title, command, import_vscode_languageserver_protocol13.CodeActionKind.QuickFix);
      actions.push(codeAction);
    }
    return actions;
  }
};

// src/server/features/quickfix.ts
var import_coc19 = require("coc.nvim");
var import_vscode_languageserver_protocol14 = __toESM(require_main2());
var _ApplyCodeActionCommand = class {
  constructor(client, formattingConfigurationManager) {
    this.client = client;
    this.formattingConfigurationManager = formattingConfigurationManager;
    this.id = _ApplyCodeActionCommand.ID;
  }
  async execute(action) {
    return applyCodeActionCommands(this.client, action);
  }
};
var ApplyCodeActionCommand = _ApplyCodeActionCommand;
ApplyCodeActionCommand.ID = "_typescript.applyCodeActionCommand";
var _ApplyFixAllCodeAction = class {
  constructor(client, formattingConfigurationManager) {
    this.client = client;
    this.formattingConfigurationManager = formattingConfigurationManager;
    this.id = _ApplyFixAllCodeAction.ID;
  }
  async execute(document, file2, tsAction) {
    if (!tsAction.fixId) {
      return;
    }
    await this.formattingConfigurationManager.ensureConfigurationForDocument(document, import_vscode_languageserver_protocol14.CancellationToken.None);
    const args = {
      scope: {
        type: "file",
        args: { file: file2 }
      },
      fixId: tsAction.fixId
    };
    try {
      const res = await this.client.execute("getCombinedCodeFix", args, import_vscode_languageserver_protocol14.CancellationToken.None);
      if (res.type != "response") {
        return;
      }
      let { body } = res;
      const edit = WorkspaceEdit2.fromFileCodeEdits(this.client, body.changes);
      await import_coc19.workspace.applyEdit(edit);
      const token = import_vscode_languageserver_protocol14.CancellationToken.None;
      const { commands: commands7 } = body;
      if (commands7 && commands7.length) {
        for (const command of commands7) {
          await this.client.execute("applyCodeActionCommand", { command }, token);
        }
      }
    } catch {
    }
  }
};
var ApplyFixAllCodeAction = _ApplyFixAllCodeAction;
ApplyFixAllCodeAction.ID = "_typescript.applyFixAllCodeAction";
var DiagnosticsSet = class {
  constructor(_values) {
    this._values = _values;
  }
  static from(diagnostics) {
    const values = /* @__PURE__ */ new Map();
    for (const diagnostic of diagnostics) {
      values.set(DiagnosticsSet.key(diagnostic), diagnostic);
    }
    return new DiagnosticsSet(values);
  }
  static key(diagnostic) {
    const { start, end } = diagnostic.range;
    return `${diagnostic.code}-${start.line},${start.character}-${end.line},${end.character}`;
  }
  get values() {
    return this._values.values();
  }
};
var SupportedCodeActionProvider = class {
  constructor(client) {
    this.client = client;
  }
  async getFixableDiagnosticsForContext(context) {
    const supportedActions = await this.supportedCodeActions;
    const fixableDiagnostics = DiagnosticsSet.from(context.diagnostics.filter((diagnostic) => supportedActions.has(+diagnostic.code)));
    return Array.from(fixableDiagnostics.values);
  }
  get supportedCodeActions() {
    if (!this._supportedCodeActions) {
      return new Promise((resolve, reject) => {
        this.client.execute("getSupportedCodeFixes", null, import_vscode_languageserver_protocol14.CancellationToken.None).then((res) => {
          if (res.type !== "response") {
            resolve(/* @__PURE__ */ new Set());
            return;
          }
          let codes = res.body.map((code) => +code).filter((code) => !isNaN(code));
          resolve(new Set(codes));
        }, reject);
      });
    }
    return Promise.resolve(this._supportedCodeActions);
  }
};
var TypeScriptQuickFixProvider = class {
  constructor(client, formattingConfigurationManager) {
    this.client = client;
    this.formattingConfigurationManager = formattingConfigurationManager;
    registCommand(new ApplyCodeActionCommand(client, formattingConfigurationManager));
    registCommand(new ApplyFixAllCodeAction(client, formattingConfigurationManager));
    this.supportedCodeActionProvider = new SupportedCodeActionProvider(client);
  }
  async provideCodeActions(document, _range, context, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return [];
    }
    await this.formattingConfigurationManager.ensureConfigurationForDocument(document, token);
    const fixableDiagnostics = await this.supportedCodeActionProvider.getFixableDiagnosticsForContext(context);
    if (!fixableDiagnostics.length) {
      return [];
    }
    if (this.client.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {
      return [];
    }
    const results = [];
    for (const diagnostic of fixableDiagnostics) {
      results.push(...await this.getFixesForDiagnostic(document, file2, diagnostic, token));
    }
    return results;
  }
  async getFixesForDiagnostic(document, file2, diagnostic, token) {
    const args = __spreadProps(__spreadValues({}, Range3.toFileRangeRequestArgs(file2, diagnostic.range)), {
      errorCodes: [+diagnostic.code]
    });
    const codeFixesResponse = await this.client.execute("getCodeFixes", args, token);
    if (codeFixesResponse.type != "response") {
      return [];
    }
    if (codeFixesResponse.body) {
      const results = [];
      for (const tsCodeFix of codeFixesResponse.body) {
        results.push(...await this.getAllFixesForTsCodeAction(document, file2, diagnostic, tsCodeFix));
      }
      return results;
    }
    return [];
  }
  async getAllFixesForTsCodeAction(document, file2, diagnostic, tsAction) {
    const singleFix = this.getSingleFixForTsCodeAction(diagnostic, tsAction);
    const fixAll = await this.getFixAllForTsCodeAction(document, file2, diagnostic, tsAction);
    return fixAll ? [singleFix, fixAll] : [singleFix];
  }
  getSingleFixForTsCodeAction(diagnostic, tsAction) {
    const codeAction = {
      title: tsAction.description,
      kind: import_vscode_languageserver_protocol14.CodeActionKind.QuickFix
    };
    codeAction.edit = getEditForCodeAction(this.client, tsAction);
    codeAction.diagnostics = [diagnostic];
    codeAction.isPreferred = true;
    if (tsAction.commands) {
      codeAction.command = {
        command: ApplyCodeActionCommand.ID,
        arguments: [tsAction],
        title: tsAction.description
      };
    }
    return codeAction;
  }
  async getFixAllForTsCodeAction(document, file2, diagnostic, tsAction) {
    if (!tsAction.fixId || !this.client.apiVersion.gte(API.v270)) {
      return void 0;
    }
    if (!this.client.diagnosticsManager.getDiagnostics(document.uri).some((x) => x.code === diagnostic.code && x !== diagnostic)) {
      return;
    }
    const action = {
      title: tsAction.fixAllDescription || "Fix all in file",
      kind: import_vscode_languageserver_protocol14.CodeActionKind.QuickFix
    };
    action.diagnostics = [diagnostic];
    action.command = {
      command: ApplyFixAllCodeAction.ID,
      arguments: [document, file2, tsAction],
      title: ""
    };
    return action;
  }
};

// src/server/features/refactor.ts
var import_coc20 = require("coc.nvim");
var import_vscode_languageserver_protocol15 = __toESM(require_main2());
var _ApplyRefactoringCommand = class {
  constructor(client) {
    this.client = client;
    this.id = _ApplyRefactoringCommand.ID;
  }
  async execute(document, file2, refactor, action, range) {
    const args = __spreadProps(__spreadValues({}, Range3.toFileRangeRequestArgs(file2, range)), {
      refactor,
      action
    });
    const response = await this.client.execute("getEditsForRefactor", args, import_vscode_languageserver_protocol15.CancellationToken.None);
    const body = response && response.body;
    if (!body || !body.edits.length) {
      return false;
    }
    const workspaceEdit = await this.toWorkspaceEdit(body);
    if (!await import_coc20.workspace.applyEdit(workspaceEdit)) {
      return false;
    }
    const renameLocation = body.renameLocation;
    if (renameLocation) {
      import_coc20.commands.executeCommand("editor.action.rename", document.uri, Position2.fromLocation(renameLocation));
    }
    return true;
  }
  async toWorkspaceEdit(body) {
    let workspaceEdit = WorkspaceEdit2.fromFileCodeEdits(this.client, body.edits);
    let documentChanges = workspaceEdit.documentChanges = workspaceEdit.documentChanges || [];
    for (const edit of body.edits) {
      let resource = this.client.toResource(edit.fileName);
      if (import_coc20.Uri.parse(resource).scheme === "file") {
        documentChanges.unshift({
          kind: "create",
          uri: resource,
          options: { ignoreIfExists: true }
        });
      }
    }
    return workspaceEdit;
  }
};
var ApplyRefactoringCommand = _ApplyRefactoringCommand;
ApplyRefactoringCommand.ID = "_typescript.applyRefactoring";
var _SelectRefactorCommand = class {
  constructor(doRefactoring) {
    this.doRefactoring = doRefactoring;
    this.id = _SelectRefactorCommand.ID;
  }
  async execute(document, file2, info, range) {
    let { actions } = info;
    const idx = actions.length == 1 ? 0 : await import_coc20.window.showQuickpick(actions.map((action) => action.description || action.name));
    if (idx == -1)
      return false;
    let label = info.actions[idx].name;
    if (!label)
      return false;
    return this.doRefactoring.execute(document, file2, info.name, label, range);
  }
};
var SelectRefactorCommand = _SelectRefactorCommand;
SelectRefactorCommand.ID = "_typescript.selectRefactoring";
var _TypeScriptRefactorProvider = class {
  constructor(client, formattingOptionsManager) {
    this.client = client;
    this.formattingOptionsManager = formattingOptionsManager;
    const doRefactoringCommand = new ApplyRefactoringCommand(this.client);
    registCommand(doRefactoringCommand);
    registCommand(new SelectRefactorCommand(doRefactoringCommand));
  }
  async provideCodeActions(document, range, context, token) {
    if (!this.shouldTrigger(context)) {
      return void 0;
    }
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return void 0;
    await this.formattingOptionsManager.ensureConfigurationForDocument(document, token);
    const args = Range3.toFileRangeRequestArgs(file2, range);
    let response;
    try {
      response = await this.client.interruptGetErr(() => {
        return this.client.execute("getApplicableRefactors", args, token);
      });
      if (!response || !response.body) {
        return void 0;
      }
    } catch {
      return void 0;
    }
    return this.convertApplicableRefactors(response.body, document, file2, range, context.only && context.only.some((v) => v.includes(import_vscode_languageserver_protocol15.CodeActionKind.Refactor)));
  }
  convertApplicableRefactors(body, document, file2, rangeOrSelection, setPrefrred) {
    const actions = [];
    for (const info of body) {
      if (info.notApplicableReason)
        continue;
      if (!info.inlineable) {
        const codeAction = {
          title: info.description,
          kind: import_vscode_languageserver_protocol15.CodeActionKind.Refactor
        };
        codeAction.command = {
          title: info.description,
          command: SelectRefactorCommand.ID,
          arguments: [document, file2, info, rangeOrSelection]
        };
        actions.push(codeAction);
      } else {
        for (const action of info.actions) {
          let codeAction = this.refactorActionToCodeAction(action, document, file2, info, rangeOrSelection);
          if (setPrefrred) {
            codeAction.isPreferred = _TypeScriptRefactorProvider.isPreferred(action, info.actions);
          }
          actions.push(codeAction);
        }
      }
    }
    return actions;
  }
  refactorActionToCodeAction(action, document, file2, info, rangeOrSelection) {
    const codeAction = {
      title: action.description,
      kind: _TypeScriptRefactorProvider.getKind(action)
    };
    codeAction.command = {
      title: action.description,
      command: ApplyRefactoringCommand.ID,
      arguments: [document, file2, info.name, action.name, rangeOrSelection]
    };
    return codeAction;
  }
  shouldTrigger(context) {
    if (context.only && context.only.every((o) => !o.includes(import_vscode_languageserver_protocol15.CodeActionKind.Refactor))) {
      return false;
    }
    return true;
  }
  static getKind(refactor) {
    if (refactor.name.startsWith("function_")) {
      return _TypeScriptRefactorProvider.extractFunctionKind;
    } else if (refactor.name.startsWith("constant_")) {
      return _TypeScriptRefactorProvider.extractConstantKind;
    } else if (refactor.name.startsWith("Move")) {
      return _TypeScriptRefactorProvider.moveKind;
    }
    return import_vscode_languageserver_protocol15.CodeActionKind.Refactor;
  }
  static isPreferred(action, allActions) {
    let kind = _TypeScriptRefactorProvider.getKind(action);
    if (_TypeScriptRefactorProvider.extractConstantKind == kind) {
      const getScope = (name2) => {
        var _a;
        const scope2 = (_a = name2.match(/scope_(\d)/)) == null ? void 0 : _a[1];
        return scope2 ? +scope2 : void 0;
      };
      const scope = getScope(action.name);
      if (typeof scope !== "number") {
        return false;
      }
      return allActions.filter((otherAtion) => otherAtion !== action && otherAtion.name.startsWith("constant_")).every((otherAction) => {
        const otherScope = getScope(otherAction.name);
        return typeof otherScope === "number" ? scope < otherScope : true;
      });
    }
    let { name } = action;
    if (name.startsWith("Extract to type alias") || name.startsWith("Extract to interface")) {
      return true;
    }
    return false;
  }
};
var TypeScriptRefactorProvider = _TypeScriptRefactorProvider;
TypeScriptRefactorProvider.extractFunctionKind = import_vscode_languageserver_protocol15.CodeActionKind.RefactorExtract + ".function";
TypeScriptRefactorProvider.extractConstantKind = import_vscode_languageserver_protocol15.CodeActionKind.RefactorExtract + ".constant";
TypeScriptRefactorProvider.moveKind = import_vscode_languageserver_protocol15.CodeActionKind.Refactor + ".move";
TypeScriptRefactorProvider.metadata = {
  providedCodeActionKinds: [import_vscode_languageserver_protocol15.CodeActionKind.Refactor]
};

// src/server/features/references.ts
var TypeScriptReferences = class {
  constructor(client) {
    this.client = client;
  }
  async provideReferences(document, position, context, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath)
      return [];
    const args = Position2.toFileLocationRequestArgs(filepath, position);
    try {
      const msg = await this.client.execute("references", args, token);
      if (!msg || msg.type != "response" || !msg.body) {
        return [];
      }
      const result = [];
      for (const ref of msg.body.refs) {
        if (!context.includeDeclaration && ref.isDefinition) {
          continue;
        }
        const url = this.client.toResource(ref.file);
        const location = Location2.fromTextSpan(url, ref);
        result.push(location);
      }
      return result;
    } catch {
      return [];
    }
  }
};

// src/server/features/referencesCodeLens.ts
var import_coc21 = require("coc.nvim");

// src/server/typescriptService.ts
var ServerResponse;
((ServerResponse2) => {
  class Cancelled {
    constructor(reason) {
      this.reason = reason;
      this.type = "cancelled";
    }
  }
  ServerResponse2.Cancelled = Cancelled;
  ServerResponse2.NoContent = new class {
    constructor() {
      this.type = "noContent";
    }
  }();
})(ServerResponse || (ServerResponse = {}));

// src/server/features/referencesCodeLens.ts
var TypeScriptReferencesCodeLensProvider = class extends TypeScriptBaseCodeLensProvider {
  async resolveCodeLens(codeLens, token) {
    let { uri } = codeLens.data;
    let filepath = this.client.toPath(uri);
    const args = Position2.toFileLocationRequestArgs(filepath, codeLens.range.start);
    let response = await this.client.execute("references", args, token, {
      lowPriority: true,
      executionTarget: 0 /* Semantic */
    });
    if (!response || response.type != "response" || !response.body) {
      codeLens.command = {
        title: response.type === "cancelled" ? "cancelled" : "could not determine references",
        command: ""
      };
      return codeLens;
    }
    const locations = response.body.refs.filter((reference) => !reference.isDefinition).map((reference) => Location2.fromTextSpan(this.client.toResource(reference.file), reference));
    codeLens.command = {
      title: locations.length === 1 ? "1 reference" : `${locations.length} references`,
      command: locations.length ? "editor.action.showReferences" : "",
      arguments: [uri, codeLens.range.start, locations]
    };
    return codeLens;
  }
  extractSymbol(document, item, parent) {
    if (parent && parent.kind === Kind.enum) {
      return getSymbolRange(document, item);
    }
    switch (item.kind) {
      case Kind.function: {
        const showOnAllFunctions = import_coc21.workspace.getConfiguration(this.modeId).get("referencesCodeLens.showOnAllFunctions");
        if (showOnAllFunctions) {
          return getSymbolRange(document, item);
        }
      }
      case Kind.const:
      case Kind.let:
      case Kind.variable:
        if (/\bexport\b/.test(item.kindModifiers)) {
          return getSymbolRange(document, item);
        }
        break;
      case Kind.class:
        if (item.text === "<class>") {
          break;
        }
        return getSymbolRange(document, item);
      case Kind.interface:
      case Kind.type:
      case Kind.enum:
        return getSymbolRange(document, item);
      case Kind.method:
      case Kind.memberGetAccessor:
      case Kind.memberSetAccessor:
      case Kind.constructorImplementation:
      case Kind.memberVariable:
        if (parent && comparePosition(Position2.fromLocation(parent.spans[0].start), Position2.fromLocation(item.spans[0].start)) == 0) {
          return null;
        }
        switch (parent == null ? void 0 : parent.kind) {
          case Kind.class:
          case Kind.interface:
          case Kind.type:
            return getSymbolRange(document, item);
        }
        break;
    }
    return null;
  }
};
function comparePosition(position, other) {
  if (position.line > other.line)
    return 1;
  if (other.line == position.line && position.character > other.character)
    return 1;
  if (other.line == position.line && position.character == other.character)
    return 0;
  return -1;
}

// src/server/features/rename.ts
var import_coc22 = require("coc.nvim");
var import_path4 = __toESM(require("path"));
var TypeScriptRenameProvider = class {
  constructor(client, fileConfigurationManager) {
    this.client = client;
    this.fileConfigurationManager = fileConfigurationManager;
  }
  async prepareRename(document, position, token) {
    const response = await this.execRename(document, position, token);
    if (!response || response.type !== "response" || !response.body) {
      return null;
    }
    const renameInfo = response.body.info;
    if (!renameInfo.canRename) {
      return Promise.reject(new Error("Invalid location for rename."));
    }
    if (this.client.apiVersion.gte(API.v310)) {
      const triggerSpan = renameInfo.triggerSpan;
      if (triggerSpan) {
        const range = Range3.fromTextSpan(triggerSpan);
        return range;
      }
    }
    return null;
  }
  async provideRenameEdits(document, position, newName, token) {
    const response = await this.execRename(document, position, token);
    if (!response || response.type !== "response" || !response.body) {
      return null;
    }
    const renameInfo = response.body.info;
    if (!renameInfo.canRename) {
      return Promise.reject(new Error("Invalid location for rename."));
    }
    if (this.client.apiVersion.gte(API.v310)) {
      if (renameInfo.fileToRename) {
        const edits = await this.renameFile(renameInfo.fileToRename, newName, token);
        if (edits) {
          return edits;
        } else {
          return Promise.reject(new Error("An error occurred while renaming file"));
        }
      }
    }
    return this.toWorkspaceEdit(response.body.locs, newName);
  }
  async execRename(document, position, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return void 0;
    const args = __spreadProps(__spreadValues({}, Position2.toFileLocationRequestArgs(file2, position)), {
      findInStrings: false,
      findInComments: false
    });
    await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
    return this.client.interruptGetErr(() => {
      return this.client.execute("rename", args, token);
    });
  }
  toWorkspaceEdit(locations, newName) {
    let changes = {};
    for (const spanGroup of locations) {
      const uri = this.client.toResource(spanGroup.file);
      if (uri) {
        changes[uri] = [];
        for (const textSpan of spanGroup.locs) {
          changes[uri].push({
            range: Range3.fromTextSpan(textSpan),
            newText: (textSpan.prefixText || "") + newName + (textSpan.suffixText || "")
          });
        }
      }
    }
    return { changes };
  }
  async renameFile(fileToRename, newName, token) {
    if (!import_path4.default.extname(newName)) {
      newName += import_path4.default.extname(fileToRename);
    }
    const dirname = import_path4.default.dirname(fileToRename);
    const newFilePath = import_path4.default.join(dirname, newName);
    const args = {
      file: fileToRename,
      oldFilePath: fileToRename,
      newFilePath
    };
    const response = await this.client.execute("getEditsForFileRename", args, token);
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    const edits = WorkspaceEdit2.fromFileCodeEdits(this.client, response.body);
    edits.documentChanges = edits.documentChanges || [];
    edits.documentChanges.push({
      kind: "rename",
      oldUri: import_coc22.Uri.file(fileToRename).toString(),
      newUri: import_coc22.Uri.file(newFilePath).toString(),
      options: {
        overwrite: false,
        ignoreIfExists: true
      }
    });
    return edits;
  }
};

// src/server/features/semanticTokens.ts
var import_coc23 = require("coc.nvim");
var CONTENT_LENGTH_LIMIT = 1e5;
var TypeScriptDocumentSemanticTokensProvider = class {
  constructor(client) {
    this.client = client;
  }
  getLegend() {
    return {
      tokenTypes,
      tokenModifiers
    };
  }
  logIgnored(uri) {
    this.client.logger.warn(`${uri} content length exceed limit 100000`);
  }
  async provideDocumentSemanticTokens(document, token) {
    const file2 = this.client.toOpenedFilePath(document.uri);
    if (!file2 || document.getText().length > CONTENT_LENGTH_LIMIT) {
      this.logIgnored(document.uri);
      return null;
    }
    return this._provideSemanticTokens(document, { file: file2, start: 0, length: document.getText().length }, token);
  }
  async provideDocumentRangeSemanticTokens(document, range, token) {
    const file2 = this.client.toOpenedFilePath(document.uri);
    if (!file2 || document.offsetAt(range.end) - document.offsetAt(range.start) > CONTENT_LENGTH_LIMIT) {
      this.logIgnored(document.uri);
      return null;
    }
    const start = document.offsetAt(range.start);
    const length = document.offsetAt(range.end) - start;
    return this._provideSemanticTokens(document, { file: file2, start, length }, token);
  }
  async _provideSemanticTokens(document, requestArg, token) {
    const file2 = this.client.toOpenedFilePath(document.uri);
    if (!file2) {
      return null;
    }
    const versionBeforeRequest = document.version;
    requestArg.format = "2020";
    const response = await this.client.execute("encodedSemanticClassifications-full", requestArg, token, {
      cancelOnResourceChange: document.uri
    });
    if (response.type !== "response" || !response.body) {
      return null;
    }
    const versionAfterRequest = document.version;
    if (versionBeforeRequest !== versionAfterRequest) {
      await waitForDocumentChangesToEnd(document);
      throw new Error("Canceled");
    }
    const doc = import_coc23.workspace.getDocument(document.uri);
    const tokenSpan = response.body.spans;
    const builder = new import_coc23.SemanticTokensBuilder();
    let i = 0;
    while (i < tokenSpan.length) {
      const offset = tokenSpan[i++];
      const length = tokenSpan[i++];
      const tsClassification = tokenSpan[i++];
      let tokenModifiers2 = 0;
      let tokenType = getTokenTypeFromClassification(tsClassification);
      if (tokenType !== void 0) {
        tokenModifiers2 = getTokenModifierFromClassification(tsClassification);
      } else {
        tokenType = tokenTypeMap[tsClassification];
        if (tokenType === void 0) {
          continue;
        }
      }
      const startPos = document.positionAt(offset);
      const endPos = document.positionAt(offset + length);
      for (let line = startPos.line; line <= endPos.line; line++) {
        const startCharacter = line === startPos.line ? startPos.character : 0;
        const endCharacter = line === endPos.line ? endPos.character : doc.getline(line).length;
        builder.push(line, startCharacter, endCharacter - startCharacter, tokenType, tokenModifiers2);
      }
    }
    return builder.build();
  }
};
TypeScriptDocumentSemanticTokensProvider.minVersion = API.v370;
function waitForDocumentChangesToEnd(document) {
  let version = document.version;
  return new Promise((s) => {
    const iv = setInterval((_) => {
      if (document.version === version) {
        clearInterval(iv);
        s();
      }
      version = document.version;
    }, 400);
  });
}
function getTokenTypeFromClassification(tsClassification) {
  if (tsClassification > TokenEncodingConsts.modifierMask) {
    return (tsClassification >> TokenEncodingConsts.typeOffset) - 1;
  }
  return void 0;
}
function getTokenModifierFromClassification(tsClassification) {
  return tsClassification & TokenEncodingConsts.modifierMask;
}
var TokenEncodingConsts = /* @__PURE__ */ ((TokenEncodingConsts2) => {
  TokenEncodingConsts2[TokenEncodingConsts2["typeOffset"] = 8] = "typeOffset";
  TokenEncodingConsts2[TokenEncodingConsts2["modifierMask"] = 255] = "modifierMask";
  return TokenEncodingConsts2;
})(TokenEncodingConsts || {});
var tokenTypes = [];
tokenTypes[0 /* class */] = "class";
tokenTypes[1 /* enum */] = "enum";
tokenTypes[2 /* interface */] = "interface";
tokenTypes[3 /* namespace */] = "namespace";
tokenTypes[4 /* typeParameter */] = "typeParameter";
tokenTypes[5 /* type */] = "type";
tokenTypes[6 /* parameter */] = "parameter";
tokenTypes[7 /* variable */] = "variable";
tokenTypes[8 /* enumMember */] = "enumMember";
tokenTypes[9 /* property */] = "property";
tokenTypes[10 /* function */] = "function";
tokenTypes[11 /* method */] = "method";
var tokenModifiers = [];
tokenModifiers[2 /* async */] = "async";
tokenModifiers[0 /* declaration */] = "declaration";
tokenModifiers[3 /* readonly */] = "readonly";
tokenModifiers[1 /* static */] = "static";
tokenModifiers[5 /* local */] = "local";
tokenModifiers[4 /* defaultLibrary */] = "defaultLibrary";
var ExperimentalProtocol;
((ExperimentalProtocol2) => {
  let EndOfLineState;
  ((EndOfLineState2) => {
    EndOfLineState2[EndOfLineState2["None"] = 0] = "None";
    EndOfLineState2[EndOfLineState2["InMultiLineCommentTrivia"] = 1] = "InMultiLineCommentTrivia";
    EndOfLineState2[EndOfLineState2["InSingleQuoteStringLiteral"] = 2] = "InSingleQuoteStringLiteral";
    EndOfLineState2[EndOfLineState2["InDoubleQuoteStringLiteral"] = 3] = "InDoubleQuoteStringLiteral";
    EndOfLineState2[EndOfLineState2["InTemplateHeadOrNoSubstitutionTemplate"] = 4] = "InTemplateHeadOrNoSubstitutionTemplate";
    EndOfLineState2[EndOfLineState2["InTemplateMiddleOrTail"] = 5] = "InTemplateMiddleOrTail";
    EndOfLineState2[EndOfLineState2["InTemplateSubstitutionPosition"] = 6] = "InTemplateSubstitutionPosition";
  })(EndOfLineState = ExperimentalProtocol2.EndOfLineState || (ExperimentalProtocol2.EndOfLineState = {}));
  let ClassificationType;
  ((ClassificationType2) => {
    ClassificationType2[ClassificationType2["comment"] = 1] = "comment";
    ClassificationType2[ClassificationType2["identifier"] = 2] = "identifier";
    ClassificationType2[ClassificationType2["keyword"] = 3] = "keyword";
    ClassificationType2[ClassificationType2["numericLiteral"] = 4] = "numericLiteral";
    ClassificationType2[ClassificationType2["operator"] = 5] = "operator";
    ClassificationType2[ClassificationType2["stringLiteral"] = 6] = "stringLiteral";
    ClassificationType2[ClassificationType2["regularExpressionLiteral"] = 7] = "regularExpressionLiteral";
    ClassificationType2[ClassificationType2["whiteSpace"] = 8] = "whiteSpace";
    ClassificationType2[ClassificationType2["text"] = 9] = "text";
    ClassificationType2[ClassificationType2["punctuation"] = 10] = "punctuation";
    ClassificationType2[ClassificationType2["className"] = 11] = "className";
    ClassificationType2[ClassificationType2["enumName"] = 12] = "enumName";
    ClassificationType2[ClassificationType2["interfaceName"] = 13] = "interfaceName";
    ClassificationType2[ClassificationType2["moduleName"] = 14] = "moduleName";
    ClassificationType2[ClassificationType2["typeParameterName"] = 15] = "typeParameterName";
    ClassificationType2[ClassificationType2["typeAliasName"] = 16] = "typeAliasName";
    ClassificationType2[ClassificationType2["parameterName"] = 17] = "parameterName";
    ClassificationType2[ClassificationType2["docCommentTagName"] = 18] = "docCommentTagName";
    ClassificationType2[ClassificationType2["jsxOpenTagName"] = 19] = "jsxOpenTagName";
    ClassificationType2[ClassificationType2["jsxCloseTagName"] = 20] = "jsxCloseTagName";
    ClassificationType2[ClassificationType2["jsxSelfClosingTagName"] = 21] = "jsxSelfClosingTagName";
    ClassificationType2[ClassificationType2["jsxAttribute"] = 22] = "jsxAttribute";
    ClassificationType2[ClassificationType2["jsxText"] = 23] = "jsxText";
    ClassificationType2[ClassificationType2["jsxAttributeStringLiteralValue"] = 24] = "jsxAttributeStringLiteralValue";
    ClassificationType2[ClassificationType2["bigintLiteral"] = 25] = "bigintLiteral";
  })(ClassificationType = ExperimentalProtocol2.ClassificationType || (ExperimentalProtocol2.ClassificationType = {}));
})(ExperimentalProtocol || (ExperimentalProtocol = {}));
var tokenTypeMap = [];
tokenTypeMap[11 /* className */] = 0 /* class */;
tokenTypeMap[12 /* enumName */] = 1 /* enum */;
tokenTypeMap[13 /* interfaceName */] = 2 /* interface */;
tokenTypeMap[14 /* moduleName */] = 3 /* namespace */;
tokenTypeMap[15 /* typeParameterName */] = 4 /* typeParameter */;
tokenTypeMap[16 /* typeAliasName */] = 5 /* type */;
tokenTypeMap[17 /* parameterName */] = 6 /* parameter */;

// src/server/features/signatureHelp.ts
var TypeScriptSignatureHelpProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideSignatureHelp(document, position, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position2.toFileLocationRequestArgs(filepath, position);
    let response;
    try {
      response = await this.client.interruptGetErr(() => this.client.execute("signatureHelp", args, token));
    } catch (e) {
      return void 0;
    }
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    let info = response.body;
    const result = {
      activeSignature: info.selectedItemIndex,
      activeParameter: this.getActiveParmeter(info),
      signatures: info.items.map((signature) => {
        return this.convertSignature(signature);
      })
    };
    return result;
  }
  getActiveParmeter(info) {
    const activeSignature = info.items[info.selectedItemIndex];
    if (activeSignature && activeSignature.isVariadic) {
      return Math.min(info.argumentIndex, activeSignature.parameters.length - 1);
    }
    return info.argumentIndex;
  }
  convertSignature(item) {
    var _a;
    let parameters = item.parameters.map((p) => {
      return {
        label: plainWithLinks(p.displayParts),
        documentation: markdownDocumentation(p.documentation, [])
      };
    });
    let label = plainWithLinks(item.prefixDisplayParts);
    label += parameters.map((parameter) => parameter.label).join(plainWithLinks(item.separatorDisplayParts));
    label += plainWithLinks(item.suffixDisplayParts);
    return {
      label,
      documentation: markdownDocumentation(item.documentation, (_a = item.tags) == null ? void 0 : _a.filter((x) => x.name !== "param")),
      parameters
    };
  }
};
TypeScriptSignatureHelpProvider.triggerCharacters = ["(", ",", "<"];

// src/server/features/smartSelect.ts
var SmartSelection = class {
  constructor(client) {
    this.client = client;
  }
  async provideSelectionRanges(document, positions, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return void 0;
    }
    const args = {
      file: file2,
      locations: positions.map(Position2.toLocation)
    };
    const response = await this.client.execute("selectionRange", args, token);
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    return response.body.map(SmartSelection.convertSelectionRange);
  }
  static convertSelectionRange(selectionRange) {
    return {
      range: Range3.fromTextSpan(selectionRange.textSpan),
      parent: selectionRange.parent ? SmartSelection.convertSelectionRange(selectionRange.parent) : void 0
    };
  }
};

// src/server/features/tagClosing.ts
var import_coc24 = require("coc.nvim");
var _TagClosing = class {
  constructor(client, descriptionLanguageId) {
    this.client = client;
    this.descriptionLanguageId = descriptionLanguageId;
    this._disposables = [];
    this._disposed = false;
    this._timeout = void 0;
    this._cancel = void 0;
    import_coc24.events.on("TextInsert", this.onInsertChange, this, this._disposables);
  }
  async onInsertChange(bufnr, change, lastInsert) {
    let doc = import_coc24.workspace.getDocument(bufnr);
    if (!doc || !doc.attached)
      return;
    let enabled = this.isEnabled(doc.filetype, doc.uri);
    if (!enabled)
      return;
    let { pre, changedtick, lnum } = change;
    if (lastInsert !== "/" && lastInsert != ">")
      return;
    if (pre.length > 1 && pre[pre.length - 2] == ">")
      return;
    const filepath = this.client.toOpenedFilePath(doc.uri);
    if (!filepath)
      return;
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._cancel) {
      this._cancel.cancel();
      this._cancel.dispose();
      this._cancel = void 0;
    }
    await doc.patchChange();
    this._timeout = setTimeout(async () => {
      this._timeout = void 0;
      if (this._disposed)
        return;
      if (doc.changedtick > changedtick)
        return;
      const position = import_coc24.Position.create(lnum - 1, pre.length);
      const args = Position2.toFileLocationRequestArgs(filepath, position);
      this._cancel = new import_coc24.CancellationTokenSource();
      const response = await this.client.execute("jsxClosingTag", args, this._cancel.token);
      if (response.type !== "response" || !response.body) {
        return;
      }
      if (this._disposed)
        return;
      const insertion = response.body;
      if (doc.changedtick === changedtick) {
        import_coc24.snippetManager.insertSnippet(this.getTagSnippet(insertion).value, false, import_coc24.Range.create(position, position));
      }
    }, 30);
  }
  isEnabled(languageId, uri) {
    const configLang = _TagClosing._configurationLanguages[languageId];
    if (!configLang || configLang !== this.descriptionLanguageId) {
      return false;
    }
    if (!import_coc24.workspace.getConfiguration(void 0, uri).get(`${configLang}.autoClosingTags`)) {
      return false;
    }
    return true;
  }
  dispose() {
    this._disposed = true;
    if (this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = void 0;
    }
    if (this._cancel) {
      this._cancel.cancel();
      this._cancel.dispose();
      this._cancel = void 0;
    }
    (0, import_coc24.disposeAll)(this._disposables);
    this._disposables = [];
  }
  getTagSnippet(closingTag) {
    const snippet = new SnippetString();
    snippet.appendPlaceholder("", 0);
    snippet.appendText(closingTag.newText);
    return snippet;
  }
};
var TagClosing = _TagClosing;
TagClosing._configurationLanguages = {
  "javascriptreact": "javascript",
  "typescriptreact": "typescript"
};

// src/server/features/updatePathOnRename.ts
var import_coc25 = require("coc.nvim");
var import_vscode_languageserver_protocol16 = __toESM(require_main2());

// src/server/utils/mutex.ts
var Mutex = class {
  constructor() {
    this.tasks = [];
    this.count = 1;
  }
  sched() {
    if (this.count > 0 && this.tasks.length > 0) {
      this.count--;
      let next = this.tasks.shift();
      next();
    }
  }
  get busy() {
    return this.count == 0;
  }
  acquire() {
    return new Promise((res) => {
      let task = () => {
        let released = false;
        res(() => {
          if (!released) {
            released = true;
            this.count++;
            this.sched();
          }
        });
      };
      this.tasks.push(task);
      process.nextTick(this.sched.bind(this));
    });
  }
  use(f) {
    return this.acquire().then((release) => {
      return f().then((res) => {
        release();
        return res;
      }).catch((err) => {
        release();
        throw err;
      });
    });
  }
};

// src/server/features/updatePathOnRename.ts
function wait(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
}
var UpdateImportsOnFileRenameHandler = class {
  constructor(client, fileConfigurationManager, languageId) {
    this.client = client;
    this.fileConfigurationManager = fileConfigurationManager;
    this.disposables = [];
    let glob = languageId == "typescript" ? "**/*.{ts,tsx}" : "**/*.{js,jsx}";
    const watcher = import_coc25.workspace.createFileSystemWatcher(glob);
    this.disposables.push(watcher);
    let mutex = new Mutex();
    watcher.onDidRename(async (e) => {
      let release = await mutex.acquire();
      try {
        await this.doRename(e.oldUri, e.newUri);
        release();
      } catch (e2) {
        this.client.logger.error("Error on rename:", e2);
        release();
      }
    }, null, this.disposables);
  }
  dispose() {
    (0, import_coc25.disposeAll)(this.disposables);
  }
  async doRename(oldResource, newResource) {
    if (oldResource.scheme !== "file" || newResource.scheme !== "file") {
      return;
    }
    const targetFile = newResource.fsPath;
    const oldFile = oldResource.fsPath;
    const newUri = newResource.toString();
    let oldDocument = import_coc25.workspace.getDocument(oldResource.toString());
    if (oldDocument) {
      await import_coc25.workspace.nvim.command(`silent ${oldDocument.bufnr}bwipeout!`);
    }
    let document = import_coc25.workspace.getDocument(newUri);
    if (document) {
      await import_coc25.workspace.nvim.command(`silent ${document.bufnr}bwipeout!`);
      await wait(30);
    }
    document = await import_coc25.workspace.loadFile(newUri);
    if (!document)
      return;
    await wait(50);
    const edits = await this.getEditsForFileRename(document.textDocument, oldFile, targetFile);
    if (!edits)
      return;
    if (await this.promptUser(newResource)) {
      await import_coc25.workspace.applyEdit(edits);
    }
  }
  async promptUser(newResource) {
    return await import_coc25.window.showPrompt(`Update imports for moved file: ${newResource.fsPath}?`);
  }
  async getEditsForFileRename(document, oldFile, newFile) {
    await this.fileConfigurationManager.ensureConfigurationForDocument(document, import_vscode_languageserver_protocol16.CancellationToken.None);
    const response = await this.client.interruptGetErr(() => {
      const args = {
        oldFilePath: oldFile,
        newFilePath: newFile
      };
      return this.client.execute("getEditsForFileRename", args, import_vscode_languageserver_protocol16.CancellationToken.None);
    });
    if (!response || response.type != "response" || !response.body) {
      return;
    }
    const edits = [];
    for (const edit of response.body) {
      if (edit.fileName.match(/[\/\\]node_modules[\/\\]/gi)) {
        continue;
      }
      for (const change of edit.textChanges) {
        if (change.newText.match(/\/node_modules\//gi)) {
          continue;
        }
      }
      edits.push(edit);
    }
    return WorkspaceEdit2.fromFileCodeEdits(this.client, edits);
  }
};

// src/server/features/jsDocCompletion.ts
var import_coc26 = require("coc.nvim");
var defaultJsDoc = new import_coc26.SnippetString(`/**
 * $0
 */`);
function createCompleteItem(document, position) {
  const line = document.lineAt(position.line).text;
  const prefix = line.slice(0, position.character).match(/\/\**\s*$/);
  const suffix = line.slice(position.character).match(/^\s*\**\//);
  const start = import_coc26.Position.create(position.line, prefix ? position.character - prefix[0].length : position.character);
  const range = import_coc26.Range.create(start, import_coc26.Position.create(start.line, start.character + (suffix ? suffix[0].length : 0)));
  let insert = `/** */`;
  return {
    label: insert,
    kind: import_coc26.CompletionItemKind.Text,
    insertTextFormat: import_coc26.InsertTextFormat.Snippet,
    detail: "JSDoc comment",
    sortText: `\0`,
    textEdit: {
      newText: insert,
      range
    }
  };
}
var JsDocCompletionProvider = class {
  constructor(client, language2, fileConfigurationManager) {
    this.client = client;
    this.language = language2;
    this.fileConfigurationManager = fileConfigurationManager;
  }
  async provideCompletionItems(document, position, token) {
    if (!import_coc26.workspace.getConfiguration(this.language.id, document.uri).get("suggest.completeJSDocs")) {
      return void 0;
    }
    const file2 = this.client.toOpenedFilePath(document.uri);
    if (!file2) {
      return void 0;
    }
    if (!this.isPotentiallyValidDocCompletionPosition(document, position)) {
      return void 0;
    }
    const response = await this.client.interruptGetErr(async () => {
      await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
      const args = Position2.toFileLocationRequestArgs(file2, position);
      return this.client.execute("docCommentTemplate", args, token);
    });
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    const item = createCompleteItem(document, position);
    if (response.body.newText === "/** */") {
      item.textEdit.newText = defaultJsDoc.value;
    } else {
      item.textEdit.newText = templateToSnippet(response.body.newText).value;
    }
    return [item];
  }
  isPotentiallyValidDocCompletionPosition(document, position) {
    const line = document.lineAt(position.line).text;
    const prefix = line.slice(0, position.character);
    if (!/^\s*$|\/\*\s*$|^\s*\/\*+\s*$/.test(prefix)) {
      return false;
    }
    const suffix = line.slice(position.character);
    return /^\s*(\*+\/)?\s*$/.test(suffix);
  }
};
function templateToSnippet(template) {
  let snippetIndex = 1;
  template = template.replace(/\*\s$/gm, "*");
  template = template.replace(/\$/g, "\\$");
  template = template.replace(/^[ \t]*(?=(\/|[ ]\*))/gm, "");
  template = template.replace(/^(\/\*\*\s*\*[ ]*)$/m, (x) => x + `$0`);
  template = template.replace(/\* @param([ ]\{\S+\})?\s+(\S+)[ \t]*$/gm, (_param, type, post) => {
    let out = "* @param ";
    if (type === " {any}" || type === " {*}") {
      out += `{\${${snippetIndex++}:*}} `;
    } else if (type) {
      out += type + " ";
    }
    out += post + ` \${${snippetIndex++}}`;
    return out;
  });
  template = template.replace(/\* @returns[ \t]*$/gm, `* @returns \${${snippetIndex++}}`);
  return new import_coc26.SnippetString(template);
}

// src/server/languageProvider.ts
var suggestionSetting = "suggestionActions.enabled";
var LanguageProvider = class {
  constructor(client, fileConfigurationManager, description, typingsStatus) {
    this.client = client;
    this.fileConfigurationManager = fileConfigurationManager;
    this.description = description;
    this.disposables = [];
    import_coc27.workspace.onDidChangeConfiguration(this.configurationChanged, this, this.disposables);
    this.configurationChanged();
    client.onReady(() => {
      this.registerProviders(client, typingsStatus);
    });
  }
  configurationChanged() {
    const config = import_coc27.workspace.getConfiguration(this.id, null);
    this.client.diagnosticsManager.setEnableSuggestions(this.id, config.get(suggestionSetting, true));
  }
  dispose() {
    (0, import_coc27.disposeAll)(this.disposables);
  }
  _register(disposable) {
    this.disposables.push(disposable);
  }
  registerProviders(client, typingsStatus) {
    let languageIds = this.description.languageIds;
    let clientId = `tsc-${this.description.id}`;
    this._register(import_coc27.languages.registerCompletionItemProvider(clientId, "TSC", languageIds, new TypeScriptCompletionItemProvider(client, typingsStatus, this.fileConfigurationManager, this.description.id), TypeScriptCompletionItemProvider.triggerCharacters));
    this._register(import_coc27.languages.registerCompletionItemProvider(`tsc-${this.description.id}-jsdoc`, "TSC", languageIds, new JsDocCompletionProvider(client, this.description, this.fileConfigurationManager), ["*", " "]));
    if (this.client.apiVersion.gte(API.v230)) {
      this._register(import_coc27.languages.registerCompletionItemProvider(`${this.description.id}-directive`, "TSC", languageIds, new DirectiveCommentCompletionProvider(client), ["@"]));
    }
    let definitionProvider = new TypeScriptDefinitionProvider(client);
    this._register(import_coc27.languages.registerDefinitionProvider(languageIds, definitionProvider));
    this._register(import_coc27.languages.registerTypeDefinitionProvider(languageIds, definitionProvider));
    this._register(import_coc27.languages.registerImplementationProvider(languageIds, definitionProvider));
    this._register(import_coc27.languages.registerReferencesProvider(languageIds, new TypeScriptReferences(client)));
    this._register(import_coc27.languages.registerHoverProvider(languageIds, new TypeScriptHoverProvider(client)));
    this._register(import_coc27.languages.registerDocumentHighlightProvider(languageIds, new TypeScriptDocumentHighlightProvider(this.client)));
    this._register(import_coc27.languages.registerSignatureHelpProvider(languageIds, new TypeScriptSignatureHelpProvider(client), ["(", ",", "<", ")"]));
    this._register(import_coc27.languages.registerDocumentSymbolProvider(languageIds, new TypeScriptDocumentSymbolProvider(client)));
    this._register(import_coc27.languages.registerRenameProvider(languageIds, new TypeScriptRenameProvider(client, this.fileConfigurationManager)));
    let formatProvider = new TypeScriptFormattingProvider(client, this.fileConfigurationManager);
    this._register(import_coc27.languages.registerDocumentFormatProvider(languageIds, formatProvider));
    this._register(import_coc27.languages.registerDocumentRangeFormatProvider(languageIds, formatProvider));
    this._register(import_coc27.languages.registerOnTypeFormattingEditProvider(languageIds, formatProvider, [";", "}", "\n", String.fromCharCode(27)]));
    this._register(import_coc27.languages.registerCodeActionProvider(languageIds, new InstallModuleProvider(client), "tsserver"));
    if (this.client.apiVersion.gte(API.v380) && typeof import_coc27.languages["registerCallHierarchyProvider"] === "function") {
      this._register(import_coc27.languages.registerCallHierarchyProvider(languageIds, new TypeScriptCallHierarchySupport(client)));
    }
    if (this.client.apiVersion.gte(API.v370)) {
      const provider = new TypeScriptDocumentSemanticTokensProvider(client);
      if (typeof import_coc27.languages["registerDocumentSemanticTokensProvider"] === "function") {
        this._register(import_coc27.languages.registerDocumentSemanticTokensProvider(languageIds, provider, provider.getLegend()));
      }
      if (typeof import_coc27.languages["registerDocumentRangeSemanticTokensProvider"] === "function") {
        this._register(import_coc27.languages.registerDocumentRangeSemanticTokensProvider(languageIds, provider, provider.getLegend()));
      }
    }
    let { fileConfigurationManager } = this;
    let conf = fileConfigurationManager.getLanguageConfiguration(this.id);
    if (["javascript", "typescript"].includes(this.id)) {
      if (this.client.apiVersion.gte(API.v290) && conf.get("updateImportsOnFileMove.enable")) {
        this._register(new UpdateImportsOnFileRenameHandler(client, this.fileConfigurationManager, this.id));
      }
    }
    if (this.client.apiVersion.gte(API.v280)) {
      this._register(import_coc27.languages.registerFoldingRangeProvider(languageIds, new TypeScriptFoldingProvider(this.client)));
      this._register(import_coc27.languages.registerCodeActionProvider(languageIds, new OrganizeImportsCodeActionProvider(this.client, this.fileConfigurationManager), "tsserver", [import_vscode_languageserver_protocol17.CodeActionKind.SourceOrganizeImports]));
    }
    if (this.client.apiVersion.gte(API.v240)) {
      this._register(import_coc27.languages.registerCodeActionProvider(languageIds, new TypeScriptRefactorProvider(client, this.fileConfigurationManager), "tsserver", [import_vscode_languageserver_protocol17.CodeActionKind.Refactor]));
    }
    this._register(import_coc27.languages.registerCodeActionProvider(languageIds, new TypeScriptQuickFixProvider(client, this.fileConfigurationManager), "tsserver", [import_vscode_languageserver_protocol17.CodeActionKind.QuickFix]));
    this._register(import_coc27.languages.registerCodeActionProvider(languageIds, new ImportFixProvider(this.client.bufferSyncSupport), "tsserver", [import_vscode_languageserver_protocol17.CodeActionKind.QuickFix]));
    let cachedResponse = new CachedNavTreeResponse();
    if (this.client.apiVersion.gte(API.v206) && conf.get("referencesCodeLens.enable")) {
      this._register(import_coc27.languages.registerCodeLensProvider(languageIds, new TypeScriptReferencesCodeLensProvider(client, cachedResponse, this.description.id)));
    }
    if (this.client.apiVersion.gte(API.v220) && conf.get("implementationsCodeLens.enable")) {
      this._register(import_coc27.languages.registerCodeLensProvider(languageIds, new TypeScriptImplementationsCodeLensProvider(client, cachedResponse, this.description.id)));
    }
    if (this.client.apiVersion.gte(API.v350)) {
      this._register(import_coc27.languages.registerSelectionRangeProvider(languageIds, new SmartSelection(this.client)));
    }
    if (this.client.apiVersion.gte(API.v300)) {
      this._register(new TagClosing(this.client, this.description.id));
    }
    if (this.client.apiVersion.gte(API.v440)) {
      if (typeof import_coc27.languages.registerInlayHintsProvider === "function") {
        let provider = new TypeScriptInlayHintsProvider(this.description, this.client, this.fileConfigurationManager);
        this._register(provider);
        this._register(import_coc27.languages.registerInlayHintsProvider(languageIds, provider));
      } else {
        this.client.logger.error(`languages.registerInlayHintsProvider is not a function, inlay hints won't work`);
      }
    }
  }
  handles(resource, doc) {
    if (doc && this.description.languageIds.includes(doc.languageId)) {
      return true;
    }
    return this.handlesConfigFile(import_coc27.Uri.parse(resource));
  }
  handlesConfigFile(uri) {
    const base = import_path5.default.basename(uri.fsPath);
    return !!base && (!!this.description.configFilePattern && this.description.configFilePattern.test(base));
  }
  handlesUri(resource) {
    const ext = import_path5.default.extname(resource.path).slice(1).toLowerCase();
    return this.description.standardFileExtensions.includes(ext) || this.handlesConfigFile(resource);
  }
  get id() {
    return this.description.id;
  }
  get diagnosticSource() {
    return this.description.diagnosticSource;
  }
  triggerAllDiagnostics() {
    this.client.bufferSyncSupport.requestAllDiagnostics();
  }
  diagnosticsReceived(diagnosticsKind, file2, diagnostics) {
    const config = import_coc27.workspace.getConfiguration(this.id, file2.toString());
    const reportUnnecessary = config.get("showUnused", true);
    const reportDeprecated = config.get("showDeprecated", true);
    this.client.diagnosticsManager.diagnosticsReceived(diagnosticsKind, file2.toString(), diagnostics.filter((diag) => {
      if (!reportUnnecessary) {
        if (diag.reportUnnecessary && diag.severity === import_vscode_languageserver_protocol17.DiagnosticSeverity.Information) {
          return false;
        }
      }
      if (!reportDeprecated) {
        if (diag.reportDeprecated && diag.severity === import_vscode_languageserver_protocol17.DiagnosticSeverity.Hint) {
          return false;
        }
      }
      return true;
    }));
  }
};

// src/server/typescriptServiceClient.ts
var import_coc37 = require("coc.nvim");
var import_fs4 = __toESM(require("fs"));
var import_os2 = __toESM(require("os"));
var import_path8 = __toESM(require("path"));
var import_vscode_languageserver_protocol21 = __toESM(require_main2());

// src/utils/fileSchemes.ts
var file = "file";
var git = "git";
var vsls = "vsls";
var disabledSchemes = /* @__PURE__ */ new Set([
  git,
  vsls
]);

// src/server/callbackMap.ts
var CallbackMap = class {
  constructor() {
    this._callbacks = /* @__PURE__ */ new Map();
    this._asyncCallbacks = /* @__PURE__ */ new Map();
  }
  destroy(cause) {
    const cancellation = new ServerResponse.Cancelled(cause);
    for (const callback of this._callbacks.values()) {
      callback.onSuccess(cancellation);
    }
    this._callbacks.clear();
    for (const callback of this._asyncCallbacks.values()) {
      callback.onSuccess(cancellation);
    }
    this._asyncCallbacks.clear();
  }
  add(seq, callback, isAsync) {
    if (isAsync) {
      this._asyncCallbacks.set(seq, callback);
    } else {
      this._callbacks.set(seq, callback);
    }
  }
  fetch(seq) {
    const callback = this._callbacks.get(seq) || this._asyncCallbacks.get(seq);
    this.delete(seq);
    return callback;
  }
  delete(seq) {
    if (!this._callbacks.delete(seq)) {
      this._asyncCallbacks.delete(seq);
    }
  }
};

// src/server/features/bufferSyncSupport.ts
var import_coc29 = require("coc.nvim");
var import_vscode_languageserver_protocol18 = __toESM(require_main2());

// src/server/utils/async.ts
var Delayer = class {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.timeout = null;
    this.completionPromise = null;
    this.onSuccess = null;
    this.task = null;
  }
  trigger(task, delay = this.defaultDelay) {
    this.task = task;
    if (delay >= 0) {
      this.cancelTimeout();
    }
    if (!this.completionPromise) {
      this.completionPromise = new Promise((resolve) => {
        this.onSuccess = resolve;
      }).then(() => {
        this.completionPromise = null;
        this.onSuccess = null;
        let result = this.task && this.task();
        this.task = null;
        return result;
      });
    }
    if (delay >= 0 || this.timeout === null) {
      this.timeout = setTimeout(() => {
        this.timeout = null;
        if (this.onSuccess) {
          this.onSuccess(void 0);
        }
      }, delay >= 0 ? delay : this.defaultDelay);
    }
    return this.completionPromise;
  }
  cancelTimeout() {
    if (this.timeout !== null) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
};

// src/server/utils/languageModeIds.ts
var typescript = "typescript";
var typescriptreact = "typescriptreact";
var typescripttsx = "typescript.tsx";
var typescriptjsx = "typescript.jsx";
var javascript = "javascript";
var javascriptreact = "javascriptreact";
var javascriptjsx = "javascript.jsx";
function mode2ScriptKind(mode) {
  switch (mode) {
    case typescript:
      return "TS";
    case typescripttsx:
      return "TSX";
    case typescriptjsx:
      return "TSX";
    case typescriptreact:
      return "TSX";
    case javascript:
      return "JS";
    case javascriptreact:
      return "JSX";
  }
  return void 0;
}

// src/server/features/resourceMap.ts
var import_coc28 = require("coc.nvim");
function defaultPathNormalizer(resource) {
  let u = import_coc28.Uri.parse(resource);
  if (u.scheme === "file") {
    return u.fsPath;
  }
  return resource.toString();
}
var ResourceMap = class {
  constructor(_normalizePath = defaultPathNormalizer) {
    this._normalizePath = _normalizePath;
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get entries() {
    return this._map.values();
  }
  has(uri) {
    const file2 = this.toKey(uri);
    return !!file2 && this._map.has(file2);
  }
  get(uri) {
    const file2 = this.toKey(uri);
    if (!file2)
      return void 0;
    let entry = this._map.get(file2);
    return entry ? entry.value : void 0;
  }
  set(uri, value) {
    const file2 = this.toKey(uri);
    if (file2) {
      this._map.set(file2, { uri, value });
    }
  }
  delete(uri) {
    const file2 = this.toKey(uri);
    if (file2) {
      this._map.delete(file2);
    }
  }
  get values() {
    return Array.from(this._map.values()).map((x) => x.value);
  }
  get uris() {
    return Array.from(this._map.values()).map((x) => x.uri);
  }
  clear() {
    this._map.clear();
  }
  toKey(uri) {
    const key = this._normalizePath ? this._normalizePath(uri) : uri;
    if (!key) {
      return key;
    }
    return this.isCaseInsensitivePath(key) ? key.toLowerCase() : key;
  }
  isCaseInsensitivePath(path9) {
    if (isWindowsPath(path9)) {
      return true;
    }
    return path9[0] === "/" && this.onIsCaseInsenitiveFileSystem;
  }
  get onIsCaseInsenitiveFileSystem() {
    if (process.platform === "win32") {
      return true;
    }
    if (process.platform === "darwin") {
      return true;
    }
    return false;
  }
};
function isWindowsPath(path9) {
  return /^[a-zA-Z]:\\/.test(path9);
}

// src/server/features/bufferSyncSupport.ts
var CloseOperation = class {
  constructor(args) {
    this.args = args;
    this.type = 0 /* Close */;
  }
};
var OpenOperation = class {
  constructor(args) {
    this.args = args;
    this.type = 1 /* Open */;
  }
};
var ChangeOperation = class {
  constructor(args) {
    this.args = args;
    this.type = 2 /* Change */;
  }
};
var SyncedBuffer = class {
  constructor(document, filepath, client, synchronizer) {
    this.document = document;
    this.filepath = filepath;
    this.client = client;
    this.synchronizer = synchronizer;
    this.state = 1 /* Initial */;
  }
  open() {
    const args = {
      file: this.filepath,
      fileContent: this.document.getText(),
      projectRootPath: this.client.getProjectRootPath(this.document.uri)
    };
    const scriptKind = mode2ScriptKind(this.document.languageId);
    if (scriptKind) {
      args.scriptKindName = scriptKind;
    }
    if (this.client.apiVersion.gte(API.v240)) {
      const tsPluginsForDocument = this.client.pluginManager.plugins.filter((x) => x.languages.indexOf(this.document.languageId) >= 0);
      if (tsPluginsForDocument.length) {
        args.plugins = tsPluginsForDocument.map((plugin) => plugin.name);
      }
    }
    this.synchronizer.open(this.resource, args);
    this.state = 2 /* Open */;
  }
  get resource() {
    return this.document.uri;
  }
  get lineCount() {
    return this.document.lineCount;
  }
  get kind() {
    if (this.document.languageId.startsWith("javascript")) {
      return 2 /* JavaScript */;
    }
    return 1 /* TypeScript */;
  }
  close() {
    if (this.state !== 2 /* Open */) {
      this.state = 2 /* Closed */;
      return false;
    }
    this.state = 2 /* Closed */;
    return this.synchronizer.close(this.resource, this.filepath);
  }
  onContentChanged(events3) {
    if (this.state !== 2 /* Open */) {
      console.error(`Unexpected buffer state: ${this.state}`);
    }
    this.synchronizer.change(this.resource, this.filepath, events3);
  }
};
var SyncedBufferMap = class extends ResourceMap {
  getForPath(filePath) {
    return this.get(import_coc29.Uri.file(filePath).toString());
  }
  get allBuffers() {
    return this.values;
  }
};
var PendingDiagnostics = class extends ResourceMap {
  getOrderedFileSet() {
    const orderedResources = Array.from(this.entries).sort((a, b) => a.value - b.value).map((entry) => entry.uri);
    const map = new ResourceMap(this._normalizePath);
    for (const resource of orderedResources) {
      map.set(resource, void 0);
    }
    return map;
  }
};
var BufferSynchronizer = class {
  constructor(client, pathNormalizer) {
    this.client = client;
    this._pending = new ResourceMap(pathNormalizer);
  }
  open(resource, args) {
    if (this.supportsBatching) {
      this.updatePending(resource, new OpenOperation(args));
    } else {
      this.client.executeWithoutWaitingForResponse("open", args);
    }
  }
  close(resource, filepath) {
    if (this.supportsBatching) {
      return this.updatePending(resource, new CloseOperation(filepath));
    } else {
      const args = { file: filepath };
      this.client.executeWithoutWaitingForResponse("close", args);
      return true;
    }
  }
  change(resource, filepath, events3) {
    if (!events3.length) {
      return;
    }
    if (this.supportsBatching) {
      this.updatePending(resource, new ChangeOperation({
        fileName: filepath,
        textChanges: events3.map((change) => ({
          newText: change.text,
          start: Position2.toLocation(change.range.start),
          end: Position2.toLocation(change.range.end)
        })).reverse()
      }));
    } else {
      for (const { range, text } of events3) {
        const args = __spreadValues({
          insertString: text
        }, Range3.toFormattingRequestArgs(filepath, range));
        this.client.executeWithoutWaitingForResponse("change", args);
      }
    }
  }
  reset() {
    this._pending.clear();
  }
  beforeCommand(command) {
    if (command === "updateOpen") {
      return;
    }
    this.flush();
  }
  flush() {
    if (!this.supportsBatching) {
      this._pending.clear();
      return;
    }
    if (this._pending.size > 0) {
      const closedFiles = [];
      const openFiles = [];
      const changedFiles = [];
      for (const change of this._pending.values) {
        switch (change.type) {
          case 2 /* Change */:
            changedFiles.push(change.args);
            break;
          case 1 /* Open */:
            openFiles.push(change.args);
            break;
          case 0 /* Close */:
            closedFiles.push(change.args);
            break;
        }
      }
      this.client.execute("updateOpen", { changedFiles, closedFiles, openFiles }, import_vscode_languageserver_protocol18.CancellationToken.None, { nonRecoverable: true });
      this._pending.clear();
    }
  }
  get supportsBatching() {
    return this.client.apiVersion.gte(API.v340);
  }
  updatePending(resource, op) {
    switch (op.type) {
      case 0 /* Close */:
        const existing = this._pending.get(resource);
        switch (existing == null ? void 0 : existing.type) {
          case 1 /* Open */:
            this._pending.delete(resource);
            return false;
        }
        break;
    }
    if (this._pending.has(resource)) {
      this.flush();
    }
    this._pending.set(resource, op);
    return true;
  }
};
var GetErrRequest = class {
  constructor(client, uris, _token, onDone) {
    this.uris = uris;
    this._token = _token;
    this._done = false;
    let files = uris.map((uri) => client.normalizePath(uri));
    const args = {
      delay: 0,
      files
    };
    const done = () => {
      if (this._done) {
        return;
      }
      this._done = true;
      onDone();
    };
    client.executeAsync("geterr", args, _token.token).then(done, done);
  }
  static executeGetErrRequest(client, uris, onDone) {
    const token = new import_vscode_languageserver_protocol18.CancellationTokenSource();
    return new GetErrRequest(client, uris, token, onDone);
  }
  cancel() {
    if (!this._done) {
      this._token.cancel();
    }
    this._token.dispose();
  }
};
var BufferSyncSupport = class {
  constructor(client, modeIds) {
    this.disposables = [];
    this._validateJavaScript = true;
    this._validateTypeScript = true;
    this.listening = false;
    this._onDelete = new import_vscode_languageserver_protocol18.Emitter();
    this.onDelete = this._onDelete.event;
    this._onWillChange = new import_vscode_languageserver_protocol18.Emitter();
    this.onWillChange = this._onWillChange.event;
    this.client = client;
    this.modeIds = new Set(modeIds);
    this.diagnosticDelayer = new Delayer(300);
    const pathNormalizer = (path9) => this.client.toPath(path9);
    this.syncedBuffers = new SyncedBufferMap(pathNormalizer);
    this.pendingDiagnostics = new PendingDiagnostics(pathNormalizer);
    this.synchronizer = new BufferSynchronizer(client, pathNormalizer);
    this.updateConfiguration();
    import_coc29.workspace.onDidChangeConfiguration(this.updateConfiguration, this, this.disposables);
  }
  listen() {
    if (this.listening)
      return;
    this.listening = true;
    import_coc29.workspace.onDidOpenTextDocument(this.openTextDocument, this, this.disposables);
    import_coc29.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, this.disposables);
    import_coc29.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, this.disposables);
    import_coc29.workspace.textDocuments.forEach(this.openTextDocument, this);
  }
  handles(resource) {
    return this.syncedBuffers.has(resource);
  }
  dispose() {
    this.pendingDiagnostics.clear();
    (0, import_coc29.disposeAll)(this.disposables);
    this._onWillChange.dispose();
    this._onDelete.dispose();
  }
  ensureHasBuffer(resource) {
    if (this.syncedBuffers.has(resource)) {
      return true;
    }
    const existingDocument = import_coc29.workspace.textDocuments.find((doc) => doc.uri.toString() === resource);
    if (existingDocument) {
      return this.openTextDocument(existingDocument);
    }
    return false;
  }
  toResource(filePath) {
    const buffer = this.syncedBuffers.getForPath(filePath);
    if (buffer)
      return buffer.resource;
    return import_coc29.Uri.file(filePath).toString();
  }
  reset() {
    var _a;
    (_a = this.pendingGetErr) == null ? void 0 : _a.cancel();
    this.pendingDiagnostics.clear();
    this.synchronizer.reset();
  }
  reinitialize() {
    this.reset();
    for (const buffer of this.syncedBuffers.allBuffers) {
      buffer.open();
    }
  }
  openTextDocument(document) {
    if (!this.modeIds.has(document.languageId)) {
      return false;
    }
    const resource = document.uri;
    const filepath = this.client.normalizePath(import_coc29.Uri.parse(resource));
    if (!filepath) {
      return false;
    }
    if (this.syncedBuffers.has(resource)) {
      return true;
    }
    const syncedBuffer = new SyncedBuffer(document, filepath, this.client, this.synchronizer);
    this.syncedBuffers.set(resource, syncedBuffer);
    syncedBuffer.open();
    this.requestDiagnostic(syncedBuffer);
    return true;
  }
  closeResource(resource) {
    const syncedBuffer = this.syncedBuffers.get(resource);
    if (!syncedBuffer) {
      return;
    }
    this.pendingDiagnostics.delete(resource);
    this.syncedBuffers.delete(resource);
    const wasBufferOpen = syncedBuffer.close();
    this._onDelete.fire(resource);
    if (wasBufferOpen) {
      this.requestAllDiagnostics();
    }
  }
  onDidCloseTextDocument(document) {
    this.closeResource(document.uri);
  }
  onDidChangeTextDocument(e) {
    const syncedBuffer = this.syncedBuffers.get(e.textDocument.uri);
    if (!syncedBuffer) {
      return;
    }
    this._onWillChange.fire(syncedBuffer.resource);
    syncedBuffer.onContentChanged(e.contentChanges);
    const didTrigger = this.requestDiagnostic(syncedBuffer);
    if (!didTrigger && this.pendingGetErr) {
      this.pendingGetErr.cancel();
      this.pendingGetErr = void 0;
      this.triggerDiagnostics();
    }
  }
  beforeCommand(command) {
    this.synchronizer.beforeCommand(command);
  }
  interuptGetErr(f) {
    if (!this.pendingGetErr) {
      return f();
    }
    this.pendingGetErr.cancel();
    this.pendingGetErr = void 0;
    const result = f();
    this.triggerDiagnostics();
    return result;
  }
  getErr(resources) {
    const handledResources = resources.filter((resource) => {
      let syncedBuffer = this.syncedBuffers.get(resource.toString());
      return syncedBuffer && this.shouldValidate(syncedBuffer);
    });
    if (!handledResources.length) {
      return;
    }
    for (const resource of handledResources) {
      this.pendingDiagnostics.set(resource.toString(), Date.now());
    }
    this.triggerDiagnostics();
  }
  triggerDiagnostics(delay = 200) {
    this.diagnosticDelayer.trigger(() => {
      this.sendPendingDiagnostics();
    }, delay);
  }
  requestAllDiagnostics() {
    for (const buffer of this.syncedBuffers.allBuffers) {
      if (this.shouldValidate(buffer)) {
        this.pendingDiagnostics.set(buffer.resource, Date.now());
      }
    }
    this.triggerDiagnostics();
  }
  requestDiagnostic(buffer) {
    if (!this.shouldValidate(buffer)) {
      return false;
    }
    this.pendingDiagnostics.set(buffer.resource, Date.now());
    const delay = Math.min(Math.max(Math.ceil(buffer.lineCount / 20), 300), 800);
    this.triggerDiagnostics(delay);
    return true;
  }
  hasPendingDiagnostics(uri) {
    return this.pendingDiagnostics.has(uri);
  }
  sendPendingDiagnostics() {
    const orderedFileSet = this.pendingDiagnostics.getOrderedFileSet();
    if (this.pendingGetErr) {
      this.pendingGetErr.cancel();
      for (const uri of this.pendingGetErr.uris) {
        let resource = uri.toString();
        let syncedBuffer = this.syncedBuffers.get(resource);
        if (syncedBuffer && this.shouldValidate(syncedBuffer)) {
          orderedFileSet.set(resource, void 0);
        } else {
          orderedFileSet.delete(resource);
        }
      }
      this.pendingGetErr = void 0;
    }
    for (const buffer of this.syncedBuffers.values) {
      if (this.shouldValidate(buffer)) {
        orderedFileSet.set(buffer.resource, void 0);
      }
    }
    if (orderedFileSet.size) {
      let uris = Array.from(orderedFileSet.uris).map((uri) => import_coc29.Uri.parse(uri));
      const getErr = this.pendingGetErr = GetErrRequest.executeGetErrRequest(this.client, uris, () => {
        if (this.pendingGetErr === getErr) {
          this.pendingGetErr = void 0;
        }
      });
    }
    this.pendingDiagnostics.clear();
  }
  updateConfiguration() {
    const jsConfig = import_coc29.workspace.getConfiguration("javascript", null);
    const tsConfig = import_coc29.workspace.getConfiguration("typescript", null);
    this._validateJavaScript = jsConfig.get("validate.enable", true);
    this._validateTypeScript = tsConfig.get("validate.enable", true);
  }
  shouldValidate(buffer) {
    switch (buffer.kind) {
      case 2 /* JavaScript */:
        return this._validateJavaScript;
      case 1 /* TypeScript */:
      default:
        return this._validateTypeScript;
    }
  }
};

// src/server/features/diagnostics.ts
var import_coc30 = require("coc.nvim");
var import_vscode_languageserver_protocol19 = __toESM(require_main2());
var DiagnosticSet = class {
  constructor() {
    this._map = new ResourceMap();
  }
  set(uri, diagnostics) {
    this._map.set(uri, diagnostics);
  }
  get(uri) {
    return this._map.get(uri) || [];
  }
  clear() {
    this._map = new ResourceMap();
  }
};
var allDiagnosticKinds = [
  0 /* Syntax */,
  1 /* Semantic */,
  2 /* Suggestion */
];
var DiagnosticsManager = class {
  constructor() {
    this._diagnostics = /* @__PURE__ */ new Map();
    this._pendingUpdates = new ResourceMap();
    this._enableJavascriptSuggestions = true;
    this._enableTypescriptSuggestions = true;
    this.updateDelay = 200;
    for (const kind of allDiagnosticKinds) {
      this._diagnostics.set(kind, new DiagnosticSet());
    }
    this._currentDiagnostics = import_coc30.languages.createDiagnosticCollection("tsserver");
  }
  dispose() {
    this._currentDiagnostics.dispose();
    for (const value of this._pendingUpdates.values) {
      clearTimeout(value);
    }
    this._pendingUpdates = new ResourceMap();
  }
  reInitialize() {
    this._currentDiagnostics.clear();
    for (const diagnosticSet of this._diagnostics.values()) {
      diagnosticSet.clear();
    }
  }
  setEnableSuggestions(languageId, value) {
    let curr = languageId == "javascript" ? this._enableJavascriptSuggestions : this._enableTypescriptSuggestions;
    if (curr == value) {
      return;
    }
    if (languageId == "javascript") {
      this._enableJavascriptSuggestions = value;
    } else {
      this._enableTypescriptSuggestions = value;
    }
  }
  diagnosticsReceived(kind, uri, diagnostics) {
    const collection = this._diagnostics.get(kind);
    if (!collection)
      return;
    let doc = import_coc30.workspace.getDocument(uri);
    if (doc)
      uri = doc.uri;
    if (diagnostics.length === 0) {
      const existing = collection.get(uri);
      if (existing.length === 0) {
        return;
      }
    }
    collection.set(uri, diagnostics);
    this.scheduleDiagnosticsUpdate(uri);
  }
  configFileDiagnosticsReceived(uri, diagnostics) {
    this._currentDiagnostics.set(uri, diagnostics);
  }
  delete(uri) {
    this._currentDiagnostics.delete(uri);
  }
  getDiagnostics(uri) {
    return this._currentDiagnostics.get(uri) || [];
    return [];
  }
  scheduleDiagnosticsUpdate(uri) {
    if (!this._pendingUpdates.has(uri)) {
      this._pendingUpdates.set(uri, setTimeout(() => this.updateCurrentDiagnostics(uri), this.updateDelay));
    }
  }
  updateCurrentDiagnostics(uri) {
    if (this._pendingUpdates.has(uri)) {
      clearTimeout(this._pendingUpdates.get(uri));
      this._pendingUpdates.delete(uri);
    }
    const allDiagnostics = [
      ...this._diagnostics.get(0 /* Syntax */).get(uri),
      ...this._diagnostics.get(1 /* Semantic */).get(uri),
      ...this.getSuggestionDiagnostics(uri)
    ];
    this._currentDiagnostics.set(uri, allDiagnostics);
  }
  getSuggestionDiagnostics(uri) {
    const enabled = this.suggestionsEnabled(uri);
    return this._diagnostics.get(2 /* Suggestion */).get(uri).filter((x) => {
      if (!enabled) {
        return x.tags && (x.tags.includes(import_vscode_languageserver_protocol19.DiagnosticTag.Unnecessary) || x.tags.includes(import_vscode_languageserver_protocol19.DiagnosticTag.Deprecated));
      }
      return enabled;
    });
  }
  suggestionsEnabled(uri) {
    let doc = import_coc30.workspace.getDocument(uri);
    if (!doc)
      return false;
    if (doc.filetype.startsWith("javascript")) {
      return this._enableJavascriptSuggestions;
    }
    if (doc.filetype.startsWith("typescript")) {
      return this._enableTypescriptSuggestions;
    }
    return true;
  }
};

// src/server/requestQueue.ts
var RequestQueue = class {
  constructor() {
    this.queue = [];
    this.sequenceNumber = 0;
  }
  get length() {
    return this.queue.length;
  }
  enqueue(item) {
    if (item.queueingType === 1 /* Normal */) {
      let index = this.queue.length - 1;
      while (index >= 0) {
        if (this.queue[index].queueingType !== 2 /* LowPriority */) {
          break;
        }
        --index;
      }
      this.queue.splice(index + 1, 0, item);
    } else {
      this.queue.push(item);
    }
  }
  dequeue() {
    return this.queue.shift();
  }
  tryDeletePendingRequest(seq) {
    for (let i = 0; i < this.queue.length; i++) {
      if (this.queue[i].request.seq === seq) {
        this.queue.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  createRequest(command, args) {
    return {
      seq: this.sequenceNumber++,
      type: "request",
      command,
      arguments: args
    };
  }
};

// src/server/utils/configuration.ts
var import_coc31 = require("coc.nvim");
var import_which = __toESM(require_which());
var TsServerLogLevel = /* @__PURE__ */ ((TsServerLogLevel2) => {
  TsServerLogLevel2[TsServerLogLevel2["Off"] = 0] = "Off";
  TsServerLogLevel2[TsServerLogLevel2["Normal"] = 1] = "Normal";
  TsServerLogLevel2[TsServerLogLevel2["Terse"] = 2] = "Terse";
  TsServerLogLevel2[TsServerLogLevel2["Verbose"] = 3] = "Verbose";
  return TsServerLogLevel2;
})(TsServerLogLevel || {});
((TsServerLogLevel2) => {
  function fromString(value) {
    switch (value && value.toLowerCase()) {
      case "normal":
        return 1 /* Normal */;
      case "terse":
        return 2 /* Terse */;
      case "verbose":
        return 3 /* Verbose */;
      case "off":
      default:
        return 0 /* Off */;
    }
  }
  TsServerLogLevel2.fromString = fromString;
  function toString2(value) {
    switch (value) {
      case 1 /* Normal */:
        return "normal";
      case 2 /* Terse */:
        return "terse";
      case 3 /* Verbose */:
        return "verbose";
      case 0 /* Off */:
      default:
        return "off";
    }
  }
  TsServerLogLevel2.toString = toString2;
})(TsServerLogLevel || (TsServerLogLevel = {}));
var TypeScriptServiceConfiguration = class {
  constructor() {
    this._configuration = import_coc31.workspace.getConfiguration("tsserver");
    this._includePackageJsonAutoImports = import_coc31.workspace.getConfiguration("typescript").get("preferences.includePackageJsonAutoImports");
    import_coc31.workspace.onDidChangeConfiguration(() => {
      this._configuration = import_coc31.workspace.getConfiguration("tsserver");
      this._includePackageJsonAutoImports = import_coc31.workspace.getConfiguration("typescript").get("preferences.includePackageJsonAutoImports");
    });
  }
  get enableTsServerTracing() {
    return this._configuration.get("enableTracing", false);
  }
  get includePackageJsonAutoImports() {
    return this._includePackageJsonAutoImports;
  }
  get locale() {
    return this._configuration.get("locale", null);
  }
  get globalTsdk() {
    return this._configuration.get("tsdk", null);
  }
  get ignoreLocalTsserver() {
    return this._configuration.get("ignoreLocalTsserver", false);
  }
  get tsServerLogLevel() {
    return TsServerLogLevel.fromString(this._configuration.get("log", null));
  }
  get watchOptions() {
    return this._configuration.get("watchOptions");
  }
  get typingsCacheLocation() {
    return this._configuration.get("typingsCacheLocation", "");
  }
  get tsServerPluginPaths() {
    return this._configuration.get("pluginPaths", []);
  }
  get checkJs() {
    return this._configuration.get("implicitProjectConfig.checkJs", false);
  }
  get experimentalDecorators() {
    return this._configuration.get("implicitProjectConfig.experimentalDecorators", false);
  }
  get disableAutomaticTypeAcquisition() {
    return this._configuration.get("disableAutomaticTypeAcquisition", false);
  }
  get formatOnType() {
    return this._configuration.get("formatOnType", false);
  }
  get maxTsServerMemory() {
    return this._configuration.get("maxTsServerMemory", 0);
  }
  get npmLocation() {
    let path9 = this._configuration.get("npm", "");
    if (path9)
      return import_coc31.workspace.expand(path9);
    try {
      path9 = import_which.default.sync("npm");
    } catch (e) {
      return null;
    }
    return path9;
  }
  static loadFromWorkspace() {
    return new TypeScriptServiceConfiguration();
  }
};

// src/server/utils/logger.ts
var import_coc32 = require("coc.nvim");

// src/server/utils/is.ts
var toString = Object.prototype.toString;
function boolean(value) {
  return value === true || value === false;
}
function string(value) {
  return toString.call(value) === "[object String]";
}

// src/server/utils/logger.ts
var Logger = class {
  get output() {
    if (this._channel) {
      return this._channel;
    }
    this._channel = import_coc32.window.createOutputChannel("tsserver");
    return this._channel;
  }
  dispose() {
    if (this._channel) {
      this._channel.dispose();
    }
  }
  data2String(data) {
    if (data instanceof Error) {
      if (string(data.stack)) {
        return data.stack;
      }
      return data.message;
    }
    if (boolean(data.success) && !data.success && string(data.message)) {
      return data.message;
    }
    if (string(data)) {
      return data;
    }
    return data.toString();
  }
  info(message, data) {
    this.logLevel("Info", message, data);
  }
  warn(message, data) {
    this.logLevel("Warn", message, data);
  }
  error(message, data) {
    if (data && data.message === "No content available.") {
      return;
    }
    this.logLevel("Error", message, data);
  }
  now() {
    const now = new Date();
    return padLeft(now.getUTCHours() + "", 2, "0") + ":" + padLeft(now.getMinutes() + "", 2, "0") + ":" + padLeft(now.getUTCSeconds() + "", 2, "0") + "." + now.getMilliseconds();
  }
  logLevel(level, message, data) {
    this.output.appendLine(`[${level} - ${this.now()}] ${message}`);
    if (data) {
      this.output.appendLine(this.data2String(data));
    }
  }
};
function padLeft(s, n, pad = " ") {
  return pad.repeat(Math.max(0, n - s.length)) + s;
}

// src/server/utils/process.ts
var import_child_process2 = __toESM(require("child_process"));
var import_os = __toESM(require("os"));
var import_path6 = __toESM(require("path"));
var import_fs2 = __toESM(require("fs"));
function makeRandomHexString(length) {
  let chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
  let result = "";
  for (let i = 0; i < length; i++) {
    const idx = Math.floor(chars.length * Math.random());
    result += chars[idx];
  }
  return result;
}
function getTempDirectory() {
  let dir = import_path6.default.join(import_os.default.tmpdir(), `coc.nvim-${process.pid}`);
  try {
    if (!import_fs2.default.existsSync(dir)) {
      import_fs2.default.mkdirSync(dir);
    }
  } catch (e) {
    return void 0;
  }
  return dir;
}
function getTempFile(name) {
  const fullName = "coc-nvim-" + name;
  let dir = getTempDirectory();
  if (!dir)
    return void 0;
  return import_path6.default.join(dir, fullName + ".sock");
}
function createTempDirectory(name) {
  let dir = getTempDirectory();
  if (!dir)
    return void 0;
  let res = import_path6.default.join(dir, name);
  try {
    import_fs2.default.mkdirSync(res);
  } catch (e) {
    return void 0;
  }
  return res;
}
function generatePatchedEnv(env, modulePath) {
  const newEnv = Object.assign({}, env);
  newEnv["NODE_PATH"] = import_path6.default.join(modulePath, "..", "..", "..");
  newEnv["PATH"] = newEnv["PATH"] || process.env.PATH;
  return newEnv;
}
function fork(modulePath, args, options, logger) {
  logger.info("Forking TSServer", `PATH: ${modulePath} `);
  let childProcess = import_child_process2.default.fork(modulePath, args, {
    silent: true,
    cwd: void 0,
    env: generatePatchedEnv(process.env, modulePath),
    execArgv: options.execArgv
  });
  return childProcess;
}

// src/server/utils/tracer.ts
var import_coc33 = require("coc.nvim");
var Trace = /* @__PURE__ */ ((Trace2) => {
  Trace2[Trace2["Off"] = 0] = "Off";
  Trace2[Trace2["Messages"] = 1] = "Messages";
  Trace2[Trace2["Verbose"] = 2] = "Verbose";
  return Trace2;
})(Trace || {});
((Trace2) => {
  function fromString(value) {
    value = value || "";
    value = value.toLowerCase();
    switch (value) {
      case "off":
        return 0 /* Off */;
      case "messages":
        return 1 /* Messages */;
      case "verbose":
        return 2 /* Verbose */;
      default:
        return 0 /* Off */;
    }
  }
  Trace2.fromString = fromString;
})(Trace || (Trace = {}));
var Tracer = class {
  constructor(logger) {
    this.logger = logger;
    this.trace = Tracer.readTrace();
  }
  static readTrace() {
    let result = Trace.fromString(import_coc33.workspace.getConfiguration("tsserver").get("trace.server", "off"));
    if (result === 0 /* Off */ && !!process.env.TSS_TRACE) {
      result = 1 /* Messages */;
    }
    return result;
  }
  traceRequest(request, responseExpected, queueLength) {
    if (this.trace === 0 /* Off */)
      return;
    let data;
    if (this.trace === 2 /* Verbose */ && request.arguments) {
      data = `Arguments: ${JSON.stringify(request.arguments, null, 4)}`;
    }
    this.logTrace(`Sending request: ${request.command} (${request.seq}). Response expected: ${responseExpected ? "yes" : "no"}. Current queue length: ${queueLength}`, data);
  }
  traceResponse(response, startTime) {
    if (this.trace === 0 /* Off */) {
      return;
    }
    let data;
    if (this.trace === 2 /* Verbose */ && response.body) {
      data = `Result: ${JSON.stringify(response.body, null, 4)}`;
    }
    this.logTrace(`Response received: ${response.command} (${response.request_seq}). Request took ${Date.now() - startTime} ms. Success: ${response.success} ${!response.success ? ". Message: " + response.message : ""}`, data);
  }
  traceEvent(event) {
    if (this.trace === 0 /* Off */) {
      return;
    }
    let data;
    if (this.trace === 2 /* Verbose */ && event.body) {
      data = `Data: ${JSON.stringify(event.body, null, 4)}`;
    }
    this.logTrace(`Event received: ${event.event} (${event.seq}).`, data);
  }
  logTrace(message, data) {
    if (this.trace !== 0 /* Off */) {
      this.logger.logLevel("Trace", message, data);
    }
  }
  traceRequestCompleted(command, request_seq, startTime) {
    if (this.trace === 0 /* Off */) {
      return;
    }
    this.logTrace(`Async response received: ${command} (${request_seq}). Request took ${Date.now() - startTime} ms.`);
  }
};

// src/server/utils/tsconfig.ts
function inferredProjectConfig(config) {
  const base = {
    module: "commonjs",
    target: "es2016",
    jsx: "preserve"
  };
  if (config.checkJs) {
    base.checkJs = true;
  }
  if (config.experimentalDecorators) {
    base.experimentalDecorators = true;
  }
  return base;
}

// src/server/utils/versionProvider.ts
var import_coc34 = require("coc.nvim");
var import_fs3 = __toESM(require("fs"));
var import_path7 = __toESM(require("path"));
var TypeScriptVersion = class {
  constructor(path9, _pathLabel) {
    this.path = path9;
    this._pathLabel = _pathLabel;
    this._api = null;
  }
  get tscPath() {
    return import_path7.default.resolve(this.path, "../bin/tsc");
  }
  get tsServerPath() {
    return import_path7.default.resolve(this.path, "tsserver.js");
  }
  get pathLabel() {
    return typeof this._pathLabel === "undefined" ? this.path : this._pathLabel;
  }
  get isValid() {
    return this.version != null;
  }
  get version() {
    if (this._api)
      return this._api;
    let api = this._api = this.getTypeScriptVersion(this.tsServerPath);
    return api;
  }
  get versionString() {
    const version = this.version;
    return version ? version.versionString : null;
  }
  getTypeScriptVersion(serverPath) {
    if (!import_fs3.default.existsSync(serverPath)) {
      return void 0;
    }
    const p = serverPath.split(import_path7.default.sep);
    if (p.length <= 2) {
      return void 0;
    }
    const p2 = p.slice(0, -2);
    const modulePath = p2.join(import_path7.default.sep);
    let fileName = import_path7.default.join(modulePath, "package.json");
    if (!import_fs3.default.existsSync(fileName)) {
      if (import_path7.default.basename(modulePath) === "built") {
        fileName = import_path7.default.join(modulePath, "..", "package.json");
      }
    }
    if (!import_fs3.default.existsSync(fileName)) {
      return void 0;
    }
    const contents = import_fs3.default.readFileSync(fileName).toString();
    let desc = null;
    try {
      desc = JSON.parse(contents);
    } catch (err) {
      return void 0;
    }
    if (!desc || !desc.version) {
      return void 0;
    }
    return desc.version ? API.fromVersionString(desc.version) : void 0;
  }
};
var MODULE_FOLDERS = ["node_modules/typescript/lib", ".vscode/pnpify/typescript/lib", ".yarn/sdks/typescript/lib"];
var TypeScriptVersionProvider = class {
  constructor(configuration) {
    this.configuration = configuration;
  }
  updateConfiguration(configuration) {
    this.configuration = configuration;
  }
  getDefaultVersion() {
    let { globalTsdk } = this.configuration;
    if (globalTsdk)
      return new TypeScriptVersion(globalTsdk);
    return this.bundledVersion;
  }
  get globalVersion() {
    let { globalTsdk } = this.configuration;
    if (globalTsdk)
      return new TypeScriptVersion(import_coc34.workspace.expand(globalTsdk));
    return void 0;
  }
  getVersionFromTscPath(tscPath) {
    if (!tscPath || !import_fs3.default.existsSync(tscPath))
      return void 0;
    let libFolder = import_path7.default.resolve(tscPath, "../../lib");
    if (import_fs3.default.existsSync(libFolder)) {
      let version = new TypeScriptVersion(libFolder);
      if (version.isValid)
        return version;
    }
  }
  getLocalVersion() {
    let folders = import_coc34.workspace.workspaceFolders.map((f) => import_coc34.Uri.parse(f.uri).fsPath);
    for (let p of folders) {
      for (let folder of MODULE_FOLDERS) {
        let libFolder = import_path7.default.join(p, folder);
        if (import_fs3.default.existsSync(libFolder)) {
          let version = new TypeScriptVersion(libFolder);
          if (version.isValid)
            return version;
        }
      }
    }
    return null;
  }
  get bundledVersion() {
    try {
      const file2 = require.resolve("typescript");
      const bundledVersion = new TypeScriptVersion(import_path7.default.dirname(file2), "");
      return bundledVersion;
    } catch (e) {
      import_coc34.window.showMessage("Bundled typescript module not found", "error");
      return null;
    }
  }
};

// src/server/utils/versionStatus.ts
var import_coc35 = require("coc.nvim");
var VersionStatus = class {
  constructor(_normalizePath, enableJavascript) {
    this._normalizePath = _normalizePath;
    this.enableJavascript = enableJavascript;
    this._versionString = "";
    this._versionBarEntry = import_coc35.window.createStatusBarItem(99);
    this._onChangeEditorSub = import_coc35.events.on("BufEnter", this.onBufEnter, this);
    this._versionBarEntry.show();
  }
  dispose() {
    this._versionBarEntry.dispose();
    this._onChangeEditorSub.dispose();
  }
  onDidChangeTypeScriptVersion(version) {
    this._versionString = version.versionString;
  }
  set loading(isLoading) {
    if (isLoading) {
      this._versionBarEntry.text = `Initializing tsserver ${this._versionString}`;
    } else {
      this._versionBarEntry.text = `TSC ${this._versionString}`;
    }
    this._versionBarEntry.isProgress = isLoading;
  }
  checkFiletype(filetype) {
    if (filetype.startsWith("javascript") && this.enableJavascript) {
      return true;
    }
    return filetype.startsWith("typescript");
  }
  async onBufEnter(bufnr) {
    let filetype = await import_coc35.workspace.nvim.call("getbufvar", [bufnr, "&filetype", ""]);
    if (this.checkFiletype(filetype)) {
      this._versionBarEntry.show();
    } else {
      this._versionBarEntry.hide();
    }
  }
};

// src/server/utils/wireProtocol.ts
var import_coc36 = require("coc.nvim");
var import_vscode_languageserver_protocol20 = __toESM(require_main2());
var DefaultSize = 8192;
var ContentLength = "Content-Length: ";
var ContentLengthSize = Buffer.byteLength(ContentLength, "utf8");
var Blank = Buffer.from(" ", "utf8")[0];
var BackslashR = Buffer.from("\r", "utf8")[0];
var BackslashN = Buffer.from("\n", "utf8")[0];
var ProtocolBuffer = class {
  constructor() {
    this.index = 0;
    this.buffer = Buffer.allocUnsafe(DefaultSize);
  }
  append(data) {
    let toAppend = null;
    if (Buffer.isBuffer(data)) {
      toAppend = data;
    } else {
      toAppend = Buffer.from(data, "utf8");
    }
    if (this.buffer.length - this.index >= toAppend.length) {
      toAppend.copy(this.buffer, this.index, 0, toAppend.length);
    } else {
      let newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
      if (this.index === 0) {
        this.buffer = Buffer.allocUnsafe(newSize);
        toAppend.copy(this.buffer, 0, 0, toAppend.length);
      } else {
        this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
      }
    }
    this.index += toAppend.length;
  }
  tryReadContentLength() {
    let result = -1;
    let current = 0;
    while (current < this.index && (this.buffer[current] === Blank || this.buffer[current] === BackslashR || this.buffer[current] === BackslashN)) {
      current++;
    }
    if (this.index < current + ContentLengthSize) {
      return result;
    }
    current += ContentLengthSize;
    let start = current;
    while (current < this.index && this.buffer[current] !== BackslashR) {
      current++;
    }
    if (current + 3 >= this.index || this.buffer[current + 1] !== BackslashN || this.buffer[current + 2] !== BackslashR || this.buffer[current + 3] !== BackslashN) {
      return result;
    }
    let data = this.buffer.toString("utf8", start, current);
    result = parseInt(data, 10);
    this.buffer = this.buffer.slice(current + 4);
    this.index = this.index - (current + 4);
    return result;
  }
  tryReadContent(length) {
    if (this.index < length) {
      return null;
    }
    let result = this.buffer.toString("utf8", 0, length);
    let sourceStart = length;
    while (sourceStart < this.index && (this.buffer[sourceStart] === BackslashR || this.buffer[sourceStart] === BackslashN)) {
      sourceStart++;
    }
    this.buffer.copy(this.buffer, 0, sourceStart);
    this.index = this.index - sourceStart;
    return result;
  }
};
var Reader = class {
  constructor(readable) {
    this.buffer = new ProtocolBuffer();
    this.nextMessageLength = -1;
    this.disposables = [];
    this._onError = new import_vscode_languageserver_protocol20.Emitter();
    this.onError = this._onError.event;
    this._onData = new import_vscode_languageserver_protocol20.Emitter();
    this.onData = this._onData.event;
    const onData = (data) => {
      this.onLengthData(data);
    };
    readable.on("data", onData);
    this.disposables.push({
      dispose: () => {
        readable.off("data", onData);
      }
    });
    this.disposables.push(this._onError);
    this.disposables.push(this._onData);
  }
  onLengthData(data) {
    try {
      this.buffer.append(data);
      while (true) {
        if (this.nextMessageLength === -1) {
          this.nextMessageLength = this.buffer.tryReadContentLength();
          if (this.nextMessageLength === -1) {
            return;
          }
        }
        const msg = this.buffer.tryReadContent(this.nextMessageLength);
        if (msg === null) {
          return;
        }
        this.nextMessageLength = -1;
        const json = JSON.parse(msg);
        this._onData.fire(json);
      }
    } catch (e) {
      this._onError.fire(e);
    }
  }
  dispose() {
    (0, import_coc36.disposeAll)(this.disposables);
  }
};

// src/server/tsServerProcess.ts
var ForkedTsServerProcess = class {
  constructor(childProcess) {
    this.childProcess = childProcess;
    this.toCancelOnResourceChange = /* @__PURE__ */ new Set();
    this._reader = new Reader(this.childProcess.stdout);
  }
  onExit(cb) {
    this.childProcess.on("exit", cb);
  }
  write(serverRequest) {
    this.childProcess.stdin.write(JSON.stringify(serverRequest) + "\r\n", "utf8");
  }
  onData(handler) {
    this._reader.onData(handler);
  }
  onError(handler) {
    this.childProcess.on("error", handler);
    this._reader.onError(handler);
  }
  kill() {
    this.toCancelOnResourceChange.clear();
    this.childProcess.kill();
    this._reader.dispose();
  }
  dispose() {
    this.toCancelOnResourceChange.clear();
    this._reader.dispose();
  }
};

// src/server/typescriptServiceClient.ts
var TypeScriptServiceClient = class {
  constructor(pluginManager, modeIds, tscPathVim) {
    this.pluginManager = pluginManager;
    this.modeIds = modeIds;
    this.tscPathVim = tscPathVim;
    this.token = 0;
    this.noRestart = false;
    this.state = import_coc37.ServiceStat.Initial;
    this.logger = new Logger();
    this.tsServerLogFile = null;
    this.cancellationPipeName = null;
    this._callbacks = new CallbackMap();
    this._requestQueue = new RequestQueue();
    this._pendingResponses = /* @__PURE__ */ new Set();
    this._onTsServerStarted = new import_vscode_languageserver_protocol21.Emitter();
    this._onProjectLanguageServiceStateChanged = new import_vscode_languageserver_protocol21.Emitter();
    this._onDidBeginInstallTypings = new import_vscode_languageserver_protocol21.Emitter();
    this._onDidEndInstallTypings = new import_vscode_languageserver_protocol21.Emitter();
    this._onTypesInstallerInitializationFailed = new import_vscode_languageserver_protocol21.Emitter();
    this.disposables = [];
    this.isRestarting = false;
    this._onDiagnosticsReceived = new import_vscode_languageserver_protocol21.Emitter();
    this._onConfigDiagnosticsReceived = new import_vscode_languageserver_protocol21.Emitter();
    this._onResendModelsRequested = new import_vscode_languageserver_protocol21.Emitter();
    this.pathSeparator = import_path8.default.sep;
    this.lastStart = Date.now();
    this.numberRestarts = 0;
    let resolve;
    let reject;
    const p = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    this._onReady = { promise: p, resolve, reject };
    this.fileConfigurationManager = new FileConfigurationManager(this);
    this._configuration = TypeScriptServiceConfiguration.loadFromWorkspace();
    this.versionProvider = new TypeScriptVersionProvider(this._configuration);
    this._apiVersion = API.defaultVersion;
    this.tracer = new Tracer(this.logger);
    this.versionStatus = new VersionStatus(this.normalizePath.bind(this), this.fileConfigurationManager.enableJavascript());
    pluginManager.onDidUpdateConfig((update) => {
      this.configurePlugin(update.pluginId, update.config);
    }, null, this.disposables);
    pluginManager.onDidChangePlugins(() => {
      this.restartTsServer();
    }, null, this.disposables);
    this.bufferSyncSupport = new BufferSyncSupport(this, modeIds);
    this.onReady(() => {
      this.bufferSyncSupport.listen();
    });
    this.diagnosticsManager = new DiagnosticsManager();
    this.bufferSyncSupport.onDelete((resource) => {
      this.cancelInflightRequestsForResource(resource);
      this.diagnosticsManager.delete(resource);
    }, null, this.disposables);
    this.bufferSyncSupport.onWillChange((resource) => {
      this.cancelInflightRequestsForResource(resource);
    });
  }
  get onDiagnosticsReceived() {
    return this._onDiagnosticsReceived.event;
  }
  get onConfigDiagnosticsReceived() {
    return this._onConfigDiagnosticsReceived.event;
  }
  get onResendModelsRequested() {
    return this._onResendModelsRequested.event;
  }
  get configuration() {
    return this._configuration;
  }
  onReady(f) {
    return this._onReady.promise.then(f);
  }
  dispose() {
    this.tsServerProcess.kill();
    this.diagnosticsManager.dispose();
    this.bufferSyncSupport.dispose();
    this.logger.dispose();
    this._onTsServerStarted.dispose();
    this._onProjectLanguageServiceStateChanged.dispose();
    this._onDidBeginInstallTypings.dispose();
    this._onDidEndInstallTypings.dispose();
    this._onTypesInstallerInitializationFailed.dispose();
    this._onResendModelsRequested.dispose();
    this.versionStatus.dispose();
  }
  info(message, data) {
    this.logger.info(message, data);
  }
  error(message, data) {
    this.logger.error(message, data);
  }
  restartTsServer() {
    if (this.tsServerProcess) {
      this.state = import_coc37.ServiceStat.Stopping;
      this.info("Killing TS Server");
      this.isRestarting = true;
      this.tsServerProcess.kill();
    }
    this.startService(true);
  }
  stop() {
    return new Promise((resolve) => {
      let { tsServerProcess } = this;
      if (tsServerProcess && this.state == import_coc37.ServiceStat.Running) {
        this.info("Killing TS Server");
        tsServerProcess.onExit(() => {
          resolve();
        });
        this.noRestart = true;
        tsServerProcess.kill();
      } else {
        resolve();
      }
    });
  }
  get onTsServerStarted() {
    return this._onTsServerStarted.event;
  }
  get onProjectLanguageServiceStateChanged() {
    return this._onProjectLanguageServiceStateChanged.event;
  }
  get onDidBeginInstallTypings() {
    return this._onDidBeginInstallTypings.event;
  }
  get onDidEndInstallTypings() {
    return this._onDidEndInstallTypings.event;
  }
  get onTypesInstallerInitializationFailed() {
    return this._onTypesInstallerInitializationFailed.event;
  }
  get apiVersion() {
    return this._apiVersion;
  }
  get tscPath() {
    return this._tscPath;
  }
  ensureServiceStarted() {
    if (!this.tsServerProcess) {
      this.startService();
    }
  }
  startService(resendModels = false) {
    const { ignoreLocalTsserver } = this.configuration;
    let currentVersion;
    if (this.tscPathVim)
      currentVersion = this.versionProvider.getVersionFromTscPath(this.tscPathVim);
    if (!currentVersion && !ignoreLocalTsserver)
      currentVersion = this.versionProvider.getLocalVersion();
    if (!currentVersion || !import_fs4.default.existsSync(currentVersion.tsServerPath)) {
      this.info("Local tsserver not found, using bundled tsserver with coc-tsserver.");
      currentVersion = this.versionProvider.getDefaultVersion();
    }
    if (!currentVersion || !currentVersion.isValid) {
      if (this.configuration.globalTsdk) {
        import_coc37.window.showErrorMessage(`Can not find typescript module, in 'tsserver.tsdk': ${this.configuration.globalTsdk}`);
      } else {
        import_coc37.window.showErrorMessage(`Can not find typescript module, run ':CocInstall coc-tsserver' to fix it!`);
      }
      return;
    }
    this._apiVersion = currentVersion.version;
    this._tscPath = currentVersion.tscPath;
    import_coc37.workspace.nvim.setVar("Tsserver_path", this._tscPath, true);
    this.versionStatus.onDidChangeTypeScriptVersion(currentVersion);
    const tsServerForkArgs = this.getTsServerArgs(currentVersion);
    const options = { execArgv: this.getExecArgv() };
    return this.startProcess(currentVersion, tsServerForkArgs, options, resendModels);
  }
  getExecArgv() {
    const args = [];
    const debugPort = getDebugPort();
    if (debugPort) {
      const isBreak = process.env[process.env.remoteName ? "TSS_REMOTE_DEBUG_BRK" : "TSS_DEBUG_BRK"] !== void 0;
      const inspectFlag = isBreak ? "--inspect-brk" : "--inspect";
      args.push(`${inspectFlag}=${debugPort}`);
    }
    const maxTsServerMemory = this._configuration.maxTsServerMemory;
    if (maxTsServerMemory) {
      args.push(`--max-old-space-size=${maxTsServerMemory}`);
    }
    return args;
  }
  startProcess(currentVersion, args, options, resendModels) {
    const myToken = ++this.token;
    this.state = import_coc37.ServiceStat.Starting;
    try {
      let childProcess = fork(currentVersion.tsServerPath, args, options, this.logger);
      this.state = import_coc37.ServiceStat.Running;
      this.info("Starting TSServer", JSON.stringify(currentVersion, null, 2));
      const handle = new ForkedTsServerProcess(childProcess);
      this.tsServerProcess = handle;
      this.lastStart = Date.now();
      handle.onError((err) => {
        if (this.token != myToken)
          return;
        import_coc37.window.showErrorMessage(`TypeScript language server exited with error. Error message is: ${err.message}`);
        this.error("TSServer errored with error.", err);
        this.error(`TSServer log file: ${this.tsServerLogFile || ""}`);
        import_coc37.window.showMessage(`TSServer errored with error. ${err.message}`, "error");
        this.serviceExited(false);
      });
      handle.onExit((code, signal) => {
        handle.dispose();
        if (this.token != myToken)
          return;
        if (code == null) {
          this.info(`TSServer exited. Signal: ${signal}`);
        } else {
          this.error(`TSServer exited with code: ${code}. Signal: ${signal}`);
        }
        this.info(`TSServer log file: ${this.tsServerLogFile || ""}`);
        this.serviceExited(!this.isRestarting);
        this.isRestarting = false;
      });
      handle.onData((msg) => {
        this.dispatchMessage(msg);
      });
      this.serviceStarted(resendModels);
      this._onReady.resolve();
      this._onTsServerStarted.fire(currentVersion.version);
      return handle;
    } catch (err) {
      this.state = import_coc37.ServiceStat.StartFailed;
      this.error("Starting TSServer failed with error.", err.stack);
      return void 0;
    }
  }
  async openTsServerLogFile() {
    const isRoot = process.getuid && process.getuid() == 0;
    let echoErr = (msg) => {
      import_coc37.window.showErrorMessage(msg);
    };
    if (isRoot) {
      echoErr("Log disabled for root user.");
      return false;
    }
    if (!this.apiVersion.gte(API.v222)) {
      echoErr("TS Server logging requires TS 2.2.2+");
      return false;
    }
    if (this._configuration.tsServerLogLevel === 0 /* Off */) {
      echoErr(`TS Server logging is off. Change 'tsserver.log' in 'coc-settings.json' to enable`);
      return false;
    }
    if (!this.tsServerLogFile) {
      echoErr("TS Server has not started logging.");
      return false;
    }
    try {
      await import_coc37.workspace.nvim.command(`edit ${this.tsServerLogFile}`);
      return true;
    } catch {
      echoErr("Could not open TS Server log file");
      return false;
    }
  }
  serviceStarted(resendModels) {
    this.bufferSyncSupport.reset();
    const watchOptions = this.apiVersion.gte(API.v380) ? this.configuration.watchOptions : void 0;
    const configureOptions = {
      hostInfo: "coc-nvim",
      preferences: {
        providePrefixAndSuffixTextForRename: true,
        allowRenameOfImportPath: true,
        includePackageJsonAutoImports: this._configuration.includePackageJsonAutoImports
      },
      watchOptions
    };
    this.executeWithoutWaitingForResponse("configure", configureOptions);
    this.setCompilerOptionsForInferredProjects(this._configuration);
    if (resendModels) {
      this._onResendModelsRequested.fire(void 0);
      this.fileConfigurationManager.reset();
      this.diagnosticsManager.reInitialize();
      this.bufferSyncSupport.reinitialize();
    }
    for (const [config, pluginName] of this.pluginManager.configurations()) {
      this.configurePlugin(config, pluginName);
    }
  }
  setCompilerOptionsForInferredProjects(configuration) {
    if (!this.apiVersion.gte(API.v206))
      return;
    const args = {
      options: this.getCompilerOptionsForInferredProjects(configuration)
    };
    this.executeWithoutWaitingForResponse("compilerOptionsForInferredProjects", args);
  }
  getCompilerOptionsForInferredProjects(configuration) {
    return __spreadProps(__spreadValues({}, inferredProjectConfig(configuration)), {
      allowJs: true,
      allowSyntheticDefaultImports: true,
      allowNonTsExtensions: true
    });
  }
  serviceExited(restart) {
    this.state = import_coc37.ServiceStat.Stopped;
    this.tsServerLogFile = null;
    this._callbacks.destroy("Service died.");
    this._callbacks = new CallbackMap();
    this._requestQueue = new RequestQueue();
    this._pendingResponses = /* @__PURE__ */ new Set();
    if (this.noRestart) {
      this.noRestart = false;
      return;
    }
    if (restart) {
      const diff = Date.now() - this.lastStart;
      this.numberRestarts++;
      let startService = true;
      if (this.numberRestarts > 5) {
        this.numberRestarts = 0;
        if (diff < 10 * 1e3) {
          this.lastStart = Date.now();
          startService = false;
          import_coc37.window.showMessage("The TypeScript language service died 5 times right after it got started.", "error");
        } else if (diff < 60 * 1e3) {
          this.lastStart = Date.now();
          import_coc37.window.showMessage("The TypeScript language service died unexpectedly 5 times in the last 5 Minutes.", "error");
        }
      }
      if (startService) {
        this.startService(true);
      }
    }
  }
  toPath(uri) {
    return this.normalizePath(import_coc37.Uri.parse(uri));
  }
  toOpenedFilePath(uri, options = {}) {
    if (!this.bufferSyncSupport.ensureHasBuffer(uri)) {
      if (!options.suppressAlertOnFailure) {
        this.error(`Unexpected resource ${uri}`);
      }
      return void 0;
    }
    return this.toPath(uri);
  }
  toResource(filepath) {
    if (filepath.includes("zipfile:")) {
      return filepath.replace(/.*zipfile:/, "zipfile://");
    }
    if (this._apiVersion.gte(API.v213)) {
      if (filepath.startsWith(this.inMemoryResourcePrefix + "untitled:")) {
        let resource = import_coc37.Uri.parse(filepath);
        if (this.inMemoryResourcePrefix) {
          const dirName = import_path8.default.dirname(resource.path);
          const fileName = import_path8.default.basename(resource.path);
          if (fileName.startsWith(this.inMemoryResourcePrefix)) {
            resource = resource.with({ path: import_path8.default.posix.join(dirName, fileName.slice(this.inMemoryResourcePrefix.length)) });
          }
        }
        return resource.toString();
      }
    }
    return import_coc37.Uri.file(filepath).toString();
  }
  normalizePath(resource) {
    if (disabledSchemes.has(resource.scheme)) {
      return void 0;
    }
    switch (resource.scheme) {
      case file: {
        let result = resource.fsPath;
        if (!result)
          return void 0;
        result = import_path8.default.normalize(result);
        return result.replace(new RegExp("\\" + this.pathSeparator, "g"), "/");
      }
      default: {
        return this.inMemoryResourcePrefix + resource.toString(true);
      }
    }
  }
  getDocument(resource) {
    if (resource.startsWith("untitled:")) {
      let bufnr = parseInt(resource.split(":", 2)[1], 10);
      return import_coc37.workspace.getDocument(bufnr);
    }
    return import_coc37.workspace.getDocument(resource);
  }
  get inMemoryResourcePrefix() {
    return this._apiVersion.gte(API.v270) ? "^" : "";
  }
  asUrl(filepath) {
    if (this._apiVersion.gte(API.v213)) {
      if (filepath.startsWith(this.inMemoryResourcePrefix + "untitled:")) {
        let resource = import_coc37.Uri.parse(filepath.slice(this.inMemoryResourcePrefix.length));
        if (this.inMemoryResourcePrefix) {
          const dirName = import_path8.default.dirname(resource.path);
          const fileName = import_path8.default.basename(resource.path);
          if (fileName.startsWith(this.inMemoryResourcePrefix)) {
            resource = resource.with({
              path: import_path8.default.posix.join(dirName, fileName.slice(this.inMemoryResourcePrefix.length))
            });
          }
        }
        return resource;
      }
    }
    return import_coc37.Uri.file(filepath);
  }
  execute(command, args, token, config) {
    var _a;
    let execution;
    if (config == null ? void 0 : config.cancelOnResourceChange) {
      const source = new import_vscode_languageserver_protocol21.CancellationTokenSource();
      token.onCancellationRequested(() => source.cancel());
      const inFlight = {
        resource: config.cancelOnResourceChange,
        cancel: () => source.cancel()
      };
      (_a = this.tsServerProcess) == null ? void 0 : _a.toCancelOnResourceChange.add(inFlight);
      execution = this.executeImpl(command, args, __spreadValues({
        isAsync: false,
        token: source.token,
        expectsResult: true
      }, config)).finally(() => {
        var _a2;
        (_a2 = this.tsServerProcess) == null ? void 0 : _a2.toCancelOnResourceChange.delete(inFlight);
        source.dispose();
      });
    } else {
      execution = this.executeImpl(command, args, __spreadValues({
        isAsync: false,
        token,
        expectsResult: true
      }, config));
    }
    if (config == null ? void 0 : config.nonRecoverable) {
      execution.catch((err) => this.fatalError(command, err));
    }
    return execution;
  }
  fatalError(command, error) {
    this.error(`A non-recoverable error occured while executing tsserver command: ${command}`);
    if (this.state === import_coc37.ServiceStat.Running) {
      this.info("Killing TS Server by fatal error:", error);
      let { tsServerProcess } = this;
      if (tsServerProcess) {
        this.tsServerProcess = void 0;
        tsServerProcess.kill();
      }
    }
  }
  executeAsync(command, args, token) {
    return this.executeImpl(command, args, {
      isAsync: true,
      token,
      expectsResult: true
    });
  }
  executeWithoutWaitingForResponse(command, args) {
    this.executeImpl(command, args, {
      isAsync: false,
      token: void 0,
      expectsResult: false
    });
  }
  executeImpl(command, args, executeInfo) {
    if (!this.tsServerProcess) {
      return Promise.resolve(void 0);
    }
    this.bufferSyncSupport.beforeCommand(command);
    const request = this._requestQueue.createRequest(command, args);
    const requestInfo = {
      request,
      expectsResponse: executeInfo.expectsResult,
      isAsync: executeInfo.isAsync,
      queueingType: getQueueingType(command, executeInfo.lowPriority)
    };
    let result;
    if (executeInfo.expectsResult) {
      result = new Promise((resolve, reject) => {
        this._callbacks.add(request.seq, { onSuccess: resolve, onError: reject, startTime: Date.now(), isAsync: executeInfo.isAsync }, executeInfo.isAsync);
        if (executeInfo.token) {
          executeInfo.token.onCancellationRequested(() => {
            this.tryCancelRequest(request.seq, command);
          });
        }
      }).catch((err) => {
        throw err;
      });
    }
    this._requestQueue.enqueue(requestInfo);
    this.sendNextRequests();
    return result;
  }
  sendNextRequests() {
    while (this._pendingResponses.size === 0 && this._requestQueue.length > 0) {
      const item = this._requestQueue.dequeue();
      if (item) {
        this.sendRequest(item);
      }
    }
  }
  sendRequest(requestItem) {
    const serverRequest = requestItem.request;
    this.tracer.traceRequest(serverRequest, requestItem.expectsResponse, this._requestQueue.length);
    if (requestItem.expectsResponse && !requestItem.isAsync) {
      this._pendingResponses.add(requestItem.request.seq);
    }
    if (!this.tsServerProcess)
      return;
    try {
      this.tsServerProcess.write(serverRequest);
    } catch (err) {
      const callback = this.fetchCallback(serverRequest.seq);
      if (callback) {
        callback.onError(err);
      }
    }
  }
  tryCancelRequest(seq, command) {
    try {
      if (this._requestQueue.tryDeletePendingRequest(seq)) {
        this.tracer.logTrace(`TypeScript Server: canceled request with sequence number ${seq}`);
        return true;
      }
      if (this.cancellationPipeName) {
        this.tracer.logTrace(`TypeScript Server: trying to cancel ongoing request with sequence number ${seq}`);
        try {
          import_fs4.default.writeFileSync(this.cancellationPipeName + seq, "");
        } catch {
        }
        return true;
      }
      this.tracer.logTrace(`TypeScript Server: tried to cancel request with sequence number ${seq}. But request got already delivered.`);
      return false;
    } finally {
      const callback = this.fetchCallback(seq);
      if (callback) {
        callback.onSuccess(new ServerResponse.Cancelled(`Cancelled request ${seq} - ${command}`));
      }
    }
  }
  fetchCallback(seq) {
    const callback = this._callbacks.fetch(seq);
    if (!callback) {
      return void 0;
    }
    this._pendingResponses.delete(seq);
    return callback;
  }
  dispatchMessage(message) {
    try {
      switch (message.type) {
        case "response":
          this.dispatchResponse(message);
          break;
        case "event":
          const event = message;
          if (event.event === "requestCompleted") {
            const seq = event.body.request_seq;
            const p = this._callbacks.fetch(seq);
            if (p) {
              this.tracer.traceRequestCompleted("requestCompleted", seq, p.startTime);
              p.onSuccess(void 0);
            }
          } else {
            this.tracer.traceEvent(event);
            this.dispatchEvent(event);
          }
          break;
        default:
          throw new Error(`Unknown message type ${message.type} received`);
      }
    } finally {
      this.sendNextRequests();
    }
  }
  dispatchResponse(response) {
    const callback = this.fetchCallback(response.request_seq);
    if (!callback) {
      return;
    }
    this.tracer.traceResponse(response, callback.startTime);
    if (response.success) {
      callback.onSuccess(response);
    } else if (response.message === "No content available.") {
      callback.onSuccess(ServerResponse.NoContent);
    } else {
      callback.onError(new Error(response.message));
    }
  }
  dispatchEvent(event) {
    switch (event.event) {
      case "syntaxDiag":
      case "semanticDiag":
      case "suggestionDiag":
        const diagnosticEvent = event;
        if (diagnosticEvent.body && diagnosticEvent.body.diagnostics) {
          this._onDiagnosticsReceived.fire({
            kind: getDiagnosticsKind(event),
            resource: this.asUrl(diagnosticEvent.body.file),
            diagnostics: diagnosticEvent.body.diagnostics
          });
        }
        break;
      case "configFileDiag":
        this._onConfigDiagnosticsReceived.fire(event);
        break;
      case "projectLanguageServiceState":
        if (event.body) {
          this._onProjectLanguageServiceStateChanged.fire(event.body);
        }
        break;
      case "beginInstallTypes":
        if (event.body) {
          this._onDidBeginInstallTypings.fire(event.body);
        }
        break;
      case "endInstallTypes":
        if (event.body) {
          this._onDidEndInstallTypings.fire(event.body);
        }
        break;
      case "projectsUpdatedInBackground":
        const body = event.body;
        const resources = body.openFiles.map(import_coc37.Uri.file);
        this.bufferSyncSupport.getErr(resources);
        break;
      case "typesInstallerInitializationFailed":
        if (event.body) {
          this._onTypesInstallerInitializationFailed.fire(event.body);
        }
        break;
      case "projectLoadingStart":
        this.versionStatus.loading = true;
        break;
      case "projectLoadingFinish":
        this.versionStatus.loading = false;
        break;
    }
  }
  getTsServerArgs(currentVersion) {
    const args = [];
    args.push("--allowLocalPluginLoads");
    if (this.apiVersion.gte(API.v250)) {
      args.push("--useInferredProjectPerProjectRoot");
    } else {
      args.push("--useSingleInferredProject");
    }
    if (this.apiVersion.gte(API.v206) && this._configuration.disableAutomaticTypeAcquisition) {
      args.push("--disableAutomaticTypingAcquisition");
    }
    if (this.apiVersion.gte(API.v222)) {
      this.cancellationPipeName = getTempFile(`tscancellation-${makeRandomHexString(20)}`);
      args.push("--cancellationPipeName", this.cancellationPipeName + "*");
    }
    const logDir = getTempDirectory();
    if (this.apiVersion.gte(API.v222)) {
      const isRoot = process.getuid && process.getuid() == 0;
      if (this._configuration.tsServerLogLevel !== 0 /* Off */ && !isRoot) {
        if (logDir) {
          this.tsServerLogFile = import_path8.default.join(logDir, `tsserver.log`);
          this.info("TSServer log file :", this.tsServerLogFile);
        } else {
          this.tsServerLogFile = null;
          this.error("Could not create TSServer log directory");
        }
        if (this.tsServerLogFile) {
          args.push("--logVerbosity", TsServerLogLevel.toString(this._configuration.tsServerLogLevel));
          args.push("--logFile", this.tsServerLogFile);
        }
      }
    }
    if (this._configuration.enableTsServerTracing) {
      let tsServerTraceDirectory = createTempDirectory(`tsserver-trace-${makeRandomHexString(5)}`);
      if (tsServerTraceDirectory) {
        args.push("--traceDirectory", tsServerTraceDirectory);
        this.info("TSServer trace directory :", tsServerTraceDirectory);
      } else {
        this.error("Could not create TSServer trace directory");
      }
    }
    if (this.apiVersion.gte(API.v230)) {
      const pluginNames = this.pluginManager.plugins.map((x) => x.name);
      let pluginPaths = this._configuration.tsServerPluginPaths;
      pluginPaths = pluginPaths.reduce((p, c) => {
        if (import_path8.default.isAbsolute(c)) {
          p.push(c);
        } else {
          let roots = import_coc37.workspace.workspaceFolders.map((o) => import_coc37.Uri.parse(o.uri).fsPath);
          p.push(...roots.map((r) => import_path8.default.join(r, c)));
        }
        return p;
      }, []);
      if (pluginNames.length) {
        const isUsingBundledTypeScriptVersion = currentVersion.path == this.versionProvider.bundledVersion.path;
        args.push("--globalPlugins", pluginNames.join(","));
        for (const plugin of this.pluginManager.plugins) {
          if (isUsingBundledTypeScriptVersion || plugin.enableForWorkspaceTypeScriptVersions) {
            pluginPaths.push(plugin.path);
          }
        }
      }
      if (pluginPaths.length) {
        args.push("--pluginProbeLocations", pluginPaths.join(","));
      }
    }
    if (this._configuration.locale) {
      args.push("--locale", this._configuration.locale);
    }
    if (this._configuration.typingsCacheLocation) {
      args.push("--globalTypingsCacheLocation", `"${this._configuration.typingsCacheLocation}"`);
    }
    if (this.apiVersion.gte(API.v234)) {
      let { npmLocation } = this._configuration;
      if (npmLocation) {
        this.logger.info(`using npm from ${npmLocation}`);
        args.push("--npmLocation", `"${npmLocation}"`);
      }
    }
    if (this.apiVersion.gte(API.v291)) {
      args.push("--noGetErrOnBackgroundUpdate");
    }
    if (this.apiVersion.gte(API.v345)) {
      args.push("--validateDefaultNpmLocation");
    }
    return args;
  }
  getProjectRootPath(uri) {
    let root = import_coc37.workspace.cwd;
    let u = import_coc37.Uri.parse(uri);
    if (u.scheme !== "file")
      return void 0;
    let folder = import_coc37.workspace.getWorkspaceFolder(uri);
    if (folder) {
      root = import_coc37.Uri.parse(folder.uri).fsPath;
    } else {
      let filepath = import_coc37.Uri.parse(uri).fsPath;
      if (!filepath.startsWith(root)) {
        root = import_path8.default.dirname(filepath);
      }
    }
    if (root == import_os2.default.homedir())
      return void 0;
    return root;
  }
  configurePlugin(pluginName, configuration) {
    if (this.apiVersion.gte(API.v314)) {
      if (!this.tsServerProcess)
        return;
      this.executeWithoutWaitingForResponse("configurePlugin", { pluginName, configuration });
    }
  }
  interruptGetErr(f) {
    return this.bufferSyncSupport.interuptGetErr(f);
  }
  cancelInflightRequestsForResource(resource) {
    if (this.state !== import_coc37.ServiceStat.Running || !this.tsServerProcess) {
      return;
    }
    for (const request of this.tsServerProcess.toCancelOnResourceChange) {
      if (request.resource.toString() === resource.toString()) {
        request.cancel();
      }
    }
  }
};
function getDiagnosticsKind(event) {
  switch (event.event) {
    case "syntaxDiag":
      return 0 /* Syntax */;
    case "semanticDiag":
      return 1 /* Semantic */;
    case "suggestionDiag":
      return 2 /* Suggestion */;
  }
  throw new Error("Unknown dignostics kind");
}
var fenceCommands = /* @__PURE__ */ new Set(["change", "close", "open"]);
function getQueueingType(command, lowPriority) {
  if (fenceCommands.has(command)) {
    return 3 /* Fence */;
  }
  return lowPriority ? 2 /* LowPriority */ : 1 /* Normal */;
}
function getDebugPort() {
  let debugBrk = process.env[process.env.remoteName ? "TSS_REMOTE_DEBUG_BRK" : "TSS_DEBUG_BRK"];
  let value = debugBrk || process.env[process.env.remoteName ? "TSS_REMOTE_DEBUG_BRK" : "TSS_DEBUG_BRK"];
  if (value) {
    const port = parseInt(value);
    if (!isNaN(port)) {
      return port;
    }
  }
  return void 0;
}

// src/server/utils/languageDescription.ts
var standardLanguageDescriptions = [
  {
    id: "typescript",
    diagnosticSource: "ts",
    diagnosticOwner: "typescript",
    diagnosticLanguage: 1 /* TypeScript */,
    languageIds: [typescript, typescriptreact, typescripttsx, typescriptjsx],
    configFilePattern: /^tsconfig(\..*)?\.json$/gi,
    standardFileExtensions: [
      "ts",
      "tsx",
      "cts",
      "mts"
    ]
  },
  {
    id: "javascript",
    diagnosticSource: "ts",
    diagnosticOwner: "typescript",
    languageIds: [javascript, javascriptreact, javascriptjsx],
    diagnosticLanguage: 0 /* JavaScript */,
    configFilePattern: /^jsconfig(\..*)?\.json$/gi,
    standardFileExtensions: [
      "js",
      "jsx",
      "cjs",
      "mjs",
      "es6",
      "pac"
    ]
  }
];

// src/server/utils/typingsStatus.ts
var import_coc38 = require("coc.nvim");
var import_vscode_languageserver_protocol22 = __toESM(require_main2());
var typingsInstallTimeout = 30 * 1e3;
var TypingsStatus = class {
  constructor(client) {
    this._acquiringTypings = /* @__PURE__ */ Object.create({});
    this._subscriptions = [];
    this._client = client;
    this._subscriptions.push(this._client.onDidBeginInstallTypings((event) => this.onBeginInstallTypings(event.eventId)));
    this._subscriptions.push(this._client.onDidEndInstallTypings((event) => this.onEndInstallTypings(event.eventId)));
  }
  dispose() {
    this._subscriptions.forEach((x) => x.dispose());
    for (const eventId of Object.keys(this._acquiringTypings)) {
      clearTimeout(this._acquiringTypings[eventId]);
    }
  }
  get isAcquiringTypings() {
    return Object.keys(this._acquiringTypings).length > 0;
  }
  onBeginInstallTypings(eventId) {
    if (this._acquiringTypings[eventId]) {
      return;
    }
    this._acquiringTypings[eventId] = setTimeout(() => {
      this.onEndInstallTypings(eventId);
    }, typingsInstallTimeout);
  }
  onEndInstallTypings(eventId) {
    const timer = this._acquiringTypings[eventId];
    if (timer) {
      clearTimeout(timer);
    }
    delete this._acquiringTypings[eventId];
  }
};
var AtaProgressReporter = class {
  constructor(client) {
    this._promises = /* @__PURE__ */ new Map();
    this._invalid = false;
    this.statusItem = import_coc38.window.createStatusBarItem(10, { progress: true });
    const disposables = [];
    disposables.push(client.onDidBeginInstallTypings((e) => this._onBegin(e.eventId)));
    disposables.push(client.onDidEndInstallTypings((e) => this._onEndOrTimeout(e.eventId)));
    disposables.push(client.onTypesInstallerInitializationFailed((_) => this.onTypesInstallerInitializationFailed()));
    this._disposable = import_vscode_languageserver_protocol22.Disposable.create(() => {
      disposables.forEach((disposable) => {
        disposable.dispose();
      });
    });
  }
  dispose() {
    this._disposable.dispose();
    this._promises.forEach((value) => value());
  }
  _onBegin(eventId) {
    const handle = setTimeout(() => this._onEndOrTimeout(eventId), typingsInstallTimeout);
    new Promise((resolve) => {
      this._promises.set(eventId, () => {
        clearTimeout(handle);
        resolve();
      });
    });
    this.statusItem.text = "Fetching data for better TypeScript IntelliSense";
    this.statusItem.show();
  }
  _onEndOrTimeout(eventId) {
    this.statusItem.hide();
    const resolve = this._promises.get(eventId);
    if (resolve) {
      this._promises.delete(eventId);
      resolve();
    }
  }
  async onTypesInstallerInitializationFailed() {
    this.statusItem.hide();
    if (!this._invalid) {
      const config = import_coc38.workspace.getConfiguration("typescript");
      if (config.get("check.npmIsInstalled", true)) {
        const dontShowAgain = "Don't Show Again";
        const selected = await import_coc38.window.showWarningMessage("Could not install typings files for JavaScript language features. Please ensure that NPM is installed or configure 'typescript.npm' in your user settings. visit https://go.microsoft.com/fwlink/?linkid=847635  to learn more.", dontShowAgain);
        if (selected === dontShowAgain) {
          config.update("check.npmIsInstalled", false, true);
        }
      }
    }
    this._invalid = true;
  }
};

// src/server/typescriptServiceClientHost.ts
var styleCheckDiagnostics = [
  6133,
  6138,
  6192,
  7027,
  7028,
  7029,
  7030
];
var TypeScriptServiceClientHost = class {
  constructor(descriptions, pluginManager, tscPath) {
    this.languagePerId = /* @__PURE__ */ new Map();
    this.disposables = [];
    this.reportStyleCheckAsWarnings = true;
    let timer;
    const handleProjectChange = () => {
      if (timer)
        clearTimeout(timer);
      timer = setTimeout(() => {
        this.triggerAllDiagnostics();
      }, 1500);
    };
    const configFileWatcher = import_coc39.workspace.createFileSystemWatcher("**/[tj]sconfig.json");
    this.disposables.push(configFileWatcher);
    configFileWatcher.onDidCreate(this.reloadProjects, this, this.disposables);
    configFileWatcher.onDidDelete(this.reloadProjects, this, this.disposables);
    configFileWatcher.onDidChange(handleProjectChange, this, this.disposables);
    const packageFileWatcher = import_coc39.workspace.createFileSystemWatcher("**/package.json");
    packageFileWatcher.onDidCreate(this.reloadProjects, this, this.disposables);
    packageFileWatcher.onDidChange(handleProjectChange, this, this.disposables);
    const allModeIds = this.getAllModeIds(descriptions, pluginManager);
    this.client = new TypeScriptServiceClient(pluginManager, allModeIds, tscPath);
    this.disposables.push(this.client);
    this.client.onDiagnosticsReceived(({ kind, resource, diagnostics }) => {
      this.diagnosticsReceived(kind, resource, diagnostics).catch((e) => {
        console.error(e);
      });
    }, null, this.disposables);
    this.disposables.push(new WatchProject(this.client));
    this.disposables.push(import_coc39.languages.registerWorkspaceSymbolProvider(new TypeScriptWorkspaceSymbolProvider(this.client, allModeIds)));
    this.client.onConfigDiagnosticsReceived((diag) => {
      let { body } = diag;
      if (body) {
        let { configFile, diagnostics } = body;
        let uri = import_coc39.Uri.file(configFile);
        if (diagnostics.length == 0) {
          this.client.diagnosticsManager.configFileDiagnosticsReceived(uri.toString(), []);
        } else {
          let diagnosticList = diagnostics.map((o) => {
            let { text, code, category, start, end } = o;
            let range;
            if (!start || !end) {
              range = import_vscode_languageserver_protocol23.Range.create(import_vscode_languageserver_protocol23.Position.create(0, 0), import_vscode_languageserver_protocol23.Position.create(0, 1));
            } else {
              range = import_vscode_languageserver_protocol23.Range.create(start.line - 1, start.offset - 1, end.line - 1, end.offset - 1);
            }
            let severity = category == "error" ? import_vscode_languageserver_protocol23.DiagnosticSeverity.Error : import_vscode_languageserver_protocol23.DiagnosticSeverity.Warning;
            return import_vscode_languageserver_protocol23.Diagnostic.create(range, text, severity, code);
          });
          this.client.diagnosticsManager.configFileDiagnosticsReceived(uri.toString(), diagnosticList);
        }
      }
    }, null, this.disposables);
    this.typingsStatus = new TypingsStatus(this.client);
    this.ataProgressReporter = new AtaProgressReporter(this.client);
    this.fileConfigurationManager = new FileConfigurationManager(this.client);
    for (const description of descriptions) {
      const manager = new LanguageProvider(this.client, this.fileConfigurationManager, description, this.typingsStatus);
      this.languagePerId.set(description.id, manager);
    }
    this.client.ensureServiceStarted();
    this.client.onReady(() => {
      const languageIds = /* @__PURE__ */ new Set();
      for (const plugin of pluginManager.plugins) {
        if (plugin.configNamespace && plugin.languages.length) {
          this.registerExtensionLanguageProvider({
            id: plugin.configNamespace,
            languageIds: Array.from(plugin.languages),
            diagnosticSource: "ts-plugin",
            diagnosticLanguage: 1 /* TypeScript */,
            diagnosticOwner: "typescript",
            standardFileExtensions: [],
            isExternal: true
          });
        } else {
          for (const language2 of plugin.languages) {
            languageIds.add(language2);
          }
        }
      }
      if (languageIds.size) {
        this.registerExtensionLanguageProvider({
          id: "typescript-plugins",
          languageIds: Array.from(languageIds.values()),
          diagnosticSource: "ts-plugin",
          diagnosticLanguage: 1 /* TypeScript */,
          diagnosticOwner: "typescript",
          standardFileExtensions: [],
          isExternal: true
        });
      }
    });
    this.client.onTsServerStarted(() => {
      this.triggerAllDiagnostics();
    });
    import_coc39.workspace.onDidChangeConfiguration(this.configurationChanged, this, this.disposables);
    this.configurationChanged();
  }
  registerExtensionLanguageProvider(description) {
    const manager = new LanguageProvider(this.client, this.fileConfigurationManager, description, this.typingsStatus);
    this.languagePerId.set(description.id, manager);
  }
  dispose() {
    (0, import_coc39.disposeAll)(this.disposables);
    for (let language2 of this.languagePerId.values()) {
      language2.dispose();
    }
    this.languagePerId.clear();
    this.fileConfigurationManager.dispose();
    this.typingsStatus.dispose();
    this.ataProgressReporter.dispose();
  }
  get serviceClient() {
    return this.client;
  }
  reloadProjects() {
    this.client.diagnosticsManager.reInitialize();
    this.client.execute("reloadProjects", null, import_vscode_languageserver_protocol23.CancellationToken.None);
    this.triggerAllDiagnostics();
  }
  getProvider(languageId) {
    return this.languagePerId.get(languageId);
  }
  configurationChanged(e) {
    if (!e || e.affectsConfiguration("tsserver")) {
      const config = import_coc39.workspace.getConfiguration("tsserver");
      this.reportStyleCheckAsWarnings = config.get("reportStyleChecksAsWarnings", true);
    }
  }
  async findLanguage(uri) {
    try {
      let doc = this.client.getDocument(uri);
      let languages4 = Array.from(this.languagePerId.values());
      if (doc)
        return languages4.find((language2) => language2.handles(uri, doc.textDocument));
      return languages4.find((language2) => language2.handlesUri(import_coc39.Uri.parse(uri)));
    } catch {
      return void 0;
    }
  }
  async handles(doc) {
    let languages4 = Array.from(this.languagePerId.values());
    let idx = languages4.findIndex((language2) => language2.handles(doc.uri, doc));
    if (idx != -1)
      return true;
    return this.client.bufferSyncSupport.handles(doc.uri);
  }
  triggerAllDiagnostics() {
    for (const language2 of this.languagePerId.values()) {
      language2.triggerAllDiagnostics();
    }
  }
  async diagnosticsReceived(kind, resource, diagnostics) {
    const language2 = await this.findLanguage(resource.toString());
    if (language2) {
      language2.diagnosticsReceived(kind, resource, this.createMarkerDatas(diagnostics));
    }
  }
  createMarkerDatas(diagnostics) {
    return diagnostics.map((tsDiag) => this.tsDiagnosticToLspDiagnostic(tsDiag));
  }
  tsDiagnosticToLspDiagnostic(diagnostic) {
    const { start, end, text } = diagnostic;
    const range = {
      start: Position2.fromLocation(start),
      end: Position2.fromLocation(end)
    };
    let relatedInformation;
    if (diagnostic.relatedInformation) {
      relatedInformation = diagnostic.relatedInformation.map((o) => {
        let { span, message } = o;
        return {
          location: Location2.fromTextSpan(this.client.toResource(span.file), span),
          message
        };
      });
    }
    let tags = [];
    if (diagnostic.reportsUnnecessary) {
      tags.push(import_vscode_languageserver_protocol23.DiagnosticTag.Unnecessary);
    }
    if (diagnostic.reportsDeprecated) {
      tags.push(import_vscode_languageserver_protocol23.DiagnosticTag.Deprecated);
    }
    tags = tags.length ? tags : void 0;
    return {
      range,
      tags,
      message: text,
      code: diagnostic.code ? diagnostic.code : null,
      severity: this.getDiagnosticSeverity(diagnostic),
      reportDeprecated: diagnostic.reportsDeprecated,
      reportUnnecessary: diagnostic.reportsUnnecessary,
      source: diagnostic.source || "tsserver",
      relatedInformation
    };
  }
  getDiagnosticSeverity(diagnostic) {
    if (this.reportStyleCheckAsWarnings && this.isStyleCheckDiagnostic(diagnostic.code) && diagnostic.category === DiagnosticCategory.error) {
      return import_vscode_languageserver_protocol23.DiagnosticSeverity.Warning;
    }
    switch (diagnostic.category) {
      case DiagnosticCategory.error:
        return import_vscode_languageserver_protocol23.DiagnosticSeverity.Error;
      case DiagnosticCategory.warning:
        return import_vscode_languageserver_protocol23.DiagnosticSeverity.Warning;
      case DiagnosticCategory.suggestion:
        return import_vscode_languageserver_protocol23.DiagnosticSeverity.Information;
      default:
        return import_vscode_languageserver_protocol23.DiagnosticSeverity.Error;
    }
  }
  isStyleCheckDiagnostic(code) {
    return code ? styleCheckDiagnostics.indexOf(code) !== -1 : false;
  }
  getAllModeIds(descriptions, pluginManager) {
    const allModeIds = flatten([
      ...descriptions.map((x) => x.languageIds),
      ...pluginManager.plugins.map((x) => x.languages)
    ]);
    return allModeIds;
  }
};

// src/server/index.ts
var TsserverService = class {
  constructor(pluginManager, subscriptions) {
    this.pluginManager = pluginManager;
    this.subscriptions = subscriptions;
    this.id = "tsserver";
    this.name = "tsserver";
    this._state = import_coc40.ServiceStat.Initial;
    this._onDidServiceReady = new import_vscode_languageserver_protocol24.Emitter();
    this.onServiceReady = this._onDidServiceReady.event;
    this.disposables = [];
    this.descriptions = [];
    const config = import_coc40.workspace.getConfiguration("tsserver");
    const enableJavascript = config.get("enableJavascript", true);
    this.enable = config.get("enable");
    this.descriptions = standardLanguageDescriptions.filter((o) => {
      return enableJavascript ? true : o.id != "javascript";
    });
    import_coc40.workspace.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("tsserver")) {
        const config2 = import_coc40.workspace.getConfiguration("tsserver");
        let enable = this.enable;
        this.enable = config2.get("enable", true);
        if (enable !== this.enable) {
          if (this.enable) {
            void this.start();
          } else {
            void this.stop();
          }
        }
      }
    });
    this.selector = this.descriptions.reduce((arr, c) => {
      return arr.concat(c.languageIds);
    }, []);
    this.registCommands();
  }
  get state() {
    if (this.clientHost) {
      return this.clientHost.serviceClient.state;
    }
    return this._state;
  }
  registCommands() {
    let { subscriptions } = this;
    const registCommand2 = (cmd) => {
      let { id, execute } = cmd;
      subscriptions.push(import_coc40.commands.registerCommand(id, execute, cmd));
    };
    registCommand2(new ConfigurePluginCommand(this.pluginManager));
    registCommand2(new AutoFixCommand(this));
    registCommand2(new ReloadProjectsCommand(this));
    registCommand2(new FileReferencesCommand(this));
    registCommand2(new OpenTsServerLogCommand(this));
    registCommand2(new TypeScriptGoToProjectConfigCommand(this));
    registCommand2(new OrganizeImportsCommand(this));
    registCommand2(new SourceImportsCommand(this));
    registCommand2({
      id: "tsserver.restart",
      execute: () => {
        this.restart();
      }
    });
  }
  get config() {
    return import_coc40.workspace.getConfiguration("tsserver");
  }
  getClientHost() {
    if (this.state == import_coc40.ServiceStat.Running)
      return Promise.resolve(this.clientHost);
    this.start();
    return new Promise((resolve, reject) => {
      let timer = setTimeout(() => {
        reject(new Error(`Server not started after 5s`));
      }, 5e3);
      let disposable = this.onServiceReady(() => {
        clearTimeout(timer);
        disposable.dispose();
        resolve(this.clientHost);
      });
    });
  }
  async start() {
    if (!this.enable || this._state == import_coc40.ServiceStat.Starting)
      return;
    this._state = import_coc40.ServiceStat.Starting;
    if (this.clientHost) {
      let client2 = this.clientHost.serviceClient;
      client2.restartTsServer();
      return;
    }
    let tscPath = await import_coc40.workspace.nvim.getVar("Tsserver_path");
    this.clientHost = new TypeScriptServiceClientHost(this.descriptions, this.pluginManager, tscPath);
    let client = this.clientHost.serviceClient;
    await new Promise((resolve) => {
      client.onReady(() => {
        this._onDidServiceReady.fire(void 0);
        resolve(void 0);
      });
    });
  }
  async restart() {
    if (!this.enable)
      return;
    await this.stop();
    await this.start();
  }
  async stop() {
    var _a;
    if (!this.clientHost)
      return;
    let client = this.clientHost.serviceClient;
    await client.stop();
    (_a = this.clientHost) == null ? void 0 : _a.dispose();
    this.clientHost = null;
    this._state = import_coc40.ServiceStat.Stopped;
  }
  dispose() {
    void this.stop();
    this._onDidServiceReady.dispose();
    (0, import_coc40.disposeAll)(this.disposables);
  }
};

// src/utils/plugins.ts
var import_coc41 = require("coc.nvim");
var import_vscode_languageserver_protocol25 = __toESM(require_main2());
var TypeScriptServerPlugin;
((TypeScriptServerPlugin2) => {
  function equals2(a, b) {
    return a.path === b.path && a.name === b.name && a.enableForWorkspaceTypeScriptVersions === b.enableForWorkspaceTypeScriptVersions && equals(a.languages, b.languages);
  }
  TypeScriptServerPlugin2.equals = equals2;
})(TypeScriptServerPlugin || (TypeScriptServerPlugin = {}));
var PluginManager = class {
  constructor() {
    this._pluginConfigurations = /* @__PURE__ */ new Map();
    this._disposables = [];
    this._onDidUpdatePlugins = this._register(new import_vscode_languageserver_protocol25.Emitter());
    this.onDidChangePlugins = this._onDidUpdatePlugins.event;
    this._onDidUpdateConfig = this._register(new import_vscode_languageserver_protocol25.Emitter());
    this.onDidUpdateConfig = this._onDidUpdateConfig.event;
    let loadPlugins = () => {
      if (!this._plugins) {
        return;
      }
      const newPlugins = this.readPlugins();
      if (!equals(flatten(Array.from(this._plugins.values())), flatten(Array.from(newPlugins.values())), TypeScriptServerPlugin.equals)) {
        this._plugins = newPlugins;
        this._onDidUpdatePlugins.fire(this);
      }
    };
    import_coc41.extensions.onDidActiveExtension(loadPlugins, void 0, this._disposables);
    import_coc41.extensions.onDidUnloadExtension(loadPlugins, void 0, this._disposables);
  }
  dispose() {
    (0, import_coc41.disposeAll)(this._disposables);
  }
  get plugins() {
    if (!this._plugins) {
      this._plugins = this.readPlugins();
    }
    return flatten(Array.from(this._plugins.values()));
  }
  _register(value) {
    this._disposables.push(value);
    return value;
  }
  setConfiguration(pluginId, config) {
    this._pluginConfigurations.set(pluginId, config);
    this._onDidUpdateConfig.fire({ pluginId, config });
  }
  configurations() {
    return this._pluginConfigurations.entries();
  }
  readPlugins() {
    const pluginMap = /* @__PURE__ */ new Map();
    for (const extension of import_coc41.extensions.all) {
      const pack = extension.packageJSON;
      if (pack.contributes && Array.isArray(pack.contributes.typescriptServerPlugins)) {
        const plugins = [];
        for (const plugin of pack.contributes.typescriptServerPlugins) {
          plugins.push({
            name: plugin.name,
            enableForWorkspaceTypeScriptVersions: !!plugin.enableForWorkspaceTypeScriptVersions,
            path: extension.extensionPath,
            languages: Array.isArray(plugin.languages) ? plugin.languages : []
          });
        }
        if (plugins.length) {
          pluginMap.set(extension.id, plugins);
        }
      }
    }
    return pluginMap;
  }
};

// src/index.ts
async function activate(context) {
  let { subscriptions } = context;
  const pluginManager = new PluginManager();
  const service = new TsserverService(pluginManager, context.subscriptions);
  subscriptions.push(import_coc42.services.regist(service));
  return {
    configurePlugin: (pluginId, configuration) => {
      pluginManager.setConfiguration(pluginId, configuration);
    }
  };
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
//# sourceMappingURL=index.js.map
