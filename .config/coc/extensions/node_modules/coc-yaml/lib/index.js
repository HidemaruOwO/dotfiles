var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// node_modules/universalify/index.js
var require_universalify = __commonJS((exports2) => {
  "use strict";
  exports2.fromCallback = function(fn) {
    return Object.defineProperty(function(...args) {
      if (typeof args[args.length - 1] === "function")
        fn.apply(this, args);
      else {
        return new Promise((resolve, reject) => {
          fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve(res));
        });
      }
    }, "name", {value: fn.name});
  };
  exports2.fromPromise = function(fn) {
    return Object.defineProperty(function(...args) {
      const cb = args[args.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, args);
      else
        fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
    }, "name", {value: fn.name});
  };
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports2, module2) => {
  var constants = require("constants");
  var origCwd = process.cwd;
  var cwd = null;
  var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module2.exports = patch;
  function patch(fs3) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs3);
    }
    if (!fs3.lutimes) {
      patchLutimes(fs3);
    }
    fs3.chown = chownFix(fs3.chown);
    fs3.fchown = chownFix(fs3.fchown);
    fs3.lchown = chownFix(fs3.lchown);
    fs3.chmod = chmodFix(fs3.chmod);
    fs3.fchmod = chmodFix(fs3.fchmod);
    fs3.lchmod = chmodFix(fs3.lchmod);
    fs3.chownSync = chownFixSync(fs3.chownSync);
    fs3.fchownSync = chownFixSync(fs3.fchownSync);
    fs3.lchownSync = chownFixSync(fs3.lchownSync);
    fs3.chmodSync = chmodFixSync(fs3.chmodSync);
    fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
    fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
    fs3.stat = statFix(fs3.stat);
    fs3.fstat = statFix(fs3.fstat);
    fs3.lstat = statFix(fs3.lstat);
    fs3.statSync = statFixSync(fs3.statSync);
    fs3.fstatSync = statFixSync(fs3.fstatSync);
    fs3.lstatSync = statFixSync(fs3.lstatSync);
    if (!fs3.lchmod) {
      fs3.lchmod = function(path2, mode, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lchmodSync = function() {
      };
    }
    if (!fs3.lchown) {
      fs3.lchown = function(path2, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lchownSync = function() {
      };
    }
    if (platform === "win32") {
      fs3.rename = function(fs$rename) {
        return function(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs3.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        };
      }(fs3.rename);
    }
    fs3.read = function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs3.read);
    fs3.readSync = function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs3, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs3.readSync);
    function patchLchmod(fs4) {
      fs4.lchmod = function(path2, mode, callback) {
        fs4.open(path2, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs4.fchmod(fd, mode, function(err2) {
            fs4.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      };
      fs4.lchmodSync = function(path2, mode) {
        var fd = fs4.openSync(path2, constants.O_WRONLY | constants.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs4.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs4.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs4.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs4) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs4.lutimes = function(path2, at, mt, cb) {
          fs4.open(path2, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs4.futimes(fd, at, mt, function(er2) {
              fs4.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        };
        fs4.lutimesSync = function(path2, at, mt) {
          var fd = fs4.openSync(path2, constants.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs4.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs4.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs4.closeSync(fd);
            }
          }
          return ret;
        };
      } else {
        fs4.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs4.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs3, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs3, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs3, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs3, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports2, module2) => {
  var Stream = require("stream").Stream;
  module2.exports = legacy;
  function legacy(fs3) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path2, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path2, options);
      Stream.call(this);
      var self = this;
      this.path = path2;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self._read();
        });
        return;
      }
      fs3.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self.emit("error", err);
          self.readable = false;
          return;
        }
        self.fd = fd;
        self.emit("open", fd);
        self._read();
      });
    }
    function WriteStream(path2, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path2, options);
      Stream.call(this);
      this.path = path2;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length; index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs3.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = {__proto__: getPrototypeOf(obj)};
    else
      var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports2, module2) => {
  var fs3 = require("fs");
  var polyfills = require_polyfills();
  var legacy = require_legacy_streams();
  var clone = require_clone();
  var util = require("util");
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util.debuglog)
    debug = util.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs3[gracefulQueue]) {
    queue = global[gracefulQueue] || [];
    publishQueue(fs3, queue);
    fs3.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs3, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs3.close);
    fs3.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs3, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs3.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs3[gracefulQueue]);
        require("assert").equal(fs3[gracefulQueue].length, 0);
      });
    }
  }
  var queue;
  if (!global[gracefulQueue]) {
    publishQueue(global, fs3[gracefulQueue]);
  }
  module2.exports = patch(clone(fs3));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
    module2.exports = patch(fs3);
    fs3.__patched = true;
  }
  function patch(fs4) {
    polyfills(fs4);
    fs4.gracefulify = patch;
    fs4.createReadStream = createReadStream;
    fs4.createWriteStream = createWriteStream;
    var fs$readFile = fs4.readFile;
    fs4.readFile = readFile;
    function readFile(path2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path2, options, cb);
      function go$readFile(path3, options2, cb2, startTime) {
        return fs$readFile(path3, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs4.writeFile;
    fs4.writeFile = writeFile;
    function writeFile(path2, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path2, data, options, cb);
      function go$writeFile(path3, data2, options2, cb2, startTime) {
        return fs$writeFile(path3, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs4.appendFile;
    if (fs$appendFile)
      fs4.appendFile = appendFile;
    function appendFile(path2, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path2, data, options, cb);
      function go$appendFile(path3, data2, options2, cb2, startTime) {
        return fs$appendFile(path3, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs4.copyFile;
    if (fs$copyFile)
      fs4.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs4.readdir;
    fs4.readdir = readdir;
    function readdir(path2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readdir(path2, options, cb);
      function go$readdir(path3, options2, cb2, startTime) {
        return fs$readdir(path3, options2, function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        });
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs4);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs4.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs4.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs4, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs4, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs4, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs4, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path2, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path2, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path2, options) {
      return new fs4.ReadStream(path2, options);
    }
    function createWriteStream(path2, options) {
      return new fs4.WriteStream(path2, options);
    }
    var fs$open = fs4.open;
    fs4.open = open;
    function open(path2, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path2, flags, mode, cb);
      function go$open(path3, flags2, mode2, cb2, startTime) {
        return fs$open(path3, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs4;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs3[gracefulQueue].push(elem);
    retry();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0; i < fs3[gracefulQueue].length; ++i) {
      if (fs3[gracefulQueue][i].length > 2) {
        fs3[gracefulQueue][i][3] = now;
        fs3[gracefulQueue][i][4] = now;
      }
    }
    retry();
  }
  function retry() {
    clearTimeout(retryTimer);
    retryTimer = void 0;
    if (fs3[gracefulQueue].length === 0)
      return;
    var elem = fs3[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === void 0) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 6e4) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs3[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === void 0) {
      retryTimer = setTimeout(retry, 0);
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS((exports2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var fs3 = require_graceful_fs();
  var api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs3[key] === "function";
  });
  Object.assign(exports2, fs3);
  api.forEach((method) => {
    exports2[method] = u(fs3[method]);
  });
  exports2.realpath.native = u(fs3.realpath.native);
  exports2.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs3.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs3.exists(filename, resolve);
    });
  };
  exports2.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs3.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs3.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve({bytesRead, buffer: buffer2});
      });
    });
  };
  exports2.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs3.write(fd, buffer, ...args);
    }
    return new Promise((resolve, reject) => {
      fs3.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve({bytesWritten, buffer: buffer2});
      });
    });
  };
  if (typeof fs3.writev === "function") {
    exports2.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs3.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs3.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve({bytesWritten, buffers: buffers2});
        });
      });
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  module2.exports.checkPath = function checkPath(pth) {
    if (process.platform === "win32") {
      const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path2.parse(pth).root, ""));
      if (pathHasInvalidWinCharacters) {
        const error = new Error(`Path contains invalid characters: ${pth}`);
        error.code = "EINVAL";
        throw error;
      }
    }
  };
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_fs();
  var {checkPath} = require_utils();
  var getMode = (options) => {
    const defaults = {mode: 511};
    if (typeof options === "number")
      return options;
    return {...defaults, ...options}.mode;
  };
  module2.exports.makeDir = async (dir, options) => {
    checkPath(dir);
    return fs3.mkdir(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
  module2.exports.makeDirSync = (dir, options) => {
    checkPath(dir);
    return fs3.mkdirSync(dir, {
      mode: getMode(options),
      recursive: true
    });
  };
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromPromise;
  var {makeDir: _makeDir, makeDirSync} = require_make_dir();
  var makeDir = u(_makeDir);
  module2.exports = {
    mkdirs: makeDir,
    mkdirsSync: makeDirSync,
    mkdirp: makeDir,
    mkdirpSync: makeDirSync,
    ensureDir: makeDir,
    ensureDirSync: makeDirSync
  };
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  function utimesMillis(path2, atime, mtime, callback) {
    fs3.open(path2, "r+", (err, fd) => {
      if (err)
        return callback(err);
      fs3.futimes(fd, atime, mtime, (futimesErr) => {
        fs3.close(fd, (closeErr) => {
          if (callback)
            callback(futimesErr || closeErr);
        });
      });
    });
  }
  function utimesMillisSync(path2, atime, mtime) {
    const fd = fs3.openSync(path2, "r+");
    fs3.futimesSync(fd, atime, mtime);
    return fs3.closeSync(fd);
  }
  module2.exports = {
    utimesMillis,
    utimesMillisSync
  };
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_fs();
  var path2 = require("path");
  var util = require("util");
  function getStats(src, dest, opts) {
    const statFunc = opts.dereference ? (file) => fs3.stat(file, {bigint: true}) : (file) => fs3.lstat(file, {bigint: true});
    return Promise.all([
      statFunc(src),
      statFunc(dest).catch((err) => {
        if (err.code === "ENOENT")
          return null;
        throw err;
      })
    ]).then(([srcStat, destStat]) => ({srcStat, destStat}));
  }
  function getStatsSync(src, dest, opts) {
    let destStat;
    const statFunc = opts.dereference ? (file) => fs3.statSync(file, {bigint: true}) : (file) => fs3.lstatSync(file, {bigint: true});
    const srcStat = statFunc(src);
    try {
      destStat = statFunc(dest);
    } catch (err) {
      if (err.code === "ENOENT")
        return {srcStat, destStat: null};
      throw err;
    }
    return {srcStat, destStat};
  }
  function checkPaths(src, dest, funcName, opts, cb) {
    util.callbackify(getStats)(src, dest, opts, (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path2.basename(src);
          const destBaseName = path2.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return cb(null, {srcStat, destStat, isChangingCase: true});
          }
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return cb(null, {srcStat, destStat});
    });
  }
  function checkPathsSync(src, dest, funcName, opts) {
    const {srcStat, destStat} = getStatsSync(src, dest, opts);
    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path2.basename(src);
        const destBaseName = path2.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return {srcStat, destStat, isChangingCase: true};
        }
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return {srcStat, destStat};
  }
  function checkParentPaths(src, srcStat, dest, funcName, cb) {
    const srcParent = path2.resolve(path2.dirname(src));
    const destParent = path2.resolve(path2.dirname(dest));
    if (destParent === srcParent || destParent === path2.parse(destParent).root)
      return cb();
    fs3.stat(destParent, {bigint: true}, (err, destStat) => {
      if (err) {
        if (err.code === "ENOENT")
          return cb();
        return cb(err);
      }
      if (areIdentical(srcStat, destStat)) {
        return cb(new Error(errMsg(src, dest, funcName)));
      }
      return checkParentPaths(src, srcStat, destParent, funcName, cb);
    });
  }
  function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path2.resolve(path2.dirname(src));
    const destParent = path2.resolve(path2.dirname(dest));
    if (destParent === srcParent || destParent === path2.parse(destParent).root)
      return;
    let destStat;
    try {
      destStat = fs3.statSync(destParent, {bigint: true});
    } catch (err) {
      if (err.code === "ENOENT")
        return;
      throw err;
    }
    if (areIdentical(srcStat, destStat)) {
      throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
  }
  function areIdentical(srcStat, destStat) {
    return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
  }
  function isSrcSubdir(src, dest) {
    const srcArr = path2.resolve(src).split(path2.sep).filter((i) => i);
    const destArr = path2.resolve(dest).split(path2.sep).filter((i) => i);
    return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
  }
  function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
  }
  module2.exports = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir,
    areIdentical
  };
});

// node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  var path2 = require("path");
  var mkdirsSync = require_mkdirs().mkdirsSync;
  var utimesMillisSync = require_utimes().utimesMillisSync;
  var stat = require_stat();
  function copySync(src, dest, opts) {
    if (typeof opts === "function") {
      opts = {filter: opts};
    }
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    const {srcStat, destStat} = stat.checkPathsSync(src, dest, "copy", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "copy");
    return handleFilterAndCopy(destStat, src, dest, opts);
  }
  function handleFilterAndCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    const destParent = path2.dirname(dest);
    if (!fs3.existsSync(destParent))
      mkdirsSync(destParent);
    return getStats(destStat, src, dest, opts);
  }
  function startCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest))
      return;
    return getStats(destStat, src, dest, opts);
  }
  function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs3.statSync : fs3.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts);
    else if (srcStat.isSocket())
      throw new Error(`Cannot copy a socket file: ${src}`);
    else if (srcStat.isFIFO())
      throw new Error(`Cannot copy a FIFO pipe: ${src}`);
    throw new Error(`Unknown file: ${src}`);
  }
  function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
  }
  function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
      fs3.unlinkSync(dest);
      return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
      throw new Error(`'${dest}' already exists`);
    }
  }
  function copyFile(srcStat, src, dest, opts) {
    fs3.copyFileSync(src, dest);
    if (opts.preserveTimestamps)
      handleTimestamps(srcStat.mode, src, dest);
    return setDestMode(dest, srcStat.mode);
  }
  function handleTimestamps(srcMode, src, dest) {
    if (fileIsNotWritable(srcMode))
      makeFileWritable(dest, srcMode);
    return setDestTimestamps(src, dest);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode) {
    return setDestMode(dest, srcMode | 128);
  }
  function setDestMode(dest, srcMode) {
    return fs3.chmodSync(dest, srcMode);
  }
  function setDestTimestamps(src, dest) {
    const updatedSrcStat = fs3.statSync(src);
    return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts);
    return copyDir(src, dest, opts);
  }
  function mkDirAndCopy(srcMode, src, dest, opts) {
    fs3.mkdirSync(dest);
    copyDir(src, dest, opts);
    return setDestMode(dest, srcMode);
  }
  function copyDir(src, dest, opts) {
    fs3.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
  }
  function copyDirItem(item, src, dest, opts) {
    const srcItem = path2.join(src, item);
    const destItem = path2.join(dest, item);
    const {destStat} = stat.checkPathsSync(srcItem, destItem, "copy", opts);
    return startCopy(destStat, srcItem, destItem, opts);
  }
  function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs3.readlinkSync(src);
    if (opts.dereference) {
      resolvedSrc = path2.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs3.symlinkSync(resolvedSrc, dest);
    } else {
      let resolvedDest;
      try {
        resolvedDest = fs3.readlinkSync(dest);
      } catch (err) {
        if (err.code === "EINVAL" || err.code === "UNKNOWN")
          return fs3.symlinkSync(resolvedSrc, dest);
        throw err;
      }
      if (opts.dereference) {
        resolvedDest = path2.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (fs3.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      return copyLink(resolvedSrc, dest);
    }
  }
  function copyLink(resolvedSrc, dest) {
    fs3.unlinkSync(dest);
    return fs3.symlinkSync(resolvedSrc, dest);
  }
  module2.exports = copySync;
});

// node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    copySync: require_copy_sync()
  };
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromPromise;
  var fs3 = require_fs();
  function pathExists(path2) {
    return fs3.access(path2).then(() => true).catch(() => false);
  }
  module2.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs3.existsSync
  };
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  var path2 = require("path");
  var mkdirs = require_mkdirs().mkdirs;
  var pathExists = require_path_exists().pathExists;
  var utimesMillis = require_utimes().utimesMillis;
  var stat = require_stat();
  function copy(src, dest, opts, cb) {
    if (typeof opts === "function" && !cb) {
      cb = opts;
      opts = {};
    } else if (typeof opts === "function") {
      opts = {filter: opts};
    }
    cb = cb || function() {
    };
    opts = opts || {};
    opts.clobber = "clobber" in opts ? !!opts.clobber : true;
    opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
    if (opts.preserveTimestamps && process.arch === "ia32") {
      console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
    }
    stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, destStat} = stats;
      stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
        if (err2)
          return cb(err2);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    });
  }
  function checkParentDir(destStat, src, dest, opts, cb) {
    const destParent = path2.dirname(dest);
    pathExists(destParent, (err, dirExists) => {
      if (err)
        return cb(err);
      if (dirExists)
        return getStats(destStat, src, dest, opts, cb);
      mkdirs(destParent, (err2) => {
        if (err2)
          return cb(err2);
        return getStats(destStat, src, dest, opts, cb);
      });
    });
  }
  function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    Promise.resolve(opts.filter(src, dest)).then((include) => {
      if (include)
        return onInclude(destStat, src, dest, opts, cb);
      return cb();
    }, (error) => cb(error));
  }
  function startCopy(destStat, src, dest, opts, cb) {
    if (opts.filter)
      return handleFilter(getStats, destStat, src, dest, opts, cb);
    return getStats(destStat, src, dest, opts, cb);
  }
  function getStats(destStat, src, dest, opts, cb) {
    const stat2 = opts.dereference ? fs3.stat : fs3.lstat;
    stat2(src, (err, srcStat) => {
      if (err)
        return cb(err);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts, cb);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts, cb);
      else if (srcStat.isSocket())
        return cb(new Error(`Cannot copy a socket file: ${src}`));
      else if (srcStat.isFIFO())
        return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
      return cb(new Error(`Unknown file: ${src}`));
    });
  }
  function onFile(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return copyFile(srcStat, src, dest, opts, cb);
    return mayCopyFile(srcStat, src, dest, opts, cb);
  }
  function mayCopyFile(srcStat, src, dest, opts, cb) {
    if (opts.overwrite) {
      fs3.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return copyFile(srcStat, src, dest, opts, cb);
      });
    } else if (opts.errorOnExist) {
      return cb(new Error(`'${dest}' already exists`));
    } else
      return cb();
  }
  function copyFile(srcStat, src, dest, opts, cb) {
    fs3.copyFile(src, dest, (err) => {
      if (err)
        return cb(err);
      if (opts.preserveTimestamps)
        return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
      return setDestMode(dest, srcStat.mode, cb);
    });
  }
  function handleTimestampsAndMode(srcMode, src, dest, cb) {
    if (fileIsNotWritable(srcMode)) {
      return makeFileWritable(dest, srcMode, (err) => {
        if (err)
          return cb(err);
        return setDestTimestampsAndMode(srcMode, src, dest, cb);
      });
    }
    return setDestTimestampsAndMode(srcMode, src, dest, cb);
  }
  function fileIsNotWritable(srcMode) {
    return (srcMode & 128) === 0;
  }
  function makeFileWritable(dest, srcMode, cb) {
    return setDestMode(dest, srcMode | 128, cb);
  }
  function setDestTimestampsAndMode(srcMode, src, dest, cb) {
    setDestTimestamps(src, dest, (err) => {
      if (err)
        return cb(err);
      return setDestMode(dest, srcMode, cb);
    });
  }
  function setDestMode(dest, srcMode, cb) {
    return fs3.chmod(dest, srcMode, cb);
  }
  function setDestTimestamps(src, dest, cb) {
    fs3.stat(src, (err, updatedSrcStat) => {
      if (err)
        return cb(err);
      return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
    });
  }
  function onDir(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat)
      return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
    return copyDir(src, dest, opts, cb);
  }
  function mkDirAndCopy(srcMode, src, dest, opts, cb) {
    fs3.mkdir(dest, (err) => {
      if (err)
        return cb(err);
      copyDir(src, dest, opts, (err2) => {
        if (err2)
          return cb(err2);
        return setDestMode(dest, srcMode, cb);
      });
    });
  }
  function copyDir(src, dest, opts, cb) {
    fs3.readdir(src, (err, items) => {
      if (err)
        return cb(err);
      return copyDirItems(items, src, dest, opts, cb);
    });
  }
  function copyDirItems(items, src, dest, opts, cb) {
    const item = items.pop();
    if (!item)
      return cb();
    return copyDirItem(items, item, src, dest, opts, cb);
  }
  function copyDirItem(items, item, src, dest, opts, cb) {
    const srcItem = path2.join(src, item);
    const destItem = path2.join(dest, item);
    stat.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
      if (err)
        return cb(err);
      const {destStat} = stats;
      startCopy(destStat, srcItem, destItem, opts, (err2) => {
        if (err2)
          return cb(err2);
        return copyDirItems(items, src, dest, opts, cb);
      });
    });
  }
  function onLink(destStat, src, dest, opts, cb) {
    fs3.readlink(src, (err, resolvedSrc) => {
      if (err)
        return cb(err);
      if (opts.dereference) {
        resolvedSrc = path2.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs3.symlink(resolvedSrc, dest, cb);
      } else {
        fs3.readlink(dest, (err2, resolvedDest) => {
          if (err2) {
            if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
              return fs3.symlink(resolvedSrc, dest, cb);
            return cb(err2);
          }
          if (opts.dereference) {
            resolvedDest = path2.resolve(process.cwd(), resolvedDest);
          }
          if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
            return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
          }
          if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
            return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
          }
          return copyLink(resolvedSrc, dest, cb);
        });
      }
    });
  }
  function copyLink(resolvedSrc, dest, cb) {
    fs3.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return fs3.symlink(resolvedSrc, dest, cb);
    });
  }
  module2.exports = copy;
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  module2.exports = {
    copy: u(require_copy())
  };
});

// node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  var path2 = require("path");
  var assert = require("assert");
  var isWindows = process.platform === "win32";
  function defaults(options) {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs3[m];
      m = m + "Sync";
      options[m] = options[m] || fs3[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
  }
  function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    rimraf_(p, options, function CB(er) {
      if (er) {
        if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
          busyTries++;
          const time = busyTries * 100;
          return setTimeout(() => rimraf_(p, options, CB), time);
        }
        if (er.code === "ENOENT")
          er = null;
      }
      cb(er);
    });
  }
  function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT") {
        return cb(null);
      }
      if (er && er.code === "EPERM" && isWindows) {
        return fixWinEPERM(p, options, er, cb);
      }
      if (st && st.isDirectory()) {
        return rmdir(p, options, er, cb);
      }
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT") {
            return cb(null);
          }
          if (er2.code === "EPERM") {
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          }
          if (er2.code === "EISDIR") {
            return rmdir(p, options, er2, cb);
          }
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2) {
        cb(er2.code === "ENOENT" ? null : er);
      } else {
        options.stat(p, (er3, stats) => {
          if (er3) {
            cb(er3.code === "ENOENT" ? null : er);
          } else if (stats.isDirectory()) {
            rmdir(p, options, er, cb);
          } else {
            options.unlink(p, cb);
          }
        });
      }
    });
  }
  function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT") {
        return;
      } else {
        throw er;
      }
    }
    if (stats.isDirectory()) {
      rmdirSync(p, options, er);
    } else {
      options.unlinkSync(p);
    }
  }
  function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
        rmkids(p, options, cb);
      } else if (er && er.code === "ENOTDIR") {
        cb(originalEr);
      } else {
        cb(er);
      }
    });
  }
  function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      let errState;
      if (n === 0)
        return options.rmdir(p, cb);
      files.forEach((f) => {
        rimraf(path2.join(p, f), options, (er2) => {
          if (errState) {
            return;
          }
          if (er2)
            return cb(errState = er2);
          if (--n === 0) {
            options.rmdir(p, cb);
          }
        });
      });
    });
  }
  function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.strictEqual(typeof options, "object", "rimraf: options should be object");
    try {
      st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      }
      if (er.code === "EPERM" && isWindows) {
        fixWinEPERMSync(p, options, er);
      }
    }
    try {
      if (st && st.isDirectory()) {
        rmdirSync(p, options, null);
      } else {
        options.unlinkSync(p);
      }
    } catch (er) {
      if (er.code === "ENOENT") {
        return;
      } else if (er.code === "EPERM") {
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      } else if (er.code !== "EISDIR") {
        throw er;
      }
      rmdirSync(p, options, er);
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOTDIR") {
        throw originalEr;
      } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
        rmkidsSync(p, options);
      } else if (er.code !== "ENOENT") {
        throw er;
      }
    }
  }
  function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path2.join(p, f), options));
    if (isWindows) {
      const startTime = Date.now();
      do {
        try {
          const ret = options.rmdirSync(p, options);
          return ret;
        } catch {
        }
      } while (Date.now() - startTime < 500);
    } else {
      const ret = options.rmdirSync(p, options);
      return ret;
    }
  }
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  var u = require_universalify().fromCallback;
  var rimraf = require_rimraf();
  function remove(path2, callback) {
    if (fs3.rm)
      return fs3.rm(path2, {recursive: true, force: true}, callback);
    rimraf(path2, callback);
  }
  function removeSync(path2) {
    if (fs3.rmSync)
      return fs3.rmSync(path2, {recursive: true, force: true});
    rimraf.sync(path2);
  }
  module2.exports = {
    remove: u(remove),
    removeSync
  };
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromPromise;
  var fs3 = require_fs();
  var path2 = require("path");
  var mkdir = require_mkdirs();
  var remove = require_remove();
  var emptyDir = u(async function emptyDir2(dir) {
    let items;
    try {
      items = await fs3.readdir(dir);
    } catch {
      return mkdir.mkdirs(dir);
    }
    return Promise.all(items.map((item) => remove.remove(path2.join(dir, item))));
  });
  function emptyDirSync(dir) {
    let items;
    try {
      items = fs3.readdirSync(dir);
    } catch {
      return mkdir.mkdirsSync(dir);
    }
    items.forEach((item) => {
      item = path2.join(dir, item);
      remove.removeSync(item);
    });
  }
  module2.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
  };
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var path2 = require("path");
  var fs3 = require_graceful_fs();
  var mkdir = require_mkdirs();
  function createFile(file, callback) {
    function makeFile() {
      fs3.writeFile(file, "", (err) => {
        if (err)
          return callback(err);
        callback();
      });
    }
    fs3.stat(file, (err, stats) => {
      if (!err && stats.isFile())
        return callback();
      const dir = path2.dirname(file);
      fs3.stat(dir, (err2, stats2) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return mkdir.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeFile();
            });
          }
          return callback(err2);
        }
        if (stats2.isDirectory())
          makeFile();
        else {
          fs3.readdir(dir, (err3) => {
            if (err3)
              return callback(err3);
          });
        }
      });
    });
  }
  function createFileSync(file) {
    let stats;
    try {
      stats = fs3.statSync(file);
    } catch {
    }
    if (stats && stats.isFile())
      return;
    const dir = path2.dirname(file);
    try {
      if (!fs3.statSync(dir).isDirectory()) {
        fs3.readdirSync(dir);
      }
    } catch (err) {
      if (err && err.code === "ENOENT")
        mkdir.mkdirsSync(dir);
      else
        throw err;
    }
    fs3.writeFileSync(file, "");
  }
  module2.exports = {
    createFile: u(createFile),
    createFileSync
  };
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var path2 = require("path");
  var fs3 = require_graceful_fs();
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  var {areIdentical} = require_stat();
  function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath2, dstpath2) {
      fs3.link(srcpath2, dstpath2, (err) => {
        if (err)
          return callback(err);
        callback(null);
      });
    }
    fs3.lstat(dstpath, (_, dstStat) => {
      fs3.lstat(srcpath, (err, srcStat) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureLink");
          return callback(err);
        }
        if (dstStat && areIdentical(srcStat, dstStat))
          return callback(null);
        const dir = path2.dirname(dstpath);
        pathExists(dir, (err2, dirExists) => {
          if (err2)
            return callback(err2);
          if (dirExists)
            return makeLink(srcpath, dstpath);
          mkdir.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeLink(srcpath, dstpath);
          });
        });
      });
    });
  }
  function createLinkSync(srcpath, dstpath) {
    let dstStat;
    try {
      dstStat = fs3.lstatSync(dstpath);
    } catch {
    }
    try {
      const srcStat = fs3.lstatSync(srcpath);
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureLink");
      throw err;
    }
    const dir = path2.dirname(dstpath);
    const dirExists = fs3.existsSync(dir);
    if (dirExists)
      return fs3.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs3.linkSync(srcpath, dstpath);
  }
  module2.exports = {
    createLink: u(createLink),
    createLinkSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var fs3 = require_graceful_fs();
  var pathExists = require_path_exists().pathExists;
  function symlinkPaths(srcpath, dstpath, callback) {
    if (path2.isAbsolute(srcpath)) {
      return fs3.lstat(srcpath, (err) => {
        if (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          return callback(err);
        }
        return callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        });
      });
    } else {
      const dstdir = path2.dirname(dstpath);
      const relativeToDst = path2.join(dstdir, srcpath);
      return pathExists(relativeToDst, (err, exists) => {
        if (err)
          return callback(err);
        if (exists) {
          return callback(null, {
            toCwd: relativeToDst,
            toDst: srcpath
          });
        } else {
          return fs3.lstat(srcpath, (err2) => {
            if (err2) {
              err2.message = err2.message.replace("lstat", "ensureSymlink");
              return callback(err2);
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: path2.relative(dstdir, srcpath)
            });
          });
        }
      });
    }
  }
  function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path2.isAbsolute(srcpath)) {
      exists = fs3.existsSync(srcpath);
      if (!exists)
        throw new Error("absolute srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: srcpath
      };
    } else {
      const dstdir = path2.dirname(dstpath);
      const relativeToDst = path2.join(dstdir, srcpath);
      exists = fs3.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      } else {
        exists = fs3.existsSync(srcpath);
        if (!exists)
          throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path2.relative(dstdir, srcpath)
        };
      }
    }
  }
  module2.exports = {
    symlinkPaths,
    symlinkPathsSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  function symlinkType(srcpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    if (type)
      return callback(null, type);
    fs3.lstat(srcpath, (err, stats) => {
      if (err)
        return callback(null, "file");
      type = stats && stats.isDirectory() ? "dir" : "file";
      callback(null, type);
    });
  }
  function symlinkTypeSync(srcpath, type) {
    let stats;
    if (type)
      return type;
    try {
      stats = fs3.lstatSync(srcpath);
    } catch {
      return "file";
    }
    return stats && stats.isDirectory() ? "dir" : "file";
  }
  module2.exports = {
    symlinkType,
    symlinkTypeSync
  };
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var path2 = require("path");
  var fs3 = require_fs();
  var _mkdirs = require_mkdirs();
  var mkdirs = _mkdirs.mkdirs;
  var mkdirsSync = _mkdirs.mkdirsSync;
  var _symlinkPaths = require_symlink_paths();
  var symlinkPaths = _symlinkPaths.symlinkPaths;
  var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
  var _symlinkType = require_symlink_type();
  var symlinkType = _symlinkType.symlinkType;
  var symlinkTypeSync = _symlinkType.symlinkTypeSync;
  var pathExists = require_path_exists().pathExists;
  var {areIdentical} = require_stat();
  function createSymlink(srcpath, dstpath, type, callback) {
    callback = typeof type === "function" ? type : callback;
    type = typeof type === "function" ? false : type;
    fs3.lstat(dstpath, (err, stats) => {
      if (!err && stats.isSymbolicLink()) {
        Promise.all([
          fs3.stat(srcpath),
          fs3.stat(dstpath)
        ]).then(([srcStat, dstStat]) => {
          if (areIdentical(srcStat, dstStat))
            return callback(null);
          _createSymlink(srcpath, dstpath, type, callback);
        });
      } else
        _createSymlink(srcpath, dstpath, type, callback);
    });
  }
  function _createSymlink(srcpath, dstpath, type, callback) {
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err)
        return callback(err);
      srcpath = relative.toDst;
      symlinkType(relative.toCwd, type, (err2, type2) => {
        if (err2)
          return callback(err2);
        const dir = path2.dirname(dstpath);
        pathExists(dir, (err3, dirExists) => {
          if (err3)
            return callback(err3);
          if (dirExists)
            return fs3.symlink(srcpath, dstpath, type2, callback);
          mkdirs(dir, (err4) => {
            if (err4)
              return callback(err4);
            fs3.symlink(srcpath, dstpath, type2, callback);
          });
        });
      });
    });
  }
  function createSymlinkSync(srcpath, dstpath, type) {
    let stats;
    try {
      stats = fs3.lstatSync(dstpath);
    } catch {
    }
    if (stats && stats.isSymbolicLink()) {
      const srcStat = fs3.statSync(srcpath);
      const dstStat = fs3.statSync(dstpath);
      if (areIdentical(srcStat, dstStat))
        return;
    }
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path2.dirname(dstpath);
    const exists = fs3.existsSync(dir);
    if (exists)
      return fs3.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs3.symlinkSync(srcpath, dstpath, type);
  }
  module2.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
  };
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS((exports2, module2) => {
  "use strict";
  var file = require_file();
  var link = require_link();
  var symlink = require_symlink();
  module2.exports = {
    createFile: file.createFile,
    createFileSync: file.createFileSync,
    ensureFile: file.createFile,
    ensureFileSync: file.createFileSync,
    createLink: link.createLink,
    createLinkSync: link.createLinkSync,
    ensureLink: link.createLink,
    ensureLinkSync: link.createLinkSync,
    createSymlink: symlink.createSymlink,
    createSymlinkSync: symlink.createSymlinkSync,
    ensureSymlink: symlink.createSymlink,
    ensureSymlinkSync: symlink.createSymlinkSync
  };
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS((exports2, module2) => {
  function stringify(obj, {EOL = "\n", finalEOL = true, replacer = null, spaces} = {}) {
    const EOF = finalEOL ? EOL : "";
    const str = JSON.stringify(obj, replacer, spaces);
    return str.replace(/\n/g, EOL) + EOF;
  }
  function stripBom(content) {
    if (Buffer.isBuffer(content))
      content = content.toString("utf8");
    return content.replace(/^\uFEFF/, "");
  }
  module2.exports = {stringify, stripBom};
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS((exports2, module2) => {
  var _fs;
  try {
    _fs = require_graceful_fs();
  } catch (_) {
    _fs = require("fs");
  }
  var universalify = require_universalify();
  var {stringify, stripBom} = require_utils2();
  async function _readFile(file, options = {}) {
    if (typeof options === "string") {
      options = {encoding: options};
    }
    const fs3 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    let data = await universalify.fromCallback(fs3.readFile)(file, options);
    data = stripBom(data);
    let obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
    return obj;
  }
  var readFile = universalify.fromPromise(_readFile);
  function readFileSync(file, options = {}) {
    if (typeof options === "string") {
      options = {encoding: options};
    }
    const fs3 = options.fs || _fs;
    const shouldThrow = "throws" in options ? options.throws : true;
    try {
      let content = fs3.readFileSync(file, options);
      content = stripBom(content);
      return JSON.parse(content, options.reviver);
    } catch (err) {
      if (shouldThrow) {
        err.message = `${file}: ${err.message}`;
        throw err;
      } else {
        return null;
      }
    }
  }
  async function _writeFile(file, obj, options = {}) {
    const fs3 = options.fs || _fs;
    const str = stringify(obj, options);
    await universalify.fromCallback(fs3.writeFile)(file, str, options);
  }
  var writeFile = universalify.fromPromise(_writeFile);
  function writeFileSync(file, obj, options = {}) {
    const fs3 = options.fs || _fs;
    const str = stringify(obj, options);
    return fs3.writeFileSync(file, str, options);
  }
  var jsonfile = {
    readFile,
    readFileSync,
    writeFile,
    writeFileSync
  };
  module2.exports = jsonfile;
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS((exports2, module2) => {
  "use strict";
  var jsonFile = require_jsonfile();
  module2.exports = {
    readJson: jsonFile.readFile,
    readJsonSync: jsonFile.readFileSync,
    writeJson: jsonFile.writeFile,
    writeJsonSync: jsonFile.writeFileSync
  };
});

// node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  var fs3 = require_graceful_fs();
  var path2 = require("path");
  var mkdir = require_mkdirs();
  var pathExists = require_path_exists().pathExists;
  function outputFile(file, data, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = "utf8";
    }
    const dir = path2.dirname(file);
    pathExists(dir, (err, itDoes) => {
      if (err)
        return callback(err);
      if (itDoes)
        return fs3.writeFile(file, data, encoding, callback);
      mkdir.mkdirs(dir, (err2) => {
        if (err2)
          return callback(err2);
        fs3.writeFile(file, data, encoding, callback);
      });
    });
  }
  function outputFileSync(file, ...args) {
    const dir = path2.dirname(file);
    if (fs3.existsSync(dir)) {
      return fs3.writeFileSync(file, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs3.writeFileSync(file, ...args);
  }
  module2.exports = {
    outputFile: u(outputFile),
    outputFileSync
  };
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS((exports2, module2) => {
  "use strict";
  var {stringify} = require_utils2();
  var {outputFile} = require_output();
  async function outputJson(file, data, options = {}) {
    const str = stringify(data, options);
    await outputFile(file, str, options);
  }
  module2.exports = outputJson;
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS((exports2, module2) => {
  "use strict";
  var {stringify} = require_utils2();
  var {outputFileSync} = require_output();
  function outputJsonSync(file, data, options) {
    const str = stringify(data, options);
    outputFileSync(file, str, options);
  }
  module2.exports = outputJsonSync;
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromPromise;
  var jsonFile = require_jsonfile2();
  jsonFile.outputJson = u(require_output_json());
  jsonFile.outputJsonSync = require_output_json_sync();
  jsonFile.outputJSON = jsonFile.outputJson;
  jsonFile.outputJSONSync = jsonFile.outputJsonSync;
  jsonFile.writeJSON = jsonFile.writeJson;
  jsonFile.writeJSONSync = jsonFile.writeJsonSync;
  jsonFile.readJSON = jsonFile.readJson;
  jsonFile.readJSONSync = jsonFile.readJsonSync;
  module2.exports = jsonFile;
});

// node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  var path2 = require("path");
  var copySync = require_copy_sync2().copySync;
  var removeSync = require_remove().removeSync;
  var mkdirpSync = require_mkdirs().mkdirpSync;
  var stat = require_stat();
  function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const {srcStat, isChangingCase = false} = stat.checkPathsSync(src, dest, "move", opts);
    stat.checkParentPathsSync(src, srcStat, dest, "move");
    if (!isParentRoot(dest))
      mkdirpSync(path2.dirname(dest));
    return doRename(src, dest, overwrite, isChangingCase);
  }
  function isParentRoot(dest) {
    const parent = path2.dirname(dest);
    const parsedPath = path2.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase) {
    if (isChangingCase)
      return rename(src, dest, overwrite);
    if (overwrite) {
      removeSync(dest);
      return rename(src, dest, overwrite);
    }
    if (fs3.existsSync(dest))
      throw new Error("dest already exists.");
    return rename(src, dest, overwrite);
  }
  function rename(src, dest, overwrite) {
    try {
      fs3.renameSync(src, dest);
    } catch (err) {
      if (err.code !== "EXDEV")
        throw err;
      return moveAcrossDevice(src, dest, overwrite);
    }
  }
  function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
  }
  module2.exports = moveSync;
});

// node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    moveSync: require_move_sync()
  };
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS((exports2, module2) => {
  "use strict";
  var fs3 = require_graceful_fs();
  var path2 = require("path");
  var copy = require_copy2().copy;
  var remove = require_remove().remove;
  var mkdirp = require_mkdirs().mkdirp;
  var pathExists = require_path_exists().pathExists;
  var stat = require_stat();
  function move(src, dest, opts, cb) {
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    const overwrite = opts.overwrite || opts.clobber || false;
    stat.checkPaths(src, dest, "move", opts, (err, stats) => {
      if (err)
        return cb(err);
      const {srcStat, isChangingCase = false} = stats;
      stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
        if (err2)
          return cb(err2);
        if (isParentRoot(dest))
          return doRename(src, dest, overwrite, isChangingCase, cb);
        mkdirp(path2.dirname(dest), (err3) => {
          if (err3)
            return cb(err3);
          return doRename(src, dest, overwrite, isChangingCase, cb);
        });
      });
    });
  }
  function isParentRoot(dest) {
    const parent = path2.dirname(dest);
    const parsedPath = path2.parse(parent);
    return parsedPath.root === parent;
  }
  function doRename(src, dest, overwrite, isChangingCase, cb) {
    if (isChangingCase)
      return rename(src, dest, overwrite, cb);
    if (overwrite) {
      return remove(dest, (err) => {
        if (err)
          return cb(err);
        return rename(src, dest, overwrite, cb);
      });
    }
    pathExists(dest, (err, destExists) => {
      if (err)
        return cb(err);
      if (destExists)
        return cb(new Error("dest already exists."));
      return rename(src, dest, overwrite, cb);
    });
  }
  function rename(src, dest, overwrite, cb) {
    fs3.rename(src, dest, (err) => {
      if (!err)
        return cb();
      if (err.code !== "EXDEV")
        return cb(err);
      return moveAcrossDevice(src, dest, overwrite, cb);
    });
  }
  function moveAcrossDevice(src, dest, overwrite, cb) {
    const opts = {
      overwrite,
      errorOnExist: true
    };
    copy(src, dest, opts, (err) => {
      if (err)
        return cb(err);
      return remove(src, cb);
    });
  }
  module2.exports = move;
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS((exports2, module2) => {
  "use strict";
  var u = require_universalify().fromCallback;
  module2.exports = {
    move: u(require_move())
  };
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    ...require_fs(),
    ...require_copy_sync2(),
    ...require_copy2(),
    ...require_empty(),
    ...require_ensure(),
    ...require_json(),
    ...require_mkdirs(),
    ...require_move_sync2(),
    ...require_move2(),
    ...require_output(),
    ...require_path_exists(),
    ...require_remove()
  };
});

// node_modules/request-light/lib/node/main.js
var require_main = __commonJS((exports2) => {
  (() => {
    var e = {46: (e2, t2) => {
      "use strict";
      Object.defineProperty(t2, "__esModule", {value: true}), t2.default = function(e3, t3, {signal: r2} = {}) {
        return new Promise((o2, n2) => {
          function s() {
            r2 == null || r2.removeEventListener("abort", s), e3.removeListener(t3, a), e3.removeListener("error", u);
          }
          function a(...e4) {
            s(), o2(e4);
          }
          function u(e4) {
            s(), n2(e4);
          }
          r2 == null || r2.addEventListener("abort", s), e3.on(t3, a), e3.on("error", u);
        });
      };
    }, 54: function(e2, t2, r2) {
      "use strict";
      var o2 = this && this.__importDefault || function(e3) {
        return e3 && e3.__esModule ? e3 : {default: e3};
      };
      const n2 = r2(361), s = o2(r2(374)), a = o2(r2(304)), u = s.default("agent-base");
      function i() {
        const {stack: e3} = new Error();
        return typeof e3 == "string" && e3.split("\n").some((e4) => e4.indexOf("(https.js:") !== -1 || e4.indexOf("node:https:") !== -1);
      }
      function c(e3, t3) {
        return new c.Agent(e3, t3);
      }
      !function(e3) {
        class t3 extends n2.EventEmitter {
          constructor(e4, t5) {
            super();
            let r3 = t5;
            typeof e4 == "function" ? this.callback = e4 : e4 && (r3 = e4), this.timeout = null, r3 && typeof r3.timeout == "number" && (this.timeout = r3.timeout), this.maxFreeSockets = 1, this.maxSockets = 1, this.maxTotalSockets = 1 / 0, this.sockets = {}, this.freeSockets = {}, this.requests = {}, this.options = {};
          }
          get defaultPort() {
            return typeof this.explicitDefaultPort == "number" ? this.explicitDefaultPort : i() ? 443 : 80;
          }
          set defaultPort(e4) {
            this.explicitDefaultPort = e4;
          }
          get protocol() {
            return typeof this.explicitProtocol == "string" ? this.explicitProtocol : i() ? "https:" : "http:";
          }
          set protocol(e4) {
            this.explicitProtocol = e4;
          }
          callback(e4, t5, r3) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
          }
          addRequest(e4, t5) {
            const r3 = Object.assign({}, t5);
            typeof r3.secureEndpoint != "boolean" && (r3.secureEndpoint = i()), r3.host == null && (r3.host = "localhost"), r3.port == null && (r3.port = r3.secureEndpoint ? 443 : 80), r3.protocol == null && (r3.protocol = r3.secureEndpoint ? "https:" : "http:"), r3.host && r3.path && delete r3.path, delete r3.agent, delete r3.hostname, delete r3._defaultAgent, delete r3.defaultPort, delete r3.createConnection, e4._last = true, e4.shouldKeepAlive = false;
            let o3 = false, n3 = null;
            const s2 = r3.timeout || this.timeout, c2 = (t6) => {
              e4._hadError || (e4.emit("error", t6), e4._hadError = true);
            }, l = () => {
              n3 = null, o3 = true;
              const e5 = new Error(`A "socket" was not created for HTTP request before ${s2}ms`);
              e5.code = "ETIMEOUT", c2(e5);
            }, d = (e5) => {
              o3 || (n3 !== null && (clearTimeout(n3), n3 = null), c2(e5));
            }, f = (t6) => {
              if (o3)
                return;
              if (n3 != null && (clearTimeout(n3), n3 = null), s3 = t6, Boolean(s3) && typeof s3.addRequest == "function")
                return u("Callback returned another Agent instance %o", t6.constructor.name), void t6.addRequest(e4, r3);
              var s3;
              if (t6)
                return t6.once("free", () => {
                  this.freeSocket(t6, r3);
                }), void e4.onSocket(t6);
              const a2 = new Error(`no Duplex stream was returned to agent-base for \`${e4.method} ${e4.path}\``);
              c2(a2);
            };
            if (typeof this.callback == "function") {
              this.promisifiedCallback || (this.callback.length >= 3 ? (u("Converting legacy callback function to promise"), this.promisifiedCallback = a.default(this.callback)) : this.promisifiedCallback = this.callback), typeof s2 == "number" && s2 > 0 && (n3 = setTimeout(l, s2)), "port" in r3 && typeof r3.port != "number" && (r3.port = Number(r3.port));
              try {
                u("Resolving socket for %o request: %o", r3.protocol, `${e4.method} ${e4.path}`), Promise.resolve(this.promisifiedCallback(e4, r3)).then(f, d);
              } catch (e5) {
                Promise.reject(e5).catch(d);
              }
            } else
              c2(new Error("`callback` is not defined"));
          }
          freeSocket(e4, t5) {
            u("Freeing socket %o %o", e4.constructor.name, t5), e4.destroy();
          }
          destroy() {
            u("Destroying agent %o", this.constructor.name);
          }
        }
        e3.Agent = t3, e3.prototype = e3.Agent.prototype;
      }(c || (c = {})), e2.exports = c;
    }, 304: (e2, t2) => {
      "use strict";
      Object.defineProperty(t2, "__esModule", {value: true}), t2.default = function(e3) {
        return function(t3, r2) {
          return new Promise((o2, n2) => {
            e3.call(this, t3, r2, (e4, t4) => {
              e4 ? n2(e4) : o2(t4);
            });
          });
        };
      };
    }, 370: function(e2, t2, r2) {
      "use strict";
      var o2 = this && this.__awaiter || function(e3, t3, r3, o3) {
        return new (r3 || (r3 = Promise))(function(n3, s2) {
          function a2(e4) {
            try {
              i2(o3.next(e4));
            } catch (e5) {
              s2(e5);
            }
          }
          function u2(e4) {
            try {
              i2(o3.throw(e4));
            } catch (e5) {
              s2(e5);
            }
          }
          function i2(e4) {
            var t4;
            e4.done ? n3(e4.value) : (t4 = e4.value, t4 instanceof r3 ? t4 : new r3(function(e5) {
              e5(t4);
            })).then(a2, u2);
          }
          i2((o3 = o3.apply(e3, t3 || [])).next());
        });
      }, n2 = this && this.__importDefault || function(e3) {
        return e3 && e3.__esModule ? e3 : {default: e3};
      };
      Object.defineProperty(t2, "__esModule", {value: true});
      const s = n2(r2(808)), a = n2(r2(404)), u = n2(r2(310)), i = n2(r2(374)), c = n2(r2(46)), l = r2(54), d = (0, i.default)("http-proxy-agent");
      class f extends l.Agent {
        constructor(e3) {
          let t3;
          if (t3 = typeof e3 == "string" ? u.default.parse(e3) : e3, !t3)
            throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
          d("Creating new HttpProxyAgent instance: %o", t3), super(t3);
          const r3 = Object.assign({}, t3);
          var o3;
          this.secureProxy = t3.secureProxy || typeof (o3 = r3.protocol) == "string" && /^https:?$/i.test(o3), r3.host = r3.hostname || r3.host, typeof r3.port == "string" && (r3.port = parseInt(r3.port, 10)), !r3.port && r3.host && (r3.port = this.secureProxy ? 443 : 80), r3.host && r3.path && (delete r3.path, delete r3.pathname), this.proxy = r3;
        }
        callback(e3, t3) {
          return o2(this, void 0, void 0, function* () {
            const {proxy: r3, secureProxy: o3} = this, n3 = u.default.parse(e3.path);
            let i2;
            if (n3.protocol || (n3.protocol = "http:"), n3.hostname || (n3.hostname = t3.hostname || t3.host || null), n3.port == null && (t3.port, 1) && (n3.port = String(t3.port)), n3.port === "80" && (n3.port = ""), e3.path = u.default.format(n3), r3.auth && e3.setHeader("Proxy-Authorization", `Basic ${Buffer.from(r3.auth).toString("base64")}`), o3 ? (d("Creating `tls.Socket`: %o", r3), i2 = a.default.connect(r3)) : (d("Creating `net.Socket`: %o", r3), i2 = s.default.connect(r3)), e3._header) {
              let t4, r4;
              d("Regenerating stored HTTP header string for request"), e3._header = null, e3._implicitHeader(), e3.output && e3.output.length > 0 ? (d("Patching connection write() output buffer with updated header"), t4 = e3.output[0], r4 = t4.indexOf("\r\n\r\n") + 4, e3.output[0] = e3._header + t4.substring(r4), d("Output buffer: %o", e3.output)) : e3.outputData && e3.outputData.length > 0 && (d("Patching connection write() output buffer with updated header"), t4 = e3.outputData[0].data, r4 = t4.indexOf("\r\n\r\n") + 4, e3.outputData[0].data = e3._header + t4.substring(r4), d("Output buffer: %o", e3.outputData[0].data));
            }
            return yield (0, c.default)(i2, "connect"), i2;
          });
        }
      }
      t2.default = f;
    }, 201: function(e2, t2, r2) {
      "use strict";
      const o2 = (this && this.__importDefault || function(e3) {
        return e3 && e3.__esModule ? e3 : {default: e3};
      })(r2(370));
      function n2(e3) {
        return new o2.default(e3);
      }
      !function(e3) {
        e3.HttpProxyAgent = o2.default, e3.prototype = o2.default.prototype;
      }(n2 || (n2 = {})), e2.exports = n2;
    }, 146: function(e2, t2, r2) {
      "use strict";
      var o2 = this && this.__awaiter || function(e3, t3, r3, o3) {
        return new (r3 || (r3 = Promise))(function(n3, s2) {
          function a2(e4) {
            try {
              i2(o3.next(e4));
            } catch (e5) {
              s2(e5);
            }
          }
          function u2(e4) {
            try {
              i2(o3.throw(e4));
            } catch (e5) {
              s2(e5);
            }
          }
          function i2(e4) {
            var t4;
            e4.done ? n3(e4.value) : (t4 = e4.value, t4 instanceof r3 ? t4 : new r3(function(e5) {
              e5(t4);
            })).then(a2, u2);
          }
          i2((o3 = o3.apply(e3, t3 || [])).next());
        });
      }, n2 = this && this.__importDefault || function(e3) {
        return e3 && e3.__esModule ? e3 : {default: e3};
      };
      Object.defineProperty(t2, "__esModule", {value: true});
      const s = n2(r2(808)), a = n2(r2(404)), u = n2(r2(310)), i = n2(r2(491)), c = n2(r2(374)), l = r2(54), d = n2(r2(829)), f = c.default("https-proxy-agent:agent");
      class p extends l.Agent {
        constructor(e3) {
          let t3;
          if (t3 = typeof e3 == "string" ? u.default.parse(e3) : e3, !t3)
            throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
          f("creating new HttpsProxyAgent instance: %o", t3), super(t3);
          const r3 = Object.assign({}, t3);
          var o3;
          this.secureProxy = t3.secureProxy || typeof (o3 = r3.protocol) == "string" && /^https:?$/i.test(o3), r3.host = r3.hostname || r3.host, typeof r3.port == "string" && (r3.port = parseInt(r3.port, 10)), !r3.port && r3.host && (r3.port = this.secureProxy ? 443 : 80), this.secureProxy && !("ALPNProtocols" in r3) && (r3.ALPNProtocols = ["http 1.1"]), r3.host && r3.path && (delete r3.path, delete r3.pathname), this.proxy = r3;
        }
        callback(e3, t3) {
          return o2(this, void 0, void 0, function* () {
            const {proxy: r3, secureProxy: o3} = this;
            let n3;
            o3 ? (f("Creating `tls.Socket`: %o", r3), n3 = a.default.connect(r3)) : (f("Creating `net.Socket`: %o", r3), n3 = s.default.connect(r3));
            const u2 = Object.assign({}, r3.headers);
            let c2 = `CONNECT ${t3.host}:${t3.port} HTTP/1.1\r
`;
            r3.auth && (u2["Proxy-Authorization"] = `Basic ${Buffer.from(r3.auth).toString("base64")}`);
            let {host: l2, port: p3, secureEndpoint: g} = t3;
            (function(e4, t4) {
              return Boolean(!t4 && e4 === 80 || t4 && e4 === 443);
            })(p3, g) || (l2 += `:${p3}`), u2.Host = l2, u2.Connection = "close";
            for (const e4 of Object.keys(u2))
              c2 += `${e4}: ${u2[e4]}\r
`;
            const v = d.default(n3);
            n3.write(`${c2}\r
`);
            const {statusCode: m, buffered: y} = yield v;
            if (m === 200) {
              if (e3.once("socket", h), t3.secureEndpoint) {
                const e4 = t3.servername || t3.host;
                if (!e4)
                  throw new Error('Could not determine "servername"');
                return f("Upgrading socket connection to TLS"), a.default.connect(Object.assign(Object.assign({}, function(e5, ...t4) {
                  const r4 = {};
                  let o4;
                  for (o4 in e5)
                    t4.includes(o4) || (r4[o4] = e5[o4]);
                  return r4;
                }(t3, "host", "hostname", "path", "port")), {socket: n3, servername: e4}));
              }
              return n3;
            }
            n3.destroy();
            const b = new s.default.Socket();
            return b.readable = true, e3.once("socket", (e4) => {
              f("replaying proxy buffer for failed request"), i.default(e4.listenerCount("data") > 0), e4.push(y), e4.push(null);
            }), b;
          });
        }
      }
      function h(e3) {
        e3.resume();
      }
      t2.default = p;
    }, 18: function(e2, t2, r2) {
      "use strict";
      const o2 = (this && this.__importDefault || function(e3) {
        return e3 && e3.__esModule ? e3 : {default: e3};
      })(r2(146));
      function n2(e3) {
        return new o2.default(e3);
      }
      !function(e3) {
        e3.HttpsProxyAgent = o2.default, e3.prototype = o2.default.prototype;
      }(n2 || (n2 = {})), e2.exports = n2;
    }, 829: function(e2, t2, r2) {
      "use strict";
      var o2 = this && this.__importDefault || function(e3) {
        return e3 && e3.__esModule ? e3 : {default: e3};
      };
      Object.defineProperty(t2, "__esModule", {value: true});
      const n2 = o2(r2(374)).default("https-proxy-agent:parse-proxy-response");
      t2.default = function(e3) {
        return new Promise((t3, r3) => {
          let o3 = 0;
          const s = [];
          function a() {
            const r4 = e3.read();
            r4 ? function(e4) {
              s.push(e4), o3 += e4.length;
              const r5 = Buffer.concat(s, o3);
              if (r5.indexOf("\r\n\r\n") === -1)
                return n2("have not received end of HTTP headers yet..."), void a();
              const u2 = r5.toString("ascii", 0, r5.indexOf("\r\n")), i2 = +u2.split(" ")[1];
              n2("got proxy server response: %o", u2), t3({statusCode: i2, buffered: r5});
            }(r4) : e3.once("readable", a);
          }
          function u(e4) {
            n2("onclose had error %o", e4);
          }
          function i() {
            n2("onend");
          }
          e3.on("error", function t4(o4) {
            e3.removeListener("end", i), e3.removeListener("error", t4), e3.removeListener("close", u), e3.removeListener("readable", a), n2("onerror %o", o4), r3(o4);
          }), e3.on("close", u), e3.on("end", i), a();
        });
      };
    }, 539: function(e2, t2, r2) {
      "use strict";
      var o2 = this && this.__assign || function() {
        return o2 = Object.assign || function(e3) {
          for (var t3, r3 = 1, o3 = arguments.length; r3 < o3; r3++)
            for (var n3 in t3 = arguments[r3])
              Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
          return e3;
        }, o2.apply(this, arguments);
      };
      Object.defineProperty(t2, "__esModule", {value: true}), t2.getErrorStatusDescription = t2.xhr = t2.configure = void 0;
      var n2 = r2(310), s = r2(687), a = r2(685), u = r2(796), i = r2(472), c = r2(18), l = r2(201);
      if (process.env.VSCODE_NLS_CONFIG) {
        var d = process.env.VSCODE_NLS_CONFIG;
        i.config(JSON.parse(d));
      }
      var f = i.loadMessageBundle(), p = null, h = true;
      function g(e3) {
        var t3;
        return new Promise(function(r3, o3) {
          var u2 = (0, n2.parse)(e3.url), i2 = {hostname: u2.hostname, agent: !!e3.agent && e3.agent, port: u2.port ? parseInt(u2.port) : u2.protocol === "https:" ? 443 : 80, path: u2.path, method: e3.type || "GET", headers: e3.headers, rejectUnauthorized: typeof e3.strictSSL != "boolean" || e3.strictSSL};
          e3.user && e3.password && (i2.auth = e3.user + ":" + e3.password);
          var c2 = function(o4) {
            if (o4.statusCode >= 300 && o4.statusCode < 400 && e3.followRedirects && e3.followRedirects > 0 && o4.headers.location) {
              var s2 = o4.headers.location;
              s2.startsWith("/") && (s2 = (0, n2.format)({protocol: u2.protocol, hostname: u2.hostname, port: u2.port, pathname: s2})), r3(g(function(e4) {
                for (var t4 = [], r4 = 1; r4 < arguments.length; r4++)
                  t4[r4 - 1] = arguments[r4];
                return t4.forEach(function(t5) {
                  return Object.keys(t5).forEach(function(r5) {
                    return e4[r5] = t5[r5];
                  });
                }), e4;
              }({}, e3, {url: s2, followRedirects: e3.followRedirects - 1})));
            } else
              r3({req: t3, res: o4});
          };
          (t3 = u2.protocol === "https:" ? s.request(i2, c2) : a.request(i2, c2)).on("error", o3), e3.timeout && t3.setTimeout(e3.timeout), e3.data && t3.write(e3.data), t3.end();
        });
      }
      t2.configure = function(e3, t3) {
        p = e3, h = t3;
      }, t2.xhr = function(e3) {
        return typeof (e3 = o2({}, e3)).strictSSL != "boolean" && (e3.strictSSL = h), e3.agent || (e3.agent = function(e4, t3) {
          t3 === void 0 && (t3 = {});
          var r3 = (0, n2.parse)(e4), o3 = t3.proxyUrl || function(e5) {
            return e5.protocol === "http:" ? process.env.HTTP_PROXY || process.env.http_proxy || null : e5.protocol === "https:" && (process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy) || null;
          }(r3);
          if (!o3)
            return null;
          var s2 = (0, n2.parse)(o3);
          if (!/^https?:$/.test(s2.protocol))
            return null;
          var a2 = {host: s2.hostname, port: Number(s2.port), auth: s2.auth, rejectUnauthorized: typeof t3.strictSSL != "boolean" || t3.strictSSL, protocol: s2.protocol};
          return r3.protocol === "http:" ? l(a2) : c(a2);
        }(e3.url, {proxyUrl: p, strictSSL: h})), typeof e3.followRedirects != "number" && (e3.followRedirects = 5), g(e3).then(function(r3) {
          return new Promise(function(o3, s2) {
            var a2, i2, c2 = r3.res, l2 = c2, d2 = false, p2 = c2.headers && c2.headers["content-encoding"];
            if (p2 && (a2 = e3.type, i2 = r3.res.statusCode, !(a2 === "HEAD" || i2 >= 100 && i2 < 200 || i2 === 204 || i2 === 304))) {
              var h2 = {flush: u.constants.Z_SYNC_FLUSH, finishFlush: u.constants.Z_SYNC_FLUSH};
              if (p2 === "gzip") {
                var g2 = u.createGunzip(h2);
                c2.pipe(g2), l2 = g2;
              } else if (p2 === "deflate") {
                var v = u.createInflate(h2);
                c2.pipe(v), l2 = v;
              }
            }
            var m = [];
            l2.on("data", function(e4) {
              return m.push(e4);
            }), l2.on("end", function() {
              if (!d2) {
                if (d2 = true, e3.followRedirects > 0 && (c2.statusCode >= 300 && c2.statusCode <= 303 || c2.statusCode === 307)) {
                  var r4 = c2.headers.location;
                  if (r4.startsWith("/")) {
                    var a3 = (0, n2.parse)(e3.url);
                    r4 = (0, n2.format)({protocol: a3.protocol, hostname: a3.hostname, port: a3.port, pathname: r4});
                  }
                  if (r4) {
                    var u2 = {type: e3.type, url: r4, user: e3.user, password: e3.password, headers: e3.headers, timeout: e3.timeout, followRedirects: e3.followRedirects - 1, data: e3.data};
                    return void (0, t2.xhr)(u2).then(o3, s2);
                  }
                }
                var i3 = Buffer.concat(m), l3 = {responseText: i3.toString(), body: i3, status: c2.statusCode, headers: c2.headers || {}};
                c2.statusCode >= 200 && c2.statusCode < 300 || c2.statusCode === 1223 ? o3(l3) : s2(l3);
              }
            }), l2.on("error", function(t3) {
              var r4 = {responseText: f("error", "Unable to access {0}. Error: {1}", e3.url, t3.message), body: Buffer.concat(m), status: 500, headers: {}};
              d2 = true, s2(r4);
            });
          });
        }, function(t3) {
          var r3;
          return r3 = e3.agent ? f("error.cannot.connect.proxy", "Unable to connect to {0} through a proxy. Error: {1}", e3.url, t3.message) : f("error.cannot.connect", "Unable to connect to {0}. Error: {1}", e3.url, t3.message), Promise.reject({responseText: r3, body: Buffer.concat([]), status: 404, headers: {}});
        });
      }, t2.getErrorStatusDescription = function(e3) {
        if (!(e3 < 400))
          switch (e3) {
            case 400:
              return f("status.400", "Bad request. The request cannot be fulfilled due to bad syntax.");
            case 401:
              return f("status.401", "Unauthorized. The server is refusing to respond.");
            case 403:
              return f("status.403", "Forbidden. The server is refusing to respond.");
            case 404:
              return f("status.404", "Not Found. The requested location could not be found.");
            case 405:
              return f("status.405", "Method not allowed. A request was made using a request method not supported by that location.");
            case 406:
              return f("status.406", "Not Acceptable. The server can only generate a response that is not accepted by the client.");
            case 407:
              return f("status.407", "Proxy Authentication Required. The client must first authenticate itself with the proxy.");
            case 408:
              return f("status.408", "Request Timeout. The server timed out waiting for the request.");
            case 409:
              return f("status.409", "Conflict. The request could not be completed because of a conflict in the request.");
            case 410:
              return f("status.410", "Gone. The requested page is no longer available.");
            case 411:
              return f("status.411", 'Length Required. The "Content-Length" is not defined.');
            case 412:
              return f("status.412", "Precondition Failed. The precondition given in the request evaluated to false by the server.");
            case 413:
              return f("status.413", "Request Entity Too Large. The server will not accept the request, because the request entity is too large.");
            case 414:
              return f("status.414", "Request-URI Too Long. The server will not accept the request, because the URL is too long.");
            case 415:
              return f("status.415", "Unsupported Media Type. The server will not accept the request, because the media type is not supported.");
            case 500:
              return f("status.500", "Internal Server Error.");
            case 501:
              return f("status.501", "Not Implemented. The server either does not recognize the request method, or it lacks the ability to fulfill the request.");
            case 503:
              return f("status.503", "Service Unavailable. The server is currently unavailable (overloaded or down).");
            default:
              return f("status.416", "HTTP status code {0}", e3);
          }
      };
    }, 800: (e2, t2, r2) => {
      "use strict";
      Object.defineProperty(t2, "__esModule", {value: true}), t2.config = t2.loadMessageBundle = t2.localize = t2.format = t2.setPseudo = t2.isPseudo = t2.isDefined = t2.BundleFormat = t2.MessageFormat = void 0;
      var o2, n2, s, a = r2(926);
      function u(e3) {
        return e3 !== void 0;
      }
      function i(e3, r3) {
        return t2.isPseudo && (e3 = "\uFF3B" + e3.replace(/[aouei]/g, "$&$&") + "\uFF3D"), r3.length === 0 ? e3 : e3.replace(/\{(\d+)\}/g, function(e4, t3) {
          var o3 = t3[0], n3 = r3[o3], s2 = e4;
          return typeof n3 == "string" ? s2 = n3 : typeof n3 != "number" && typeof n3 != "boolean" && n3 != null || (s2 = String(n3)), s2;
        });
      }
      (s = t2.MessageFormat || (t2.MessageFormat = {})).file = "file", s.bundle = "bundle", s.both = "both", (n2 = t2.BundleFormat || (t2.BundleFormat = {})).standalone = "standalone", n2.languagePack = "languagePack", function(e3) {
        e3.is = function(e4) {
          var t3 = e4;
          return t3 && u(t3.key) && u(t3.comment);
        };
      }(o2 || (o2 = {})), t2.isDefined = u, t2.isPseudo = false, t2.setPseudo = function(e3) {
        t2.isPseudo = e3;
      }, t2.format = i, t2.localize = function(e3, t3) {
        for (var r3 = [], o3 = 2; o3 < arguments.length; o3++)
          r3[o3 - 2] = arguments[o3];
        return i(t3, r3);
      }, t2.loadMessageBundle = function(e3) {
        return a.default().loadMessageBundle(e3);
      }, t2.config = function(e3) {
        return a.default().config(e3);
      };
    }, 926: (e2, t2) => {
      "use strict";
      var r2;
      function o2() {
        if (r2 === void 0)
          throw new Error("No runtime abstraction layer installed");
        return r2;
      }
      Object.defineProperty(t2, "__esModule", {value: true}), function(e3) {
        e3.install = function(e4) {
          if (e4 === void 0)
            throw new Error("No runtime abstraction layer provided");
          r2 = e4;
        };
      }(o2 || (o2 = {})), t2.default = o2;
    }, 472: (e2, t2, r2) => {
      "use strict";
      Object.defineProperty(t2, "__esModule", {value: true}), t2.config = t2.loadMessageBundle = void 0;
      var o2 = r2(17), n2 = r2(147), s = r2(926), a = r2(800), u = r2(800);
      Object.defineProperty(t2, "MessageFormat", {enumerable: true, get: function() {
        return u.MessageFormat;
      }}), Object.defineProperty(t2, "BundleFormat", {enumerable: true, get: function() {
        return u.BundleFormat;
      }});
      var i, c, l = Object.prototype.toString;
      function d(e3) {
        return l.call(e3) === "[object Number]";
      }
      function f(e3) {
        return l.call(e3) === "[object String]";
      }
      function p(e3) {
        return JSON.parse(n2.readFileSync(e3, "utf8"));
      }
      function h(e3) {
        return function(t3, r3) {
          for (var o3 = [], n3 = 2; n3 < arguments.length; n3++)
            o3[n3 - 2] = arguments[n3];
          return d(t3) ? t3 >= e3.length ? void console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: " + new Error("").stack) : a.format(e3[t3], o3) : f(r3) ? (console.warn("Message " + r3 + " didn't get externalized correctly."), a.format(r3, o3)) : void console.error("Broken localize call found. Stacktrace is\n: " + new Error("").stack);
        };
      }
      function g(e3, t3) {
        return i[e3] = t3, t3;
      }
      function v(e3) {
        try {
          return function(e4) {
            var t3 = p(o2.join(e4, "nls.metadata.json")), r3 = Object.create(null);
            for (var n3 in t3) {
              var s2 = t3[n3];
              r3[n3] = s2.messages;
            }
            return r3;
          }(e3);
        } catch (e4) {
          return void console.log("Generating default bundle from meta data failed.", e4);
        }
      }
      function m(e3, t3) {
        var r3;
        if (c.languagePackSupport === true && c.cacheRoot !== void 0 && c.languagePackId !== void 0 && c.translationsConfigFile !== void 0 && c.translationsConfig !== void 0)
          try {
            r3 = function(e4, t4) {
              var r4, s3, a2, u2 = o2.join(c.cacheRoot, e4.id + "-" + e4.hash + ".json"), i2 = false, l2 = false;
              try {
                return r4 = JSON.parse(n2.readFileSync(u2, {encoding: "utf8", flag: "r"})), s3 = u2, a2 = new Date(), n2.utimes(s3, a2, a2, function() {
                }), r4;
              } catch (e5) {
                if (e5.code === "ENOENT")
                  l2 = true;
                else {
                  if (!(e5 instanceof SyntaxError))
                    throw e5;
                  console.log("Syntax error parsing message bundle: " + e5.message + "."), n2.unlink(u2, function(e6) {
                    e6 && console.error("Deleting corrupted bundle " + u2 + " failed.");
                  }), i2 = true;
                }
              }
              if (r4 = function(e5, t5) {
                var r5 = c.translationsConfig[e5.id];
                if (r5) {
                  var n3 = p(r5).contents, s4 = p(o2.join(t5, "nls.metadata.json")), a3 = Object.create(null);
                  for (var u3 in s4) {
                    var i3 = s4[u3], l3 = n3[e5.outDir + "/" + u3];
                    if (l3) {
                      for (var d2 = [], h2 = 0; h2 < i3.keys.length; h2++) {
                        var g2 = i3.keys[h2], v2 = l3[f(g2) ? g2 : g2.key];
                        v2 === void 0 && (v2 = i3.messages[h2]), d2.push(v2);
                      }
                      a3[u3] = d2;
                    } else
                      a3[u3] = i3.messages;
                  }
                  return a3;
                }
              }(e4, t4), !r4 || i2)
                return r4;
              if (l2)
                try {
                  n2.writeFileSync(u2, JSON.stringify(r4), {encoding: "utf8", flag: "wx"});
                } catch (e5) {
                  if (e5.code === "EEXIST")
                    return r4;
                  throw e5;
                }
              return r4;
            }(e3, t3);
          } catch (e4) {
            console.log("Load or create bundle failed ", e4);
          }
        if (!r3) {
          if (c.languagePackSupport)
            return v(t3);
          var s2 = function(e4) {
            for (var t4 = c.language; t4; ) {
              var r4 = o2.join(e4, "nls.bundle." + t4 + ".json");
              if (n2.existsSync(r4))
                return r4;
              var s3 = t4.lastIndexOf("-");
              t4 = s3 > 0 ? t4.substring(0, s3) : void 0;
            }
            if (t4 === void 0 && (r4 = o2.join(e4, "nls.bundle.json"), n2.existsSync(r4)))
              return r4;
          }(t3);
          if (s2)
            try {
              return p(s2);
            } catch (e4) {
              console.log("Loading in the box message bundle failed.", e4);
            }
          r3 = v(t3);
        }
        return r3;
      }
      function y(e3) {
        if (!e3)
          return a.localize;
        var t3 = o2.extname(e3);
        if (t3 && (e3 = e3.substr(0, e3.length - t3.length)), c.messageFormat === a.MessageFormat.both || c.messageFormat === a.MessageFormat.bundle) {
          var r3 = function(e4) {
            for (var t4, r4 = o2.dirname(e4); t4 = o2.join(r4, "nls.metadata.header.json"), !n2.existsSync(t4); ) {
              var s3 = o2.dirname(r4);
              if (s3 === r4) {
                t4 = void 0;
                break;
              }
              r4 = s3;
            }
            return t4;
          }(e3);
          if (r3) {
            var s2 = o2.dirname(r3), u2 = i[s2];
            if (u2 === void 0)
              try {
                var l2 = JSON.parse(n2.readFileSync(r3, "utf8"));
                try {
                  var d2 = m(l2, s2);
                  u2 = g(s2, d2 ? {header: l2, nlsBundle: d2} : null);
                } catch (e4) {
                  console.error("Failed to load nls bundle", e4), u2 = g(s2, null);
                }
              } catch (e4) {
                console.error("Failed to read header file", e4), u2 = g(s2, null);
              }
            if (u2) {
              var f2 = e3.substr(s2.length + 1).replace(/\\/g, "/"), v2 = u2.nlsBundle[f2];
              return v2 === void 0 ? (console.error("Messages for file " + e3 + " not found. See console for details."), function() {
                return "Messages not found.";
              }) : h(v2);
            }
          }
        }
        if (c.messageFormat === a.MessageFormat.both || c.messageFormat === a.MessageFormat.file)
          try {
            var y2 = p(function(e4) {
              var t4;
              if (c.cacheLanguageResolution && t4)
                t4 = t4;
              else {
                if (a.isPseudo || !c.language)
                  t4 = ".nls.json";
                else
                  for (var r4 = c.language; r4; ) {
                    var o3 = ".nls." + r4 + ".json";
                    if (n2.existsSync(e4 + o3)) {
                      t4 = o3;
                      break;
                    }
                    var s3 = r4.lastIndexOf("-");
                    s3 > 0 ? r4 = r4.substring(0, s3) : (t4 = ".nls.json", r4 = null);
                  }
                c.cacheLanguageResolution && (t4 = t4);
              }
              return e4 + t4;
            }(e3));
            return Array.isArray(y2) ? h(y2) : a.isDefined(y2.messages) && a.isDefined(y2.keys) ? h(y2.messages) : (console.error("String bundle '" + e3 + "' uses an unsupported format."), function() {
              return "File bundle has unsupported format. See console for details";
            });
          } catch (e4) {
            e4.code !== "ENOENT" && console.error("Failed to load single file bundle", e4);
          }
        return console.error("Failed to load message bundle for file " + e3), function() {
          return "Failed to load message bundle. See console for details.";
        };
      }
      function b(e3) {
        return e3 && (f(e3.locale) && (c.locale = e3.locale.toLowerCase(), c.language = c.locale, i = Object.create(null)), e3.messageFormat !== void 0 && (c.messageFormat = e3.messageFormat), e3.bundleFormat === a.BundleFormat.standalone && c.languagePackSupport === true && (c.languagePackSupport = false)), a.setPseudo(c.locale === "pseudo"), y;
      }
      !function() {
        if (c = {locale: void 0, language: void 0, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: a.MessageFormat.bundle}, f(process.env.VSCODE_NLS_CONFIG))
          try {
            var e3 = JSON.parse(process.env.VSCODE_NLS_CONFIG), t3 = void 0;
            if (e3.availableLanguages) {
              var r3 = e3.availableLanguages["*"];
              f(r3) && (t3 = r3);
            }
            if (f(e3.locale) && (c.locale = e3.locale.toLowerCase()), t3 === void 0 ? c.language = c.locale : t3 !== "en" && (c.language = t3), function(e4) {
              return e4 === true || e4 === false;
            }(e3._languagePackSupport) && (c.languagePackSupport = e3._languagePackSupport), f(e3._cacheRoot) && (c.cacheRoot = e3._cacheRoot), f(e3._languagePackId) && (c.languagePackId = e3._languagePackId), f(e3._translationsConfigFile)) {
              c.translationsConfigFile = e3._translationsConfigFile;
              try {
                c.translationsConfig = p(c.translationsConfigFile);
              } catch (t4) {
                if (e3._corruptedFile) {
                  var s2 = o2.dirname(e3._corruptedFile);
                  n2.exists(s2, function(t5) {
                    t5 && n2.writeFile(e3._corruptedFile, "corrupted", "utf8", function(e4) {
                      console.error(e4);
                    });
                  });
                }
              }
            }
          } catch (e4) {
          }
        a.setPseudo(c.locale === "pseudo"), i = Object.create(null);
      }(), t2.loadMessageBundle = y, t2.config = b, s.default.install(Object.freeze({loadMessageBundle: y, config: b}));
    }, 374: (e2, t2) => {
      function r2() {
      }
      Object.defineProperty(t2, "__esModule", {value: true}), t2.default = function(e3) {
        return r2;
      };
    }, 491: (e2) => {
      "use strict";
      e2.exports = require("assert");
    }, 361: (e2) => {
      "use strict";
      e2.exports = require("events");
    }, 147: (e2) => {
      "use strict";
      e2.exports = require("fs");
    }, 685: (e2) => {
      "use strict";
      e2.exports = require("http");
    }, 687: (e2) => {
      "use strict";
      e2.exports = require("https");
    }, 808: (e2) => {
      "use strict";
      e2.exports = require("net");
    }, 17: (e2) => {
      "use strict";
      e2.exports = require("path");
    }, 404: (e2) => {
      "use strict";
      e2.exports = require("tls");
    }, 310: (e2) => {
      "use strict";
      e2.exports = require("url");
    }, 796: (e2) => {
      "use strict";
      e2.exports = require("zlib");
    }}, t = {}, r = function r2(o2) {
      var n2 = t[o2];
      if (n2 !== void 0)
        return n2.exports;
      var s = t[o2] = {exports: {}};
      return e[o2].call(s.exports, s, s.exports, r2), s.exports;
    }(539), o = exports2;
    for (var n in r)
      o[n] = r[n];
    r.__esModule && Object.defineProperty(o, "__esModule", {value: true});
  })();
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  SchemaSelectionRequests: () => SchemaSelectionRequests,
  activate: () => activate
});
var import_coc5 = __toModule(require("coc.nvim"));

// src/schema-extension-api.ts
var import_coc = __toModule(require("coc.nvim"));
var MODIFICATION_ACTIONS;
(function(MODIFICATION_ACTIONS2) {
  MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["delete"] = 0] = "delete";
  MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["add"] = 1] = "add";
})(MODIFICATION_ACTIONS || (MODIFICATION_ACTIONS = {}));
var SchemaModificationNotification;
(function(SchemaModificationNotification2) {
  SchemaModificationNotification2.type = new import_coc.RequestType("json/schema/modify");
})(SchemaModificationNotification || (SchemaModificationNotification = {}));
var SchemaExtensionAPI = class {
  constructor(client) {
    this._customSchemaContributors = {};
    this._yamlClient = client;
  }
  registerContributor(schema, requestSchema, requestSchemaContent, label) {
    if (this._customSchemaContributors[schema]) {
      return false;
    }
    if (!requestSchema) {
      throw new Error("Illegal parameter for requestSchema.");
    }
    if (label) {
      const [first, second] = label.split(":");
      if (first && second) {
        label = second.trim();
        label = label.replace(".", "\\.");
        label = `${first}:[	 ]+${label}`;
      }
    }
    this._customSchemaContributors[schema] = {
      requestSchema,
      requestSchemaContent,
      label
    };
    return true;
  }
  requestCustomSchema(resource) {
    const matches = [];
    for (const customKey of Object.keys(this._customSchemaContributors)) {
      try {
        const contributor = this._customSchemaContributors[customKey];
        let uri;
        if (contributor.label && import_coc.workspace.textDocuments) {
          const labelRegexp = new RegExp(contributor.label, "g");
          for (const doc of import_coc.workspace.textDocuments) {
            if (doc.uri.toString() === resource) {
              if (labelRegexp.test(doc.getText())) {
                uri = contributor.requestSchema(resource);
                return [uri];
              }
            }
          }
        }
        uri = contributor.requestSchema(resource);
        if (uri) {
          matches.push(uri);
        }
      } catch (error) {
        logToExtensionOutputChannel(`Error thrown while requesting schema "${error}" when calling the registered contributor "${customKey}"`);
      }
    }
    return matches;
  }
  requestCustomSchemaContent(uri) {
    if (uri) {
      const _uri = import_coc.Uri.parse(uri);
      if (_uri.scheme && this._customSchemaContributors[_uri.scheme] && this._customSchemaContributors[_uri.scheme].requestSchemaContent) {
        return this._customSchemaContributors[_uri.scheme].requestSchemaContent(uri);
      }
    }
  }
  async modifySchemaContent(schemaModifications) {
    return this._yamlClient.sendRequest(SchemaModificationNotification.type, schemaModifications);
  }
  hasProvider(schema) {
    return this._customSchemaContributors[schema] !== void 0;
  }
};
var CUSTOM_SCHEMA_REQUEST = "custom/schema/request";
var CUSTOM_CONTENT_REQUEST = "custom/schema/content";

// src/paths.ts
var Dot = ".".charCodeAt(0);
function normalizePath(parts) {
  const newParts = [];
  for (const part of parts) {
    if (part.length === 0 || part.length === 1 && part.charCodeAt(0) === Dot) {
    } else if (part.length === 2 && part.charCodeAt(0) === Dot && part.charCodeAt(1) === Dot) {
      newParts.pop();
    } else {
      newParts.push(part);
    }
  }
  if (parts.length > 1 && parts[parts.length - 1].length === 0) {
    newParts.push("");
  }
  let res = newParts.join("/");
  if (parts[0].length === 0) {
    res = "/" + res;
  }
  return res;
}
function joinPath(uri, ...paths) {
  const parts = uri.path.split("/");
  for (const path2 of paths) {
    parts.push(...path2.split("/"));
  }
  return uri.with({path: normalizePath(parts)});
}

// src/status-item.ts
var import_coc2 = __toModule(require("coc.nvim"));
var getSchema = new import_coc2.RequestType("yaml/get/jsonSchema");
var StatusBar = class {
  constructor(client) {
    this.client = client;
    this.disposables = [];
    this.attached = false;
    var _a;
    this.item = import_coc2.window.createStatusBarItem(99, {});
    let config = import_coc2.workspace.getConfiguration("yaml");
    this.text = (_a = config.statusText) != null ? _a : "yaml";
    import_coc2.events.on("BufEnter", (bufnr) => {
      let doc = import_coc2.workspace.getDocument(bufnr);
      if (doc)
        void this.checkDocument(doc);
    }, null, this.disposables);
    import_coc2.workspace.onDidOpenTextDocument((e) => {
      let doc = import_coc2.workspace.getDocument(import_coc2.workspace.bufnr);
      if (doc)
        void this.checkDocument(doc);
    }, null, this.disposables);
  }
  init() {
    this.attached = true;
    let doc = import_coc2.workspace.getDocument(import_coc2.workspace.bufnr);
    if (doc)
      void this.checkDocument(doc);
  }
  async checkDocument(doc) {
    var _a;
    if (!doc || !doc.attached || !this.attached)
      return;
    const item = this.item;
    if (!this.client.started) {
      item.hide();
      return;
    }
    if (doc.languageId === "yaml") {
      const schema = await this.client.sendRequest(getSchema, doc.uri);
      if (import_coc2.workspace.bufnr != doc.bufnr)
        return;
      if (!schema || schema.length === 0) {
        item.text = `${this.text} No JSON Schema`;
      } else if (schema.length === 1) {
        item.text = this.text + " " + ((_a = schema[0].name) != null ? _a : schema[0].uri);
      } else {
        item.text = `${this.text} Multiple JSON Schemas...`;
      }
      item.show();
    } else {
      item.hide();
    }
  }
  dispose() {
    import_coc2.disposeAll(this.disposables);
    this.item.dispose();
  }
};
var status_item_default = StatusBar;

// src/schema-cache.ts
var import_fs_extra = __toModule(require_lib());
var import_path = __toModule(require("path"));
var import_crypto = __toModule(require("crypto"));
var CACHE_DIR = "schemas_cache";
var CACHE_KEY = "json-schema-key";
var JSONSchemaCache = class {
  constructor(globalStoragePath, memento, log) {
    this.memento = memento;
    this.log = log;
    this.isInitialized = false;
    this.cachePath = import_path.default.join(globalStoragePath, CACHE_DIR);
    this.cache = memento.get(CACHE_KEY, {});
  }
  async init() {
    await import_fs_extra.default.ensureDir(this.cachePath);
    const cachedFiles = await import_fs_extra.default.readdir(this.cachePath);
    const cachedValues = cachedFiles.map((it) => import_path.default.join(this.cachePath, it));
    for (const key in this.cache) {
      if (Object.prototype.hasOwnProperty.call(this.cache, key)) {
        const cacheEntry = this.cache[key];
        if (!cachedValues.includes(cacheEntry.schemaPath)) {
          delete this.cache[key];
        }
      }
    }
    await this.memento.update(CACHE_KEY, this.cache);
    this.isInitialized = true;
  }
  getCacheFilePath(uri) {
    const hash = import_crypto.default.createHash("MD5");
    hash.update(uri);
    const hashedURI = hash.digest("hex");
    return import_path.default.join(this.cachePath, hashedURI);
  }
  getETag(schemaUri) {
    var _a;
    if (!this.isInitialized) {
      return void 0;
    }
    return (_a = this.cache[schemaUri]) == null ? void 0 : _a.eTag;
  }
  async putSchema(schemaUri, eTag, schemaContent) {
    if (!this.isInitialized) {
      await this.init();
    }
    if (!this.cache[schemaUri]) {
      this.cache[schemaUri] = {eTag, schemaPath: this.getCacheFilePath(schemaUri)};
    } else {
      this.cache[schemaUri].eTag = eTag;
    }
    try {
      const cacheFile = this.cache[schemaUri].schemaPath;
      await import_fs_extra.default.writeFile(cacheFile, schemaContent);
      await this.memento.update(CACHE_KEY, this.cache);
    } catch (err) {
      delete this.cache[schemaUri];
      this.log(err);
    }
  }
  async getSchema(schemaUri) {
    var _a;
    if (!this.isInitialized) {
      await this.init();
    }
    const cacheFile = (_a = this.cache[schemaUri]) == null ? void 0 : _a.schemaPath;
    if (await import_fs_extra.default.pathExists(cacheFile)) {
      return await import_fs_extra.default.readFile(cacheFile, {encoding: "UTF8"});
    }
    return void 0;
  }
};

// src/content-provider.ts
var import_coc3 = __toModule(require("coc.nvim"));
var import_request_light = __toModule(require_main());
var JSONSchemaDocumentContentProvider = class {
  constructor(schemaCache, schemaApi) {
    this.schemaCache = schemaCache;
    this.schemaApi = schemaApi;
  }
  async provideTextDocumentContent(uri) {
    if (uri.fragment) {
      const origUri = uri.fragment;
      const schemaUri = import_coc3.Uri.parse(origUri);
      if (origUri.startsWith("http")) {
        return getJsonSchemaContent(origUri, this.schemaCache);
      } else if (this.schemaApi.hasProvider(schemaUri.scheme)) {
        let content = this.schemaApi.requestCustomSchemaContent(origUri);
        content = await Promise.resolve(content);
        if (content.indexOf("\n") === -1) {
          content = JSON.stringify(JSON.parse(content), null, 2);
        }
        return content;
      } else {
        import_coc3.window.showErrorMessage(`Cannot Load content for: ${origUri}. Unknown schema: '${schemaUri.scheme}'`);
        return null;
      }
    } else {
      import_coc3.window.showErrorMessage(`Cannot Load content for: '${uri.toString()}' `);
      return null;
    }
  }
};
async function getJsonSchemaContent(uri, schemaCache) {
  const cachedETag = schemaCache.getETag(uri);
  const httpSettings = import_coc3.workspace.getConfiguration("http");
  import_request_light.configure(httpSettings.http && httpSettings.http.proxy, httpSettings.http && httpSettings.http.proxyStrictSSL);
  const headers = {"Accept-Encoding": "gzip, deflate"};
  if (cachedETag) {
    headers["If-None-Match"] = cachedETag;
  }
  return import_request_light.xhr({url: uri, followRedirects: 5, headers}).then(async (response) => {
    const etag = response.headers["etag"];
    if (typeof etag === "string") {
      await schemaCache.putSchema(uri, etag, response.responseText);
    }
    return response.responseText;
  }).then((text) => {
    return text;
  }).catch(async (error) => {
    if (error.status === 304) {
      const content = await schemaCache.getSchema(uri);
      if (content === void 0) {
        console.error(`Cannot read cached content for: ${uri}, trying to load again`);
        delete headers["If-None-Match"];
        return import_request_light.xhr({url: uri, followRedirects: 5, headers}).then((response) => {
          return response.responseText;
        }).catch((err) => {
          return createReject(err);
        });
      }
      return content;
    }
    if (schemaCache.getETag(uri)) {
      const content = schemaCache.getSchema(uri);
      if (content) {
        return content;
      }
    }
    return createReject(error);
  });
}
function createReject(error) {
  return Promise.reject(error.responseText || import_request_light.getErrorStatusDescription(error.status) || error.toString());
}

// src/list.ts
var import_coc4 = __toModule(require("coc.nvim"));

// node_modules/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `[${38 + offset};2;${red};${green};${blue}m`;
function assembleStyles() {
  const codes = new Map();
  const styles = {
    modifier: {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };
  styles.color.gray = styles.color.blackBright;
  styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
  styles.color.grey = styles.color.blackBright;
  styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `[${style[0]}m`,
        close: `[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "[39m";
  styles.bgColor.close = "[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value: (red, green, blue) => {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value: (hex) => {
        const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let {colorString} = matches.groups;
        if (colorString.length === 3) {
          colorString = colorString.split("").map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value: (code) => {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// src/list.ts
var getJSONSchemas = new import_coc4.RequestType("yaml/get/all/jsonSchemas");
function yellow(str) {
  return `${ansi_styles_default.yellow.open}${str}${ansi_styles_default.yellow.close}`;
}
function gray(str) {
  return `${ansi_styles_default.gray.open}${str}${ansi_styles_default.gray.close}`;
}
var SchemaList = class {
  constructor(client) {
    this.client = client;
    this.description = "Select associate yaml schema with current file";
    this.name = "yamlschemas";
    this.defaultAction = "choose";
    this.actions = [];
    this.actions.push({
      name: "choose",
      execute: (item) => {
        let {uri, schema} = (Array.isArray(item) ? item[0] : item).data;
        this.update(uri, schema);
      },
      multiple: false
    });
  }
  update(fileUri, schema) {
    const settings = import_coc4.workspace.getConfiguration("yaml").get("schemas");
    const newSettings = Object.assign({}, settings);
    deleteExistingFilePattern(newSettings, fileUri);
    const schemaURI = schema.uri;
    const schemaSettings = newSettings[schemaURI];
    if (schemaSettings) {
      if (Array.isArray(schemaSettings)) {
        schemaSettings.push(fileUri);
      } else if (typeof schemaSettings === "string") {
        newSettings[schemaURI] = [schemaSettings, fileUri];
      }
    } else {
      newSettings[schemaURI] = fileUri;
    }
    import_coc4.workspace.getConfiguration("yaml").update("schemas", newSettings);
  }
  async loadItems(context, token) {
    var _a;
    const {client} = this;
    let items = [];
    if (!client.started) {
      throw new Error("yaml language client not running");
    }
    let doc = import_coc4.workspace.getDocument(context.buffer.id);
    if (!doc || !doc.attached) {
      throw new Error("current buffer not attached");
    }
    if (doc.languageId !== "yaml") {
      throw new Error("current buffer filetype is not yaml");
    }
    const schemas = await client.sendRequest(getJSONSchemas, doc.uri);
    if (token.isCancellationRequested)
      return;
    for (const val of schemas) {
      let label = (_a = val.name) != null ? _a : val.uri;
      if (val.usedForCurrentFile)
        label = yellow(label);
      if (val.description)
        label = label + ` ${gray(val.description)}`;
      const item = {
        label,
        data: {
          schema: val,
          uri: doc.uri
        }
      };
      items.push(item);
    }
    items.sort((a, b) => {
      var _a2, _b;
      if ((_a2 = a.data.schema) == null ? void 0 : _a2.usedForCurrentFile) {
        return -1;
      }
      if ((_b = b.data.schema) == null ? void 0 : _b.usedForCurrentFile) {
        return 1;
      }
      return a.label.localeCompare(b.label);
    });
    return items;
  }
};
var list_default = SchemaList;
function deleteExistingFilePattern(settings, fileUri) {
  for (const key in settings) {
    if (Object.prototype.hasOwnProperty.call(settings, key)) {
      const element = settings[key];
      if (Array.isArray(element)) {
        const filePatterns = element.filter((val) => val !== fileUri);
        settings[key] = filePatterns;
      }
      if (element === fileUri) {
        delete settings[key];
      }
    }
  }
  return settings;
}

// src/index.ts
var import_util = __toModule(require("util"));
var import_fs = __toModule(require("fs"));
var SettingIds;
(function(SettingIds2) {
  SettingIds2.maxItemsComputed = "yaml.maxItemsComputed";
})(SettingIds || (SettingIds = {}));
var StorageIds;
(function(StorageIds2) {
  StorageIds2.maxItemsExceededInformation = "yaml.maxItemsExceededInformation";
})(StorageIds || (StorageIds = {}));
var SchemaAssociationNotification;
(function(SchemaAssociationNotification2) {
  SchemaAssociationNotification2.type = new import_coc5.NotificationType("json/schemaAssociations");
})(SchemaAssociationNotification || (SchemaAssociationNotification = {}));
var FSReadFile;
(function(FSReadFile2) {
  FSReadFile2.type = new import_coc5.RequestType("fs/readFile");
})(FSReadFile || (FSReadFile = {}));
var VSCodeContentRequestRegistration;
(function(VSCodeContentRequestRegistration2) {
  VSCodeContentRequestRegistration2.type = new import_coc5.NotificationType("yaml/registerVSCodeContentRequest");
})(VSCodeContentRequestRegistration || (VSCodeContentRequestRegistration = {}));
var VSCodeContentRequest;
(function(VSCodeContentRequest2) {
  VSCodeContentRequest2.type = new import_coc5.RequestType("vscode/content");
})(VSCodeContentRequest || (VSCodeContentRequest = {}));
var DynamicCustomSchemaRequestRegistration;
(function(DynamicCustomSchemaRequestRegistration2) {
  DynamicCustomSchemaRequestRegistration2.type = new import_coc5.NotificationType("yaml/registerCustomSchemaRequest");
})(DynamicCustomSchemaRequestRegistration || (DynamicCustomSchemaRequestRegistration = {}));
var ResultLimitReachedNotification;
(function(ResultLimitReachedNotification2) {
  ResultLimitReachedNotification2.type = new import_coc5.NotificationType("yaml/resultLimitReached");
})(ResultLimitReachedNotification || (ResultLimitReachedNotification = {}));
var SchemaSelectionRequests;
(function(SchemaSelectionRequests2) {
  SchemaSelectionRequests2.type = new import_coc5.NotificationType("yaml/supportSchemaSelection");
  SchemaSelectionRequests2.schemaStoreInitialized = new import_coc5.NotificationType("yaml/schema/store/initialized");
})(SchemaSelectionRequests || (SchemaSelectionRequests = {}));
function activate(context) {
  const serverModule = context.asAbsolutePath("./dist/languageserver.js");
  const config = import_coc5.workspace.getConfiguration("yaml");
  if (!config.get("enable", true))
    return;
  const debugOptions = {execArgv: ["--nolazy", "--inspect=6009"]};
  const serverOptions = {
    run: {module: serverModule, transport: import_coc5.TransportKind.ipc, options: {execArgv: config.get("execArgv", [])}},
    debug: {module: serverModule, transport: import_coc5.TransportKind.ipc, options: debugOptions}
  };
  const clientOptions = {
    documentSelector: [{language: "yaml"}, {language: "dockercompose"}, {pattern: "*.y(a)ml"}],
    synchronize: {
      fileEvents: [import_coc5.workspace.createFileSystemWatcher("**/*.?(e)y?(a)ml"), import_coc5.workspace.createFileSystemWatcher("**/*.json")]
    },
    revealOutputChannelOn: import_coc5.RevealOutputChannelOn.Never
  };
  const client = new import_coc5.LanguageClient("yaml", "YAML Support", serverOptions, clientOptions);
  const schemaExtensionAPI = new SchemaExtensionAPI(client);
  context.subscriptions.push(import_coc5.services.registLanguageClient(client));
  context.subscriptions.push(import_coc5.listManager.registerList(new list_default(client)));
  context.subscriptions.push(import_coc5.commands.registerCommand("yaml.selectSchema", () => {
    import_coc5.workspace.nvim.command(`CocList yamlschemas`, true);
  }));
  const schemaCache = new JSONSchemaCache(context.storagePath, context.globalState, (msg) => {
    client.outputChannel.appendLine(msg);
  });
  const statusBarItem = new status_item_default(client);
  context.subscriptions.push(statusBarItem);
  context.subscriptions.push(import_coc5.workspace.registerTextDocumentContentProvider("json-schema", new JSONSchemaDocumentContentProvider(schemaCache, schemaExtensionAPI)));
  client.onReady().then(() => {
    client.sendNotification(SchemaAssociationNotification.type, getSchemaAssociations());
    import_coc5.extensions.onDidActiveExtension(() => {
      client.sendNotification(SchemaAssociationNotification.type, getSchemaAssociations());
    });
    import_coc5.extensions.onDidUnloadExtension(() => {
      client.sendNotification(SchemaAssociationNotification.type, getSchemaAssociations());
    });
    client.sendNotification(DynamicCustomSchemaRequestRegistration.type);
    client.sendNotification(VSCodeContentRequestRegistration.type);
    client.sendNotification(SchemaSelectionRequests.type);
    client.onRequest(CUSTOM_SCHEMA_REQUEST, (resource) => {
      return schemaExtensionAPI.requestCustomSchema(resource);
    });
    client.onRequest(CUSTOM_CONTENT_REQUEST, (uri) => {
      return schemaExtensionAPI.requestCustomSchemaContent(uri);
    });
    client.onRequest(FSReadFile.type, (fsPath) => {
      return import_util.promisify(import_fs.default.readFile)(fsPath, "utf8");
    });
    client.onRequest(VSCodeContentRequest.type, (uri) => {
      return getJsonSchemaContent(uri, schemaCache);
    });
    client.onNotification(SchemaSelectionRequests.schemaStoreInitialized, () => {
      statusBarItem.init();
    });
    client.onNotification(ResultLimitReachedNotification.type, async (message) => {
      const shouldPrompt = context.globalState.get(StorageIds.maxItemsExceededInformation) !== false;
      if (shouldPrompt) {
        const ok = "Ok";
        const openSettings = "Open Settings";
        const neverAgain = "Don't Show Again";
        const pick = await import_coc5.window.showInformationMessage(`${message}
Use setting '${SettingIds.maxItemsComputed}' to configure the limit.`, ok, openSettings, neverAgain);
        if (pick === neverAgain) {
          await context.globalState.update(StorageIds.maxItemsExceededInformation, false);
        } else if (pick === openSettings) {
          const {nvim} = import_coc5.workspace;
          nvim.command("CocConfig", true);
        }
      }
    });
  });
  return schemaExtensionAPI;
}
function getSchemaAssociations() {
  const associations = [];
  import_coc5.extensions.all.forEach((extension) => {
    const packageJSON = extension.packageJSON;
    if (packageJSON && packageJSON.contributes && packageJSON.contributes.yamlValidation) {
      const yamlValidation = packageJSON.contributes.yamlValidation;
      if (Array.isArray(yamlValidation)) {
        yamlValidation.forEach((jv) => {
          let {fileMatch, url} = jv;
          if (typeof fileMatch === "string") {
            fileMatch = [fileMatch];
          }
          if (Array.isArray(fileMatch) && typeof url === "string") {
            let uri = url;
            if (uri[0] === "." && uri[1] === "/") {
              uri = joinPath(import_coc5.Uri.file(extension.extensionPath), uri).toString();
            }
            fileMatch = fileMatch.map((fm) => {
              if (fm[0] === "%") {
                fm = fm.replace(/%APP_SETTINGS_HOME%/, "/User");
                fm = fm.replace(/%MACHINE_SETTINGS_HOME%/, "/Machine");
                fm = fm.replace(/%APP_WORKSPACES_HOME%/, "/Workspaces");
              } else if (!fm.match(/^(\w+:\/\/|\/|!)/)) {
                fm = "/" + fm;
              }
              return fm;
            });
            associations.push({fileMatch, uri});
          }
        });
      }
    }
  });
  return associations;
}
//# sourceMappingURL=index.js.map
