"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateImplStubs = void 0;
const coc_nvim_1 = require("coc.nvim");
const binaries_1 = require("../binaries");
const tools_1 = require("./tools");
const interfaceRegex = /^(\w+ \*?\w+ )?([\w./-]+)$/;
async function generateImplStubs(document) {
    try {
        const implInput = await coc_nvim_1.window.requestInput("Enter receiver and interface [f *File io.Closer]");
        if (implInput == null) {
            coc_nvim_1.window.showMessage("No input detected! Aborting.", "warning");
            return;
        }
        const matches = implInput.match(interfaceRegex);
        if (!matches) {
            throw Error(`Cannot parse input: ${implInput}`);
        }
        const edit = await runGoImpl(document, [matches[1], matches[2]]);
        await coc_nvim_1.workspace.applyEdit({ changes: { [document.uri]: [edit] } });
    }
    catch (error) {
        coc_nvim_1.window.showMessage(error, "error");
    }
}
exports.generateImplStubs = generateImplStubs;
async function runGoImpl(document, args) {
    const stdout = await (0, tools_1.execTool)(binaries_1.IMPL, args);
    const { line } = await coc_nvim_1.window.getCursorPosition();
    const insertPos = { line: line + 1, character: 0 };
    const lineText = await coc_nvim_1.workspace.getLine(document.uri, line);
    const newText = lineText.trim() === ''
        ? stdout
        : `\n${stdout}`;
    return {
        range: {
            start: insertPos,
            end: insertPos
        },
        newText
    };
}
//# sourceMappingURL=impl.js.map